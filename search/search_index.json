{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A toolbox to make working with QML models easier. <p>This repo contains some of the commonly used Ansaetze and coding stuff required for working with QML and Data-Reuploading models. There are also dedicated classes to calculate entanglement and expressiblity of a provided model as well as its Fourier coefficients. Checkout our Arxiv Paper to learn more.</p> <p>Curious?  Installing this package is as simple as with any other package </p> <p><pre><code>pip install qml-essentials\n</code></pre> or with the uv package manager: <pre><code>uv add qml-essentials\n</code></pre></p> <p>Once you have set things up, go ahead and checkout how to use qml-essentials.</p> <p> </p> <p> </p> <p>If you want to contribute, please refer to our CONTRIBUTING guide on Github.</p> <p>Do you want to use our software in a research project?  Please checkout the github repository and follow the instructions (\"Cite this repository\") there.</p>"},{"location":"ansaetze/","title":"Ansaetze","text":"<p>.. or Ansatzes as preferred by the english community. Anyway, we got various of the most-used Ansaetze implemented in this package. </p> <p>You can load them manually by <pre><code>from qml_essentials.ansaetze import Ansaetze\nall_ansaetze = Ansaetze.get_available()\n\nfor ansatz in all_ansaetze:\n    print(ansatz.__name__)\n</code></pre></p> <p>See the Overview at the end of this document for more details. However, usually you just want reference to them (by name) when instantiating a model. To get an overview of all the available Ansaetze, checkout the references.</p>"},{"location":"ansaetze/#custom_ansatz","title":"Custom Ansatz","text":"<p>If you want to implement your own ansatz, you can do so by inheriting from the <code>Circuit</code> class: <pre><code>import pennylane as qml\nimport pennylane.numpy as np\nfrom qml_essentials.ansaetze import Circuit\nfrom qml_essentials.ansaetze import PulseInformation as pinfo\nfrom typing import Optional\n\nclass MyHardwareEfficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return n_qubits * 3\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        n_params_RY = pinfo.num_params(\"RY\")\n        n_params_RZ = pinfo.num_params(\"RZ\")\n        n_params_CZ = pinfo.num_params(\"CZ\")\n\n        n_pulse_params = (num_params_RY + num_params_RZ) * n_qubits\n        n_pulse_params += num_params_CZ * (n_qubits - 1)\n\n        return pulse_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        w_idx = 0\n        for q in range(n_qubits):\n            qml.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            qml.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                qml.CZ(wires=[q, q + 1], **kwargs)\n</code></pre></p> <p>and then pass it to the model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n)\n</code></pre> The <code>**kwargs</code> allow both noise simulation and pulse simulation. A custom <code>Circuit</code> should define <code>n_pulse_params_per_layer</code> if it will use pulse simulation at some point, but may be omitted otherwise.</p> <p>Check out page Usage on how to proceed from here.</p>"},{"location":"ansaetze/#custom_encoding","title":"Custom Encoding","text":"<p>On model instantiation, you can choose how your inputs are encoded. The default encoding is \"RX\" which will result in a single RX rotation per qubit. You can change this behavior, by setting the optional <code>encoding</code> argument to - a string or a list of strings where each is checked agains the <code>Gates</code> class - a callable or a list of callables</p> <p>A callable must take an input, the wire where it's acting on and an optional noise_params dictionary. Let's look at an example, where we want to encode a two-dimensional input: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.ansaetze import Gates\n\ndef MyCustomEncoding(w, wires, **kwars):\n    Gates.RX(w[0], wires, **kwargs)\n    Gates.RY(w[1], wires, **kwargs)\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n    encoding=MyCustomEncoding,\n)\n\nmodel(inputs=[1, 2])\n</code></pre></p>"},{"location":"ansaetze/#noise","title":"Noise","text":"<p>You might have noticed, that the <code>build</code> method takes the additional input **kwargs, which we did not used so far. In general, all of the Ansatzes that are implemented in this package allow the additional input below which is a dictionary containing all the noise parameters of the circuit (here all with probability \\(0.0\\)): <pre><code>noise_params = {\n    \"BitFlip\": 0.0,\n    \"PhaseFlip\": 0.0,\n    \"AmplitudeDamping\": 0.0,\n    \"PhaseDamping\": 0.0,\n    \"Depolarizing\": 0.0,\n    \"MultiQubitDepolarizing\": 0.0,\n}\n</code></pre></p> <p>Providing this optional input will apply the corresponding noise to the model where the Bit Flip, Phase Flip, Depolarizing and Two-Qubit Depolarizing Channels are applied after each gate and the Amplitude and Phase Damping are applied at the end of the circuit.</p> <p>To demonstrate this, let's recall the custom ansatz <code>MyHardwareEfficient</code> defined in Custom Ansatz and extend the model's usage:</p> <pre><code>model(\n    model.params,\n    inputs=None,\n    execution_type=\"density\",\n    noise_params={\n        \"BitFlip\": 0.01,\n        \"PhaseFlip\": 0.02,\n        \"AmplitudeDamping\": 0.03,\n        \"PhaseDamping\": 0.04,\n        \"Depolarizing\": 0.05,\n        \"MultiQubitDepolarizing\": 0.06\n})\n</code></pre> <p>In addition to these decoherent errors, we can also apply a <code>GateError</code> which affects each parameterized gate as \\(w = w + \\mathcal{N}(0, \\epsilon)\\), where \\(\\sqrt{\\epsilon}\\) is the standard deviation of the noise, specified by the <code>GateError</code> key in the <code>noise_params</code> argument. It's important to note that, depending on the flag set in <code>Ansaetze.UnitaryGates.batch_gate_error</code>, the error will be applied to the entire batch of parameters (all parameters are affected in the same way) or to each parameter individually (default). This can be particularly usefull in a scenario where one would like to apply noise e.g. only on the encoding gates but wants to change them all uniformly. An example of this is provided in the following code:</p> <pre><code>from qml_essentials.ansaetze import UnitaryGates\n\nUnitaryGates.batch_gate_error = False\nmodel(\n    ...\n    noise_params={\n        \"GateError\": 0.01,\n    }\n)\n\ndef pqc_noise_free(*args, **kwargs):\n    kwargs[\"noise_params\"] = None\n    return pqc(*args, **kwargs)\nmodel.pqc = pqc_noise_free\n</code></pre> <p>Note: When using a noisy circuit, make sure to run the model with the <code>density</code> execution type.</p>"},{"location":"ansaetze/#pulse_simulation","title":"Pulse Simulation","text":"<p>Our framework allows constructing circuits at the pulse level, where each gate is implemented as a time-dependent control pulse rather than an abstract unitary. This provides a more fine grained access to the simulation of the underlying physical process. While we provide a developer-oriented overview in this section, we would like to highlight Tilmann's Bachelor's Thesis if you want to have a more detailled read into pulse-level simulation and quantum Fourier models.</p> <p>We implement a fundamental set of gates (RX, RY, RZ, CZ) upon which other, more complex gates can be built. The dependency graph is shown in the following figure:   In this graph, the edge weights represent the number child gates required to implement a particular gate. The gates at the bottom represent the fundamental gates.</p> <p>Generally, the gates are available through the same interface as the regular unitary gates. Pulse simulation can easily be enabled by adding the <code>mode=\"pulse\"</code> keyword argument, e.g.:</p> <pre><code>from qml_essentials.ansaetze import Gates\n\nGates.CY(wires=[0, 1], mode=\"pulse\")\n</code></pre>"},{"location":"ansaetze/#pulse_parameters_per_gate","title":"Pulse Parameters per Gate","text":"<p>You can use the <code>PulseInformation</code> class in <code>qml_essentials.ansaetze</code> to access both the number and optimized values of the pulse parameters for each gate. Consider the following code snippet:</p> <pre><code>from qml_essentials.ansaetze import PulseInformation as pinfo\n\ngate = \"CX\"\n\nprint(f\"Number of pulse parameters for {gate}: {pinfo.num_params(gate)}\")\n# Number of pulse parameters for CX: 9\n\ngate_instance = pinfo.gate_by_name(gate)\n\nprint(f\"Childs of {gate}: {gate_instance.childs}\")\n# Childs of CX: [H, CZ, H]\n\nprint(f\"All parameters of {gate}: {len(gate_instance.params)}\")\n# All parameters of CX: 9\n\nprint(f\"Leaf parameters of {gate}: {len(gate_instance.leaf_params)}\")\n# Leaf parameters of CX: 5\n</code></pre> <p>Looking back at the dependency graph, we can easily see where the discrepancy between the overall number parameters and the number of leaf parameters comes from. The CX gate is composed of two Hadamard gates which in turn are decomposed into RY and RZ gates respectively. By default, our implementation assumes, that you want to treat each rotational gate equally, thus the number of leaf parameters is just the \"unique\" number of parameter resulting after merging multiple occurencies of the same gate type. However, it is also possible to overwrite these behavior, as we will see in the following example.</p>"},{"location":"ansaetze/#calling_gates_in_pulse_mode","title":"Calling Gates in Pulse Mode","text":"<p>To execute a gate in pulse mode, provide <code>gate_mode=\"pulse\"</code> when calling the gate. Optional <code>pulse_params</code> can be passed; if omitted, optimized default values are used:</p> <pre><code>w = 3.14159\n\n# CX gate with default optimized pulse parameters \n# (gates of equal type will recieve equal pulse parameters)\nGates.CX(w, wires=0, gate_mode=\"pulse\")\n\n# CX gate with custom pulse parameters (overwriting default pulse parameters)\npulse_params = [0.5, 7.9218643, 22.0381298, 1.09409231, 0.31830953, 0.5, 7.9218643, 22.0381298, 1.09409231]\nGates.RX(w, wires=0, gate_mode=\"pulse\", pulse_params=pulse_params)\n</code></pre>"},{"location":"ansaetze/#building_ansatzes_in_pulse_mode","title":"Building Ansatzes in Pulse Mode","text":"<p>When building an ansatz in pulse mode (via a <code>Model</code>), the framework internally passes an array of ones as element-wise scalers for the optimized parameters. If <code>pulse_params</code> are provided for a model or gate, these are treated similarly as element-wise scalers to modify the default pulses. We again take advantage of the **kwargs and call:</p> <pre><code>model(gate_mode=\"pulse\", pulse_params=model.pulse_params_scaler * 1.5)\n</code></pre> <p>Here, input and params are inferred from the <code>Model</code> instance, and we scale all pulse parameters by a factor of 1.5. Currently there is no way to change the raw values of pulse parameter through the model api directly.</p> <p>Similar to the input and standard parameters, we also support batching for the <code>pulse_params</code> argument, meaning that you can also pass a batched array of pulse parameters of e.g. size 2 to as follows:</p> <pre><code>model(pulse_params=np.repeat(model.pulse_params, 2, axis=-1), gate_mode=\"pulse\")\n</code></pre> <p>Note: Pulse-level simulation currently does not support noise channels. Mixing with noise will raise an error.  </p>"},{"location":"ansaetze/#quantum_optimal_control_qoc","title":"Quantum Optimal Control (QOC)","text":"<p>Our package provides a QOC interface for directly optimizing pulse parameters for specific gates.  </p> <p>QOC is currently WIP, therefore only minimal documentation is provided</p> <p>Conceptually the provided QOC class contains methods to create test circuits (<code>create_GATE</code>) which return two circuits, one using the pulse level implementation of <code>GATE</code> and the other using the unitary level implementation of <code>GATE</code>. For the specific implementation of these methods, we refer to the documentation of the <code>QOC</code> class. To test a broad range of states, each of these circuits does not only include the <code>GATE</code> itself, but other, unitary based gates as well. Those usually take a paramter <code>w</code>, allowing to sweep through the parameter space and validate if <code>GATE</code> acutally mimics its unitary counterpart.</p> <p>Without any parameter specification, we can initialize the QOC class:</p> <pre><code>from qml_essentials.qoc import QOC\n\nqoc = QOC()\n</code></pre> <p>For a detailled description of available arguments, we refer to the documentation of the <code>QOC</code> class. Now, we can select a gate of pass <code>sel_gates=\"all\"</code> when calling <code>optimize_all</code>:</p> <pre><code>qoc.optimize_all(sel_gates=\"GATE\")\n</code></pre> <p>which will run the optimization for the specified gate. The output of the optimization is logged to <code>qoc_logs.csv</code> whereas the resulting pulse parameters are stored in <code>qoc_results.csv</code>.</p> <p>For further examples we refer to our \"Pulses\" notebook .</p> <p>With the optimized pulse parameters we can generate a fidelities plot as follows:</p> <p> </p> <p>Note that in this plot, the phase error is shown as \\(1-\\text{phase error}\\) to align it with the fidelity scale.</p>"},{"location":"ansaetze/#overview","title":"Overview","text":"<p>This section shows an overview of all the available Ansaetze in our package. Most of the circuits are implemented according to to the original paper by Sim et al.. Note that Circuit 10 deviates from the original implementation!</p> <p>Oh and in case you need a refresh on the rotational axes and their corresponding states, here is a Bloch sphere  :</p> <p></p>"},{"location":"ansaetze/#no_ansatz","title":"No Ansatz","text":""},{"location":"ansaetze/#circuit_1","title":"Circuit 1","text":""},{"location":"ansaetze/#circuit_2","title":"Circuit 2","text":""},{"location":"ansaetze/#circuit_3","title":"Circuit 3","text":""},{"location":"ansaetze/#circuit_4","title":"Circuit 4","text":""},{"location":"ansaetze/#circuit_6","title":"Circuit 6","text":""},{"location":"ansaetze/#circuit_9","title":"Circuit 9","text":""},{"location":"ansaetze/#circuit_10","title":"Circuit 10","text":""},{"location":"ansaetze/#circuit_15","title":"Circuit 15","text":""},{"location":"ansaetze/#circuit_16","title":"Circuit 16","text":""},{"location":"ansaetze/#circuit_17","title":"Circuit 17","text":""},{"location":"ansaetze/#circuit_18","title":"Circuit 18","text":""},{"location":"ansaetze/#circuit_19","title":"Circuit 19","text":""},{"location":"ansaetze/#no_entangling","title":"No Entangling","text":""},{"location":"ansaetze/#strongly_entangling","title":"Strongly Entangling","text":""},{"location":"ansaetze/#hardware_efficient","title":"Hardware Efficient","text":""},{"location":"ansaetze/#ghz","title":"GHZ","text":""},{"location":"coefficients/","title":"Coefficients","text":"<p>A characteristic property of any Fourier model are its coefficients. Our package can, given a model, calculate the corresponding coefficients.</p> <p>In the simplest case, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.coefficients import Coefficients\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\ncoeffs, freqs = Coefficients.get_spectrum(model)\n</code></pre></p> <p>Here, the coefficients are stored in the <code>coeffs</code> variable, and the corresponding frequency indices are stored in the <code>freqs</code> variable.</p> <p>But wait! There is much more to this. Let's keep on reading if you're curious .</p>"},{"location":"coefficients/#detailled_explanation","title":"Detailled Explanation","text":"<p>To visualize what happens, let's create a very simplified Fourier model <pre><code>class Model_Fct:\n    def __init__(self, c, f):\n        self.c = c\n        self.f = f\n        self.degree = (2*max(f)+1,)\n        self.frequencies = f\n        self.n_input_feat = 1\n\n    def __call__(self, inputs, **kwargs):\n        return np.sum([c * np.exp(-1j * inputs * f) for f, c in zip(self.f, self.c)], axis=0)\n</code></pre></p> <p>This model takes a vector of coefficients and frequencies on instantiation. When called, these coefficients and frequencies are used to compute the output of the model, which is the sum of sine functions determined by the length of the vectors. Let's try that for just two frequencies:</p> <pre><code>freqs = [-3, -1.5, 0, 1.5, 3]\ncoeffs = [1, 1, 0, 1, 1]\n\nfs = max(freqs) * 2 + 1\nmodel_fct = Model_Fct(coeffs, freqs)\n\nx = np.arange(0, 2 * np.pi, 2 * np.pi / fs)\nout = model_fct(x)\n</code></pre> <p>We can now calculate the Fast Fourier Transform of our model: <pre><code>X = np.fft.fft(out) / len(out)\nX_shift = np.fft.fftshift(X)\nX_freq = np.fft.fftfreq(X.size, 1/fs)\nX_freq_shift = np.fft.fftshift(X_freq)\n</code></pre> Note that calling <code>np.fft.fftshift</code> is not required from a technical point of view, but makes our spectrum nicely zero-centered and projected correctly.</p> <p> </p> <p>You may notice, that something isn't quite right here; we specified the frequencies [1.5,3] earlier, but get frequencies for [0,1,2,3]. This is because, we chose the wrong resolution for the FFT, i.e. the window length was too short. In our framework we can achieve the same and above, while simultanously applying the fix to our problem, i.e. setting <code>mts=2</code>. This additional variable effectively doubles the window length which gives us then the possibility to obtain frequencies \"between\" the integer valued frequencies seen above.</p> <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, mts=2, shift=True)\n</code></pre> <p> </p> <p>Note, that applying the shift can be controlled with the optional <code>shift</code> argument.</p> <p>Another important point is, that the <code>force_mean</code> flag is set, and the <code>execution_type</code> is is implicitly set to <code>expval</code>. This is mainly because, we require a single expectation value to calculate the coefficients.</p>"},{"location":"coefficients/#increasing_the_resolution","title":"Increasing the Resolution","text":"<p>You might have noticed that we choose our sampling frequency <code>fs</code> in such a way, that it just fulfills the Nyquist criterium. Also the number of samples <code>x</code> are just enough to sufficiently represent our function. In such a simplified scenario, this is fine, but there are cases, where we want to have more information both in the time and frequency domain. Therefore, two additional arguments exist in the <code>get_spectrum</code> method: - <code>mfs</code>: The multiplier for the highest frequency. Increasing this will increase the width of the spectrum - <code>mts</code>: The multiplier for the number of time samples. Increasing this will increase the resolution of the time domain and therefore \"add\" frequencies in between our original frequencies. - <code>trim</code>: Whether to remove the Nyquist frequency if spectrum is even. This will result in a symmetric spectrum</p> <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, mfs=2, mts=3, shift=True)\n</code></pre> <p> </p> <p>Note that, as the frequencies change with the <code>mts</code> argument, we have to take that into account when calculating the frequencies with the last call.</p> <p>Feel free to checkout our jupyter notebook if you would like to play around with this.</p> <p>A sidenote on the performance; Increasing the <code>mts</code> value effectively increases the input lenght that goes into the model. This means that <code>mts=2</code> will require twice the time to compute, which will be very noticable when running noisy simulations.</p>"},{"location":"coefficients/#power_spectral_density","title":"Power spectral density","text":"<p>In some cases it can be useful to get the power spectral density (PSD). As calculation of this metric might differ between the different research domains, we included a function to get the PSD of a given spectrum using the following formula:</p> \\[PSD = \\frac{2 (\\mathrm{Re}(F)^2+\\mathrm{Im}(F)^2)}{n_\\text{samples}^2}\\] <p>where \\(F\\) is the spectrum and \\(n_\\text{samples}\\) the length of the input vector.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p> </p>"},{"location":"coefficients/#analytic_coefficients","title":"Analytic Coefficients","text":"<p>All of the calculations above were performed by applying a Fast Fourier Transform to the output of our Model. However, we can also calculate the coefficients analytically.</p> <p>This can be achieved by the so called <code>FourierTree</code> class: <pre><code>from qml_essentials.coefficients import FourierTree\n\nfourier_tree = FourierTree(model)\nan_coeffs, an_freqs = fourier_tree.get_spectrum(force_mean=True)\n</code></pre></p> <p>Note that while this takes significantly longer to compute, it gives us the precise coefficients, solely depending on the parameters. We can verify this by comparing it to the previous results:</p> <p> </p>"},{"location":"coefficients/#technical_details","title":"Technical Details","text":"<p>We use an approach developed by Nemkov et al., which was later extended by Wiedmann et al.. The implementation is also inspired by the corresponding code for Nemkov et al.'s paper.</p> <p>In Nemkov et al.'s algorithm the first step is to separate Clifford and non-Clifford gates, such that all Clifford gates can be regarded as part of the observable, and the actual circuit only consists of Pauli rotations (cf. qml_essentials.utils.PauliCircuit). The main idea is then to split each Pauli rotation into sine and cosine product terms to obtain the coefficients, which are only dependent on the parameters of the circuit.</p> <p>Currently, our implementation supports only one input feature, albeit more are theoretical possible.</p>"},{"location":"coefficients/#multi-dimensional_coefficients","title":"Multi-Dimensional Coefficients","text":"<p>The <code>get_spectrum</code> method can also be used to calculate the coefficients of a model with multiple input dimensions. This feature can be enabled, by explicitly providing an encoding that supports multi-dimensional input, e.g. a list of single encodings (see Usage for details on how encodings are applied).  Currently, only the FFT-based method supports this.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000,\n    encoding=[\"RX\", \"RY\"]\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1\n, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p>Using a logarithmic color bar, one obtains the following 2D-spectrum:</p> <p> </p> <p>Note that \"X1\" refers to the \"RX\" encoding and \"X2\" to the \"RY\" encoding.</p> <p>In the multidimensional case, the <code>freqs</code> variable now contains the frequency indices for each dimension. This is an important detail, as due to the <code>data_reupload</code> argument, it is possible to have a different number of frequencies for each input dimension.</p>"},{"location":"coefficients/#fourier_coefficient_correlation_fcc","title":"Fourier Coefficient Correlation (FCC)","text":"<p>The FCC, as introduced in Fourier Fingerprints of Ansatzes in Quantum Machine Learning, is a metric that aims to predict the expected performance of an arbitrary Ansatz based on the the correlation between its Fourier modes. In this framework, the FCC for a given <code>model</code> can be obtained as follows:</p> <p><pre><code>from qml_essentials.coefficients import FCC\n\nmodel = Model(\n    n_qubits=6,\n    n_layers=1,\n    circuit_type=\"Hardware_Efficient\",\n    output_qubit=-1,\n    encoding=[\"RY\"],\n    use_multithreading=True,\n)\n\nfcc = FCC.get_fcc(\n    model=model,\n    n_samples=500,\n    seed=1000,\n)\n</code></pre> Returns <code>0.1442</code> as already in Fig. 3a of aforementioned paper.</p> <p>Optionally, you can choose a different correlation <code>method</code> (currently \"pearson\" and \"spearman\" are supported). Similar, other methods which require specifying <code>n_samples</code> (c.f. calculation of expressibility and entangling capability), methods in the <code>FCC</code> class take an optional parameter <code>scale</code> (defaults to <code>False</code>), which scales the number of samples depending on the number of qubits and the number of input features as \\(n_\\text{samples} \\cdot n_\\text{params} \\cdot 2^{n_\\text{qubits}} \\cdot n_\\text{features}\\).</p> <p>As described in our paper, the FCC is calculated as the mean of the Fourier fingerprint, which in turn can be obtained separately as follows:</p> <pre><code>fingerprint = FCC.get_fourier_fingerprint(\n    model=model,\n    n_samples=500,\n    seed=1000,\n)\n</code></pre> <p> </p> <p>Note that actually calculating the FCC as it is shown in the paper, requires removing all the redundant entries in the fingerprint. This is implicitly done in <code>FCC.get_fourier_fingerprint</code> (and controlled using the <code>trim_redundant</code> argument), by - removing all negative frequencies (because their coefficients are complex conjugates of the positive frequencies) - removing symmetries inside the correlation matrix (the Fourier fingerprint), e.g. \\(c_{0,1} = c_{1,0}\\) Note that <code>get_fcc</code> also (by default) trims down the fingerprint before calculating the actual FCC. </p> <p>Both <code>get_fcc</code> and <code>get_fourier_fingerprint</code> support a <code>weight</code> parameter, which can be used to weight the correlation matrix, such that high-frequency components receive a lower weight. Intuitively this adresses the issue, that low frequency components have a higher impact on the mean-squared error (c.f. App. D in our paper). </p>"},{"location":"entanglement/","title":"Entanglement","text":"<p>As one of the fundamental aspects of quantum computing, entanglement plays also an important role in quantum machine learning. Our package offers various methods for calculating the entangling capability of a particular model.</p>"},{"location":"entanglement/#meyer-wallach","title":"Meyer-Wallach","text":"<p>In the simplest case, using the Meyer-Wallach measure, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.entanglement import Entanglement\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\nent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000\n)\n</code></pre></p> <p>Here, <code>n_samples</code> is the number of samples for the parameters, sampled according to the default initialization strategy of the model, and <code>seed</code> is the random number generator seed.</p> <p>Note, that every function in this class accepts keyword-arguments which are being passed to the model call, so you could e.g. enable caching by</p> <pre><code>ent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000\n)\n</code></pre> <p>If you set <code>n_samples=None</code>, we will use the currently stored parameters of the model to estimate the degree of entanglement.</p>"},{"location":"entanglement/#bell-measurement","title":"Bell-Measurement","text":"<p>An alternate method for calculating the entangling capability is the Bell-Measurement method. We can utilize this by</p> <pre><code>ent_cap = Entanglement.bell_measurements(\n    model, n_samples=1000, seed=1000\n)\n</code></pre>"},{"location":"entanglement/#relative_entropy","title":"Relative Entropy","text":"<p>While calculating entanglement using the Meyer-Wallach or Bell-Measurements method works great for noiseless circuits, it won't result in the correct values when being used together with incoherent noise. To account for this, you can use the Relative Entropy method as follows: </p> <pre><code>ent_cap = Entanglement.relative_entropy(\n    model, n_samples=1000, n_sigmas=10, seed=1000, noise_params={\"BitFlip\": 0.1}\n)\n</code></pre> <p>Note that this method takes an additional parameter <code>n_sigmas</code>, which is the number of density matrices of the next separable state that we use for comparison. The runtime scales with <code>n_sigmas</code>\\(\\times\\)<code>n_samples</code> and both increase exponentially if <code>scale=True</code> is set.</p> <p>Internally, we compare the states, obtained from the PQC, against those from a GHZ state of the same size (which we consider the next separable state). This approach is explained in detail in this paper and illustrated in the following figure:</p> <p></p>"},{"location":"entanglement/#entanglement_of_formation","title":"Entanglement of Formation","text":"<p>Another possibility to compute the entanglement of a noisy circuit is the Entanglement of Formation. Similar to the relative entropy of entanglement, this measure presents an approximation, and can be used via:</p> <pre><code>ent_cap = Entanglement.entanglement_of_formation(\n    model, n_samples=1000, seed=1000, noise_params={\"BitFlip\": 0.1}\n)\n</code></pre> <p>For a technical description we refer to the review by Plenio and Virmani. The general idea is that a mixed state gets decomposed into pure states with respective probabilities using the eigendecomposition of the density matrix. Then, entanglement is computed for each pure state, weighted by the eigenvalue. In our implementation, we use the Meyer-Wallach measure for this purpose.</p> <p>Note however, that the decomposition is not unique! Therefore, this measure presents the entanglement for some decomposition into pure states, not necessarily the one that is anticipated when applying the Kraus channels. This becomes particularly evident, when computing the entanglement of a noisy GHZ-circuit. To prevent unintended decompositions for pure states, the methods of EF and Meyer-Wallach are equivalent for these.</p>"},{"location":"entanglement/#concentratable_entanglement","title":"Concentratable Entanglement","text":"<p>This measure, introduced in Computable and operationally meaningful multipartite entanglement measures, utilizes a parallelized SWAP test to compute the entanglement of a given model with the advantage of having only a constant depth circuit while not requiring access to the density matrix.</p> <pre><code>ent_cap = Entanglement.concentratable_entanglement(\n    model, n_samples=1000, seed=1000\n)\n</code></pre>"},{"location":"expressibility/","title":"Expressibility","text":"<p>Our package allows you estimate the expressiblity of a given model. <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"HardwareEfficient\",\n)\n\ninput_domain, bins, dist_circuit = Expressibility.state_fidelities(\n    seed=1000,\n    n_samples=200,\n    n_bins=10,\n    n_input_samples=5,\n    input_domain=[0, 2*np.pi],\n    model=model,\n)\n</code></pre></p> <p>Here, <code>n_bins</code> is the number of bins that you want to use in the histogram, <code>n_samples</code> is the number of parameter sets to generate (using the default initialization strategy of the model), <code>n_input_samples</code> is the number of samples for the input domain in \\([0, 2\\pi]\\), and <code>seed</code> is the random number generator seed.</p> <p>Note that <code>state_fidelities</code> accepts keyword arguments that are being passed to the model call. This allows you to utilize e.g. caching.</p> <p>Next, you can calculate the Haar integral (as reference), by <pre><code>input_domain, dist_haar = Expressibility.haar_integral(\n    n_qubits=2,\n    n_bins=10,\n    cache=True,\n)\n</code></pre></p> <p>Finally, the Kullback-Leibler divergence allows you to see how well the particular circuit performs compared to the Haar integral: <pre><code>kl_dist = Expressibility.kullback_leibler_divergence(dist_circuit, dist_haar).mean()\n</code></pre></p>"},{"location":"references/","title":"References","text":""},{"location":"references/#ansaetze","title":"Ansaetze","text":"<pre><code>from qml_essentials.ansaetze import Ansaetze\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Ansaetze:\n    def get_available():\n        return [\n            Ansaetze.No_Ansatz,\n            Ansaetze.Circuit_1,\n            Ansaetze.Circuit_2,\n            Ansaetze.Circuit_3,\n            Ansaetze.Circuit_4,\n            Ansaetze.Circuit_6,\n            Ansaetze.Circuit_9,\n            Ansaetze.Circuit_10,\n            Ansaetze.Circuit_15,\n            Ansaetze.Circuit_16,\n            Ansaetze.Circuit_17,\n            Ansaetze.Circuit_18,\n            Ansaetze.Circuit_19,\n            Ansaetze.No_Entangling,\n            Ansaetze.Strongly_Entangling,\n            Ansaetze.Hardware_Efficient,\n            Ansaetze.GHZ,\n        ]\n\n    class No_Ansatz(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            pass\n\n    class GHZ(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for the GHZ circuit.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Total number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"H\")\n            n_params += (n_qubits - 1) * PulseInformation.num_params(\"CX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            Gates.H(0, **kwargs)\n\n            for q in range(n_qubits - 1):\n                Gates.CX([q, q + 1], **kwargs)\n\n    class Hardware_Efficient(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Hardware Efficient Ansatz.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit.\n            \"\"\"\n            if n_qubits &lt; 2:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 3\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for the\n            Hardware Efficient Ansatz.\n\n            This counts all parameters needed if the circuit is used at the\n            pulse level. It includes contributions from single-qubit rotations\n            (`RY` and `RZ`) and multi-qubit gates (`CX`) if more than one qubit\n            is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_CX = (n_qubits // 2) + ((n_qubits - 1) // 2)\n            n_CX += 1 if n_qubits &gt; 2 else 0\n            n_params += n_CX * PulseInformation.num_params(\"CX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Hardware-Efficient ansatz, as proposed in\n            https://arxiv.org/pdf/2309.03279\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CX(wires=[(2 * q), (2 * q + 1)], **kwargs)\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CX(wires=[(2 * q + 1), (2 * q + 2)], **kwargs)\n                if n_qubits &gt; 2:\n                    Gates.CX(wires=[(n_qubits - 1), 0], **kwargs)\n\n    class Circuit_19(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_19.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_19.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRX`) on each qubit if more than one\n            qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            if n_qubits &gt; 1:\n                n_params += PulseInformation.num_params(\"CRX\") * n_qubits\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit19 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n    class Circuit_18(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_18.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_18.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRZ`) on each qubit if more than one\n            qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            if n_qubits &gt; 1:\n                n_params += PulseInformation.num_params(\"CRZ\") * n_qubits\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit18 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n    class Circuit_15(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_15.\n\n            The number of parameters is 2 times the number of qubits.\n            A warning is logged if the number of qubits is less than 2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 2\n            else:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_15.\n\n            This includes contributions from single-qubit rotations (`RY`) on all\n            qubits, and controlled rotations (`CX`) on each qubit if more than one\n            qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n            if n_qubits &gt; 1:\n                n_params += 2 * PulseInformation.num_params(\"CX\") * n_qubits\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit15 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        **kwargs,\n                    )\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                        **kwargs,\n                    )\n\n    class Circuit_9(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_9.\n\n            The number of parameters is equal to the number of qubits.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            return n_qubits\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_9.\n\n            This includes contributions from single-qubit rotations (`H`, `RX`) on all\n            qubits, and controlled rotations (`CZ`) on each qubit except one if more\n            than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"H\") * n_qubits\n            n_params += PulseInformation.num_params(\"RX\") * n_qubits\n\n            n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit9 ansatz.\n\n            Length of flattened vector must be n_qubits\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.H(wires=q, **kwargs)\n\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[n_qubits - q - 2, n_qubits - q - 1],\n                    **kwargs,\n                )\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n    class Circuit_6(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_6.\n\n            The total number of parameters is n_qubits*3+n_qubits**2, which is\n            the number of rotations n_qubits*3 plus the number of entangling gates\n            n_qubits**2.\n\n            If n_qubits is 1, the number of parameters is 4, and a warning is logged\n            since no entanglement is possible.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3 + n_qubits**2\n            else:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 4\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_6.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRX`) on each qubit twice except repeats\n            if more than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = 2 * PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += 2 * PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_CRX = n_qubits * (n_qubits - 1)\n            n_params += n_CRX * PulseInformation.num_params(\"CRX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            # TODO: implement\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit6 ansatz.\n\n            Length of flattened vector must be\n                n_qubits*4+n_qubits*(n_qubits-1) =\n                n_qubits*3+n_qubits**2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size\n                    n_layers*(n_qubits*3+n_qubits**2)\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for ql in range(n_qubits):\n                    for q in range(n_qubits):\n                        if q == ql:\n                            continue\n                        Gates.CRX(\n                            w[w_idx],\n                            wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                            **kwargs,\n                        )\n                        w_idx += 1\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n    class Circuit_1(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_1.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_9.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits only.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit1 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n    class Circuit_2(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_2.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_2.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CX`) on each qubit except one if more\n            than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            if n_qubits &gt; 1:\n                n_params += PulseInformation.num_params(\"CX\") * (n_qubits - 1)\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit2 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            for q in range(n_qubits - 1):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    **kwargs,\n                )\n\n    class Circuit_3(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Calculates the number of parameters per layer for Circuit3.\n\n            The number of parameters per layer is given by the number of qubits, with\n            each qubit contributing 3 parameters. The last qubit only contributes 2\n            parameters because it is the target qubit for the controlled gates.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_3.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRZ`) on each qubit except one if more\n            than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRZ\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-(n_qubits - 1), None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit3 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            for q in range(n_qubits - 1):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    **kwargs,\n                )\n                w_idx += 1\n\n    class Circuit_4(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_4.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRX`) on each qubit except one if more\n            than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-(n_qubits - 1), None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit4 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            for q in range(n_qubits - 1):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    **kwargs,\n                )\n                w_idx += 1\n\n    class Circuit_10(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n            The number of parameters is calculated as n_qubits*2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_10.\n\n            This includes contributions from single-qubit rotations (`RY`) on all\n            qubits, controlled rotations (`CZ`) on each qubit except one if more\n            than one qubit is present and a final controlled rotation (`CZ`) if\n            more than two qubits are present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n            n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n            n_params += PulseInformation.num_params(\"CZ\") if n_qubits &gt; 2 else 0\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit10 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            # constant gates, independent of layers. has to be fixed\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[\n                        (n_qubits - q - 2) % n_qubits,\n                        (n_qubits - q - 1) % n_qubits,\n                    ],\n                    **kwargs,\n                )\n            if n_qubits &gt; 2:\n                Gates.CZ(wires=[n_qubits - 1, 0], **kwargs)\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n    class Circuit_16(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_16.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRZ`) if more than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_CRZ = n_qubits * (n_qubits - 1) // 2\n            n_params += n_CRZ * PulseInformation.num_params(\"CRZ\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-(n_qubits - 1), None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit16 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n    class Circuit_17(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Circuit_17.\n\n            This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n            qubits, and controlled rotations (`CRX`) if more than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"RX\") * n_qubits\n            n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n            n_CRZ = n_qubits * (n_qubits - 1) // 2\n            n_params += n_CRZ * PulseInformation.num_params(\"CRX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-(n_qubits - 1), None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a Circuit17 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, **kwargs)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n    class Strongly_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Strongly Entangling ansatz.\n\n            The number of parameters is calculated as n_qubits*6.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &lt; 2:\n                warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 6\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for Strongly_Entangling\n            circuit.\n\n            This includes contributions from single-qubit rotations (`Rot`) on all\n            qubits, and controlled rotations (`CX`) if more than one qubit is present.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = 2 * PulseInformation.num_params(\"Rot\") * n_qubits\n\n            if n_qubits &gt; 1:\n                n_params += n_qubits * 2 * PulseInformation.num_params(\"CX\")\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs) -&gt; None:\n            \"\"\"\n            Creates a Strongly Entangling ansatz.\n\n            Length of flattened vector must be n_qubits*6\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*6\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    **kwargs,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(wires=[q, (q + 1) % n_qubits], **kwargs)\n\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    **kwargs,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[q, (q + n_qubits // 2) % n_qubits],\n                        **kwargs,\n                    )\n\n    class No_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the NoEntangling ansatz.\n\n            The number of parameters is calculated as n_qubits*3.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3\n\n        @staticmethod\n        def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of pulse parameters per layer for No_Entangling circuit.\n\n            This includes contributions from single-qubit rotations (`Rot`) on all\n            qubits only.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit.\n\n            Returns\n            -------\n            int\n                Number of pulse parameters required for one layer of the circuit.\n            \"\"\"\n            n_params = PulseInformation.num_params(\"Rot\") * n_qubits\n\n            return n_params\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, **kwargs):\n            \"\"\"\n            Creates a circuit without entangling, but with U3 gates on all qubits\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    **kwargs,\n                )\n                w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1","title":"<code>Circuit_1</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_1(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_1.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_9.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits only.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit1 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit1 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit1 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_1.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_1.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_9.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits only.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_9.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits only.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10","title":"<code>Circuit_10</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_10(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n        The number of parameters is calculated as n_qubits*2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_10.\n\n        This includes contributions from single-qubit rotations (`RY`) on all\n        qubits, controlled rotations (`CZ`) on each qubit except one if more\n        than one qubit is present and a final controlled rotation (`CZ`) if\n        more than two qubits are present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n        n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n        n_params += PulseInformation.num_params(\"CZ\") if n_qubits &gt; 2 else 0\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit10 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        # constant gates, independent of layers. has to be fixed\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[\n                    (n_qubits - q - 2) % n_qubits,\n                    (n_qubits - q - 1) % n_qubits,\n                ],\n                **kwargs,\n            )\n        if n_qubits &gt; 2:\n            Gates.CZ(wires=[n_qubits - 1, 0], **kwargs)\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit10 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit10 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    # constant gates, independent of layers. has to be fixed\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    for q in range(n_qubits - 1):\n        Gates.CZ(\n            wires=[\n                (n_qubits - q - 2) % n_qubits,\n                (n_qubits - q - 1) % n_qubits,\n            ],\n            **kwargs,\n        )\n    if n_qubits &gt; 2:\n        Gates.CZ(wires=[n_qubits - 1, 0], **kwargs)\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_10 ansatz.</p> <p>The number of parameters is calculated as n_qubits*2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n    The number of parameters is calculated as n_qubits*2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2  # constant gates not considered yet. has to be fixed\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_10.</p> <p>This includes contributions from single-qubit rotations (<code>RY</code>) on all qubits, controlled rotations (<code>CZ</code>) on each qubit except one if more than one qubit is present and a final controlled rotation (<code>CZ</code>) if more than two qubits are present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_10.\n\n    This includes contributions from single-qubit rotations (`RY`) on all\n    qubits, controlled rotations (`CZ`) on each qubit except one if more\n    than one qubit is present and a final controlled rotation (`CZ`) if\n    more than two qubits are present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n    n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n    n_params += PulseInformation.num_params(\"CZ\") if n_qubits &gt; 2 else 0\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15","title":"<code>Circuit_15</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_15(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_15.\n\n        The number of parameters is 2 times the number of qubits.\n        A warning is logged if the number of qubits is less than 2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 2\n        else:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_15.\n\n        This includes contributions from single-qubit rotations (`RY`) on all\n        qubits, and controlled rotations (`CX`) on each qubit if more than one\n        qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n        if n_qubits &gt; 1:\n            n_params += 2 * PulseInformation.num_params(\"CX\") * n_qubits\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit15 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    **kwargs,\n                )\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                    **kwargs,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit15 ansatz.</p> <p>Length of flattened vector must be n_qubits*2 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit15 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                **kwargs,\n            )\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                **kwargs,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_15.</p> <p>The number of parameters is 2 times the number of qubits. A warning is logged if the number of qubits is less than 2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_15.\n\n    The number of parameters is 2 times the number of qubits.\n    A warning is logged if the number of qubits is less than 2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 2\n    else:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_15.</p> <p>This includes contributions from single-qubit rotations (<code>RY</code>) on all qubits, and controlled rotations (<code>CX</code>) on each qubit if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_15.\n\n    This includes contributions from single-qubit rotations (`RY`) on all\n    qubits, and controlled rotations (`CX`) on each qubit if more than one\n    qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n\n    if n_qubits &gt; 1:\n        n_params += 2 * PulseInformation.num_params(\"CX\") * n_qubits\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16","title":"<code>Circuit_16</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_16(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_16.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRZ`) if more than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_CRZ = n_qubits * (n_qubits - 1) // 2\n        n_params += n_CRZ * PulseInformation.num_params(\"CRZ\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-(n_qubits - 1), None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit16 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    **kwargs,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    **kwargs,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit16 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit16 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                **kwargs,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-(n_qubits - 1), None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_16 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_16.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRZ</code>) if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_16.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRZ`) if more than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_CRZ = n_qubits * (n_qubits - 1) // 2\n    n_params += n_CRZ * PulseInformation.num_params(\"CRZ\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17","title":"<code>Circuit_17</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_17(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_17.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRX`) if more than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_CRZ = n_qubits * (n_qubits - 1) // 2\n        n_params += n_CRZ * PulseInformation.num_params(\"CRX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-(n_qubits - 1), None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit17 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    **kwargs,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    **kwargs,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit17 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit17 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                **kwargs,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-(n_qubits - 1), None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_17 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_17.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRX</code>) if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_17.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRX`) if more than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_CRZ = n_qubits * (n_qubits - 1) // 2\n    n_params += n_CRZ * PulseInformation.num_params(\"CRX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18","title":"<code>Circuit_18</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_18(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_18.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_18.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRZ`) on each qubit if more than one\n        qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        if n_qubits &gt; 1:\n            n_params += PulseInformation.num_params(\"CRZ\") * n_qubits\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit18 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    **kwargs,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit18 ansatz.</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit18 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_18.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_18.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_18.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRZ</code>) on each qubit if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_18.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRZ`) on each qubit if more than one\n    qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    if n_qubits &gt; 1:\n        n_params += PulseInformation.num_params(\"CRZ\") * n_qubits\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19","title":"<code>Circuit_19</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_19(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_19.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_19.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRX`) on each qubit if more than one\n        qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        if n_qubits &gt; 1:\n            n_params += PulseInformation.num_params(\"CRX\") * n_qubits\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit19 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    **kwargs,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit19 ansatz.</p> <p>Length of flattened vector must be n_qubits*3 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit19 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_19.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_19.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_19.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRX</code>) on each qubit if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_19.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRX`) on each qubit if more than one\n    qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    if n_qubits &gt; 1:\n        n_params += PulseInformation.num_params(\"CRX\") * n_qubits\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2","title":"<code>Circuit_2</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_2(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_2.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_2.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CX`) on each qubit except one if more\n        than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        if n_qubits &gt; 1:\n            n_params += PulseInformation.num_params(\"CX\") * (n_qubits - 1)\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit2 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        for q in range(n_qubits - 1):\n            Gates.CX(\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                **kwargs,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit2 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit2 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    for q in range(n_qubits - 1):\n        Gates.CX(\n            wires=[n_qubits - q - 1, n_qubits - q - 2],\n            **kwargs,\n        )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_2.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_2.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_2.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CX</code>) on each qubit except one if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_2.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CX`) on each qubit except one if more\n    than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    if n_qubits &gt; 1:\n        n_params += PulseInformation.num_params(\"CX\") * (n_qubits - 1)\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3","title":"<code>Circuit_3</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_3(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Calculates the number of parameters per layer for Circuit3.\n\n        The number of parameters per layer is given by the number of qubits, with\n        each qubit contributing 3 parameters. The last qubit only contributes 2\n        parameters because it is the target qubit for the controlled gates.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_3.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRZ`) on each qubit except one if more\n        than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRZ\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-(n_qubits - 1), None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit3 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        for q in range(n_qubits - 1):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit3 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit3 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    for q in range(n_qubits - 1):\n        Gates.CRZ(\n            w[w_idx],\n            wires=[n_qubits - q - 1, n_qubits - q - 2],\n            **kwargs,\n        )\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-(n_qubits - 1), None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Calculates the number of parameters per layer for Circuit3.</p> <p>The number of parameters per layer is given by the number of qubits, with each qubit contributing 3 parameters. The last qubit only contributes 2 parameters because it is the target qubit for the controlled gates.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Calculates the number of parameters per layer for Circuit3.\n\n    The number of parameters per layer is given by the number of qubits, with\n    each qubit contributing 3 parameters. The last qubit only contributes 2\n    parameters because it is the target qubit for the controlled gates.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_3.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRZ</code>) on each qubit except one if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_3.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRZ`) on each qubit except one if more\n    than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRZ\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4","title":"<code>Circuit_4</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_4(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_4.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRX`) on each qubit except one if more\n        than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-(n_qubits - 1), None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit4 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        for q in range(n_qubits - 1):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                **kwargs,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit4 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit4 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    for q in range(n_qubits - 1):\n        Gates.CRX(\n            w[w_idx],\n            wires=[n_qubits - q - 1, n_qubits - q - 2],\n            **kwargs,\n        )\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-(n_qubits - 1), None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_4 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_4.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRX</code>) on each qubit except one if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_4.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRX`) on each qubit except one if more\n    than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_params += (n_qubits - 1) * PulseInformation.num_params(\"CRX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6","title":"<code>Circuit_6</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_6(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_6.\n\n        The total number of parameters is n_qubits*3+n_qubits**2, which is\n        the number of rotations n_qubits*3 plus the number of entangling gates\n        n_qubits**2.\n\n        If n_qubits is 1, the number of parameters is 4, and a warning is logged\n        since no entanglement is possible.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3 + n_qubits**2\n        else:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 4\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_6.\n\n        This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n        qubits, and controlled rotations (`CRX`) on each qubit twice except repeats\n        if more than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = 2 * PulseInformation.num_params(\"RX\") * n_qubits\n        n_params += 2 * PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_CRX = n_qubits * (n_qubits - 1)\n        n_params += n_CRX * PulseInformation.num_params(\"CRX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        # TODO: implement\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit6 ansatz.\n\n        Length of flattened vector must be\n            n_qubits*4+n_qubits*(n_qubits-1) =\n            n_qubits*3+n_qubits**2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size\n                n_layers*(n_qubits*3+n_qubits**2)\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for ql in range(n_qubits):\n                for q in range(n_qubits):\n                    if q == ql:\n                        continue\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                        **kwargs,\n                    )\n                    w_idx += 1\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit6 ansatz.</p> <p>Length of flattened vector must be     n_qubits4+n_qubits(n_qubits-1) =     n_qubits3+n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size         n_layers(n_qubits3+n_qubits**2) n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit6 ansatz.\n\n    Length of flattened vector must be\n        n_qubits*4+n_qubits*(n_qubits-1) =\n        n_qubits*3+n_qubits**2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size\n            n_layers*(n_qubits*3+n_qubits**2)\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for ql in range(n_qubits):\n            for q in range(n_qubits):\n                if q == ql:\n                    continue\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                    **kwargs,\n                )\n                w_idx += 1\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    # TODO: implement\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_6.</p> <p>The total number of parameters is n_qubits3+n_qubits2, which is the number of rotations n_qubits3 plus the number of entangling gates n_qubits**2.</p> <p>If n_qubits is 1, the number of parameters is 4, and a warning is logged since no entanglement is possible.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_6.\n\n    The total number of parameters is n_qubits*3+n_qubits**2, which is\n    the number of rotations n_qubits*3 plus the number of entangling gates\n    n_qubits**2.\n\n    If n_qubits is 1, the number of parameters is 4, and a warning is logged\n    since no entanglement is possible.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3 + n_qubits**2\n    else:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 4\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_6.</p> <p>This includes contributions from single-qubit rotations (<code>RX</code>, <code>RZ</code>) on all qubits, and controlled rotations (<code>CRX</code>) on each qubit twice except repeats if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_6.\n\n    This includes contributions from single-qubit rotations (`RX`, `RZ`) on all\n    qubits, and controlled rotations (`CRX`) on each qubit twice except repeats\n    if more than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = 2 * PulseInformation.num_params(\"RX\") * n_qubits\n    n_params += 2 * PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_CRX = n_qubits * (n_qubits - 1)\n    n_params += n_CRX * PulseInformation.num_params(\"CRX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9","title":"<code>Circuit_9</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_9(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_9.\n\n        The number of parameters is equal to the number of qubits.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        return n_qubits\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Circuit_9.\n\n        This includes contributions from single-qubit rotations (`H`, `RX`) on all\n        qubits, and controlled rotations (`CZ`) on each qubit except one if more\n        than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"H\") * n_qubits\n        n_params += PulseInformation.num_params(\"RX\") * n_qubits\n\n        n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Circuit9 ansatz.\n\n        Length of flattened vector must be n_qubits\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.H(wires=q, **kwargs)\n\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[n_qubits - q - 2, n_qubits - q - 1],\n                **kwargs,\n            )\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit9 ansatz.</p> <p>Length of flattened vector must be n_qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Circuit9 ansatz.\n\n    Length of flattened vector must be n_qubits\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.H(wires=q, **kwargs)\n\n    for q in range(n_qubits - 1):\n        Gates.CZ(\n            wires=[n_qubits - q - 2, n_qubits - q - 1],\n            **kwargs,\n        )\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_9.</p> <p>The number of parameters is equal to the number of qubits.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_9.\n\n    The number of parameters is equal to the number of qubits.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    return n_qubits\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Circuit_9.</p> <p>This includes contributions from single-qubit rotations (<code>H</code>, <code>RX</code>) on all qubits, and controlled rotations (<code>CZ</code>) on each qubit except one if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Circuit_9.\n\n    This includes contributions from single-qubit rotations (`H`, `RX`) on all\n    qubits, and controlled rotations (`CZ`) on each qubit except one if more\n    than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"H\") * n_qubits\n    n_params += PulseInformation.num_params(\"RX\") * n_qubits\n\n    n_params += (n_qubits - 1) * PulseInformation.num_params(\"CZ\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.GHZ","title":"<code>GHZ</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class GHZ(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return 0\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for the GHZ circuit.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Total number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"H\")\n        n_params += (n_qubits - 1) * PulseInformation.num_params(\"CX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        Gates.H(0, **kwargs)\n\n        for q in range(n_qubits - 1):\n            Gates.CX([q, q + 1], **kwargs)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.GHZ.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for the GHZ circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.GHZ.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.GHZ.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Total number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for the GHZ circuit.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Total number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"H\")\n    n_params += (n_qubits - 1) * PulseInformation.num_params(\"CX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient","title":"<code>Hardware_Efficient</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Hardware_Efficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Hardware Efficient Ansatz.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit.\n        \"\"\"\n        if n_qubits &lt; 2:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 3\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for the\n        Hardware Efficient Ansatz.\n\n        This counts all parameters needed if the circuit is used at the\n        pulse level. It includes contributions from single-qubit rotations\n        (`RY` and `RZ`) and multi-qubit gates (`CX`) if more than one qubit\n        is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n        n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n        n_CX = (n_qubits // 2) + ((n_qubits - 1) // 2)\n        n_CX += 1 if n_qubits &gt; 2 else 0\n        n_params += n_CX * PulseInformation.num_params(\"CX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a Hardware-Efficient ansatz, as proposed in\n        https://arxiv.org/pdf/2309.03279\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n            Gates.RY(w[w_idx], wires=q, **kwargs)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CX(wires=[(2 * q), (2 * q + 1)], **kwargs)\n            for q in range((n_qubits - 1) // 2):\n                Gates.CX(wires=[(2 * q + 1), (2 * q + 2)], **kwargs)\n            if n_qubits &gt; 2:\n                Gates.CX(wires=[(n_qubits - 1), 0], **kwargs)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Hardware-Efficient ansatz, as proposed in https://arxiv.org/pdf/2309.03279</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a Hardware-Efficient ansatz, as proposed in\n    https://arxiv.org/pdf/2309.03279\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n        Gates.RY(w[w_idx], wires=q, **kwargs)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CX(wires=[(2 * q), (2 * q + 1)], **kwargs)\n        for q in range((n_qubits - 1) // 2):\n            Gates.CX(wires=[(2 * q + 1), (2 * q + 2)], **kwargs)\n        if n_qubits &gt; 2:\n            Gates.CX(wires=[(n_qubits - 1), 0], **kwargs)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Hardware Efficient Ansatz.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Hardware Efficient Ansatz.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit.\n    \"\"\"\n    if n_qubits &lt; 2:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for the Hardware Efficient Ansatz.</p> <p>This counts all parameters needed if the circuit is used at the pulse level. It includes contributions from single-qubit rotations (<code>RY</code> and <code>RZ</code>) and multi-qubit gates (<code>CX</code>) if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for the\n    Hardware Efficient Ansatz.\n\n    This counts all parameters needed if the circuit is used at the\n    pulse level. It includes contributions from single-qubit rotations\n    (`RY` and `RZ`) and multi-qubit gates (`CX`) if more than one qubit\n    is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = 2 * PulseInformation.num_params(\"RY\") * n_qubits\n    n_params += PulseInformation.num_params(\"RZ\") * n_qubits\n\n    n_CX = (n_qubits // 2) + ((n_qubits - 1) // 2)\n    n_CX += 1 if n_qubits &gt; 2 else 0\n    n_params += n_CX * PulseInformation.num_params(\"CX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling","title":"<code>No_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class No_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the NoEntangling ansatz.\n\n        The number of parameters is calculated as n_qubits*3.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for No_Entangling circuit.\n\n        This includes contributions from single-qubit rotations (`Rot`) on all\n        qubits only.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = PulseInformation.num_params(\"Rot\") * n_qubits\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs):\n        \"\"\"\n        Creates a circuit without entangling, but with U3 gates on all qubits\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                **kwargs,\n            )\n            w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a circuit without entangling, but with U3 gates on all qubits</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs):\n    \"\"\"\n    Creates a circuit without entangling, but with U3 gates on all qubits\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            **kwargs,\n        )\n        w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the NoEntangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*3.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the NoEntangling ansatz.\n\n    The number of parameters is calculated as n_qubits*3.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for No_Entangling circuit.</p> <p>This includes contributions from single-qubit rotations (<code>Rot</code>) on all qubits only.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for No_Entangling circuit.\n\n    This includes contributions from single-qubit rotations (`Rot`) on all\n    qubits only.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = PulseInformation.num_params(\"Rot\") * n_qubits\n\n    return n_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling","title":"<code>Strongly_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Strongly_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Strongly Entangling ansatz.\n\n        The number of parameters is calculated as n_qubits*6.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &lt; 2:\n            warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 6\n\n    @staticmethod\n    def n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of pulse parameters per layer for Strongly_Entangling\n        circuit.\n\n        This includes contributions from single-qubit rotations (`Rot`) on all\n        qubits, and controlled rotations (`CX`) if more than one qubit is present.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit.\n\n        Returns\n        -------\n        int\n            Number of pulse parameters required for one layer of the circuit.\n        \"\"\"\n        n_params = 2 * PulseInformation.num_params(\"Rot\") * n_qubits\n\n        if n_qubits &gt; 1:\n            n_params += n_qubits * 2 * PulseInformation.num_params(\"CX\")\n\n        return n_params\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, **kwargs) -&gt; None:\n        \"\"\"\n        Creates a Strongly Entangling ansatz.\n\n        Length of flattened vector must be n_qubits*6\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*6\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                **kwargs,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(wires=[q, (q + 1) % n_qubits], **kwargs)\n\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                **kwargs,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[q, (q + n_qubits // 2) % n_qubits],\n                    **kwargs,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build","title":"<code>build(w, n_qubits, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a Strongly Entangling ansatz.</p> <p>Length of flattened vector must be n_qubits*6</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*6 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, **kwargs) -&gt; None:\n    \"\"\"\n    Creates a Strongly Entangling ansatz.\n\n    Length of flattened vector must be n_qubits*6\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*6\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            **kwargs,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(wires=[q, (q + 1) % n_qubits], **kwargs)\n\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            **kwargs,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[q, (q + n_qubits // 2) % n_qubits],\n                **kwargs,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Strongly Entangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*6.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Strongly Entangling ansatz.\n\n    The number of parameters is calculated as n_qubits*6.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &lt; 2:\n        warnings.warn(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 6\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_pulse_params_per_layer","title":"<code>n_pulse_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of pulse parameters per layer for Strongly_Entangling circuit.</p> <p>This includes contributions from single-qubit rotations (<code>Rot</code>) on all qubits, and controlled rotations (<code>CX</code>) if more than one qubit is present.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_pulse_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_pulse_params_per_layer--returns","title":"Returns","text":"<p>int     Number of pulse parameters required for one layer of the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_pulse_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of pulse parameters per layer for Strongly_Entangling\n    circuit.\n\n    This includes contributions from single-qubit rotations (`Rot`) on all\n    qubits, and controlled rotations (`CX`) if more than one qubit is present.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit.\n\n    Returns\n    -------\n    int\n        Number of pulse parameters required for one layer of the circuit.\n    \"\"\"\n    n_params = 2 * PulseInformation.num_params(\"Rot\") * n_qubits\n\n    if n_qubits &gt; 1:\n        n_params += n_qubits * 2 * PulseInformation.num_params(\"CX\")\n\n    return n_params\n</code></pre>"},{"location":"references/#gates","title":"Gates","text":"<p>As the structure of the different classes used to realize pulse and unitary gates can be a bit confusing, the following diagram might help:</p> <p> </p> <pre><code>from qml_essentials.ansaetze import Gates\n</code></pre> <p>Dynamic accessor for quantum gates.</p> <p>Routes calls like <code>Gates.RX(...)</code> to either <code>UnitaryGates</code> or <code>PulseGates</code> depending on the <code>gate_mode</code> keyword (defaults to 'unitary').</p> <p>During circuit building, the pulse manager can be activated via <code>pulse_manager_context</code>, which slices the global model pulse parameters and passes them to each gate. Model pulse parameters act as element-wise scalers on the gate's optimized pulse parameters.</p> <pre><code>from qml_essentials.ansaetze import UnitaryGates\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates--parameters","title":"Parameters","text":"<p>gate_mode : str, optional     Determines the backend. 'unitary' for UnitaryGates, 'pulse' for PulseGates.     Defaults to 'unitary'.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates--examples","title":"Examples","text":"<p>Gates.RX(w, wires) Gates.RX(w, wires, gate_mode=\"unitary\") Gates.RX(w, wires, gate_mode=\"pulse\") Gates.RX(w, wires, pulse_params, gate_mode=\"pulse\")</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Gates(metaclass=GatesMeta):\n    \"\"\"\n    Dynamic accessor for quantum gates.\n\n    Routes calls like `Gates.RX(...)` to either `UnitaryGates` or `PulseGates`\n    depending on the `gate_mode` keyword (defaults to 'unitary').\n\n    During circuit building, the pulse manager can be activated via\n    `pulse_manager_context`, which slices the global model pulse parameters\n    and passes them to each gate. Model pulse parameters act as element-wise\n    scalers on the gate's optimized pulse parameters.\n\n    Parameters\n    ----------\n    gate_mode : str, optional\n        Determines the backend. 'unitary' for UnitaryGates, 'pulse' for PulseGates.\n        Defaults to 'unitary'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; Gates.RX(w, wires)\n    &gt;&gt;&gt; Gates.RX(w, wires, gate_mode=\"unitary\")\n    &gt;&gt;&gt; Gates.RX(w, wires, gate_mode=\"pulse\")\n    &gt;&gt;&gt; Gates.RX(w, wires, pulse_params, gate_mode=\"pulse\")\n    \"\"\"\n\n    def __getattr__(self, gate_name):\n        def handler(**kwargs):\n            return self._inner_getattr(gate_name, **kwargs)\n\n        return handler\n\n    @staticmethod\n    def _inner_getattr(gate_name, *args, **kwargs):\n        gate_mode = kwargs.pop(\"gate_mode\", \"unitary\")\n\n        # Backend selection and kwargs filtering\n        allowed_args = [\"w\", \"wires\", \"phi\", \"theta\", \"omega\"]\n        if gate_mode == \"unitary\":\n            gate_backend = UnitaryGates\n            allowed_args += [\"noise_params\", \"random_key\"]\n        elif gate_mode == \"pulse\":\n            gate_backend = PulseGates\n            allowed_args += [\"pulse_params\"]\n        else:\n            raise ValueError(\n                f\"Unknown gate mode: {gate_mode}. Use 'unitary' or 'pulse'.\"\n            )\n\n        if len(kwargs.keys() - allowed_args) &gt; 0:\n            # TODO: pulse params are always provided?\n            log.debug(\n                f\"Unsupported keyword arguments: {list(kwargs.keys() - allowed_args)}\"\n            )\n\n        kwargs = {k: v for k, v in kwargs.items() if k in allowed_args}\n        pulse_params = kwargs.get(\"pulse_params\")\n        pulse_mgr = getattr(Gates, \"_pulse_mgr\", None)\n\n        # TODO: rework this part to convert to valid PulseParams earlier\n        # Type check on pulse parameters\n        if pulse_params is not None:\n            # flatten pulse parameters\n            if isinstance(pulse_params, (list, tuple)):\n                flat_params = pulse_params\n\n            elif isinstance(pulse_params, jax.core.Tracer):\n                flat_params = np.ravel(pulse_params)\n\n            elif isinstance(pulse_params, (np.ndarray, np.ndarray)):\n                flat_params = pulse_params.flatten().tolist()\n            elif isinstance(pulse_params, PulseParams):\n                # extract the params in case a full object is given\n                kwargs[\"pulse_params\"] = pulse_params.params\n                flat_params = pulse_params.params.flatten().tolist()\n\n            else:\n                raise TypeError(f\"Unsupported pulse_params type: {type(pulse_params)}\")\n\n            # checks elements in flat parameters are real numbers or jax Tracer\n            if not all(\n                isinstance(x, (numbers.Real, jax.core.Tracer)) for x in flat_params\n            ):\n                raise TypeError(\n                    \"All elements in pulse_params must be int or float, \"\n                    f\"got {pulse_params}, type {type(pulse_params)}. \"\n                )\n\n        # Len check on pulse parameters\n        if pulse_params is not None and not isinstance(pulse_mgr, PulseParamManager):\n            n_params = PulseInformation.gate_by_name(gate_name).size\n            if len(flat_params) != n_params:\n                raise ValueError(\n                    f\"Gate '{gate_name}' expects {n_params} pulse parameters, \"\n                    f\"got {len(flat_params)}\"\n                )\n\n        # Pulse slicing + scaling\n        if gate_mode == \"pulse\" and isinstance(pulse_mgr, PulseParamManager):\n            n_params = PulseInformation.gate_by_name(gate_name).size\n            scalers = pulse_mgr.get(n_params)\n            base = PulseInformation.gate_by_name(gate_name).params\n            kwargs[\"pulse_params\"] = base * scalers\n\n        # Call the selected gate backend\n        gate = getattr(gate_backend, gate_name, None)\n        if gate is None:\n            raise AttributeError(\n                f\"'{gate_backend.__class__.__name__}' object \"\n                f\"has no attribute '{gate_name}'\"\n            )\n\n        return gate(*args, **kwargs)\n\n    @staticmethod\n    @contextmanager\n    def pulse_manager_context(pulse_params: np.ndarray):\n        \"\"\"Temporarily set the global pulse manager for circuit building.\"\"\"\n        Gates._pulse_mgr = PulseParamManager(pulse_params)\n        try:\n            yield\n        finally:\n            Gates._pulse_mgr = None\n\n    @staticmethod\n    def parse_gates(\n        gates: Union[str, Callable, List[Union[str, Callable]]],\n        set_of_gates=None,\n    ):\n        set_of_gates = set_of_gates or Gates\n\n        if isinstance(gates, str):\n            # if str, use the pennylane fct\n            parsed_gates = [getattr(set_of_gates, f\"{gates}\")]\n        elif isinstance(gates, list):\n            parsed_gates = []\n            for enc in gates:\n                # if list, check if str or callable\n                if isinstance(enc, str):\n                    parsed_gates.append(getattr(set_of_gates, f\"{enc}\"))\n                # check if callable\n                elif callable(enc):\n                    parsed_gates.append(enc)\n                else:\n                    raise ValueError(\n                        f\"Operation {enc} is not a valid gate or callable.\\\n                        Got {type(enc)}\"\n                    )\n        elif callable(gates):\n            # default to callable\n            parsed_gates = [gates]\n        elif gates is None:\n            parsed_gates = [lambda *args, **kwargs: None]\n        else:\n            raise ValueError(\n                f\"Operation {gates} is not a valid gate or callable or list of both.\"\n            )\n        return parsed_gates\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.pulse_manager_context","title":"<code>pulse_manager_context(pulse_params)</code>  <code>staticmethod</code>","text":"<p>Temporarily set the global pulse manager for circuit building.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\n@contextmanager\ndef pulse_manager_context(pulse_params: np.ndarray):\n    \"\"\"Temporarily set the global pulse manager for circuit building.\"\"\"\n    Gates._pulse_mgr = PulseParamManager(pulse_params)\n    try:\n        yield\n    finally:\n        Gates._pulse_mgr = None\n</code></pre>"},{"location":"references/#unitary_gates","title":"Unitary Gates","text":"<p>Collection of unitary quantum gates with optional noise simulation.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class UnitaryGates:\n    \"\"\"Collection of unitary quantum gates with optional noise simulation.\"\"\"\n\n    batch_gate_error = True\n\n    @staticmethod\n    def NQubitDepolarizingChannel(p: float, wires: List[int]) -&gt; qml.QubitChannel:\n        \"\"\"\n        Generate Kraus operators for n-qubit depolarizing channel.\n\n        The n-qubit depolarizing channel models uniform depolarizing noise\n        acting on n qubits simultaneously, useful for simulating realistic\n        multi-qubit noise affecting entangling gates.\n\n        Args:\n            p (float): Total probability of depolarizing error (0 \u2264 p \u2264 1).\n            wires (List[int]): Qubit indices on which the channel acts.\n                Must contain at least 2 qubits.\n\n        Returns:\n            qml.QubitChannel: PennyLane QubitChannel with Kraus operators\n                representing the depolarizing noise channel.\n\n        Raises:\n            ValueError: If p is not in [0, 1] or if fewer than 2 qubits provided.\n        \"\"\"\n\n        def n_qubit_depolarizing_kraus(p: float, n: int) -&gt; List[np.ndarray]:\n            if not (0.0 &lt;= p &lt;= 1.0):\n                raise ValueError(f\"Probability p must be between 0 and 1, got {p}\")\n            if n &lt; 2:\n                raise ValueError(f\"Number of qubits must be &gt;= 2, got {n}\")\n\n            Id = np.eye(2)\n            X = qml.matrix(qml.PauliX(0))\n            Y = qml.matrix(qml.PauliY(0))\n            Z = qml.matrix(qml.PauliZ(0))\n            paulis = [Id, X, Y, Z]\n\n            dim = 2**n\n            all_ops = []\n\n            # Generate all n-qubit Pauli tensor products:\n            for indices in itertools.product(range(4), repeat=n):\n                P = np.eye(1)\n                for idx in indices:\n                    P = np.kron(P, paulis[idx])\n                all_ops.append(P)\n\n            # Identity operator corresponds to all zeros indices (Id^n)\n            K0 = np.sqrt(1 - p * (4**n - 1) / (4**n)) * np.eye(dim)\n\n            kraus_ops = []\n            for i, P in enumerate(all_ops):\n                if i == 0:\n                    # Skip the identity, already handled as K0\n                    continue\n                kraus_ops.append(np.sqrt(p / (4**n)) * P)\n\n            return [K0] + kraus_ops\n\n        return qml.QubitChannel(n_qubit_depolarizing_kraus(p, len(wires)), wires=wires)\n\n    @staticmethod\n    def Noise(\n        wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply noise channels to specified qubits.\n\n        Applies various single-qubit and multi-qubit noise channels based on\n        the provided noise parameters dictionary.\n\n        Args:\n            wires (Union[int, List[int]]): Qubit index or list of qubit indices\n                to apply noise to.\n            noise_params (Optional[Dict[str, float]]): Dictionary of noise\n                parameters. Supported keys:\n                - \"BitFlip\" (float): Bit flip error probability\n                - \"PhaseFlip\" (float): Phase flip error probability\n                - \"Depolarizing\" (float): Single-qubit depolarizing probability\n                - \"MultiQubitDepolarizing\" (float): Multi-qubit depolarizing\n                  probability (applies if len(wires) &gt; 1)\n                All parameters default to 0.0 if not provided.\n\n        Returns:\n            None: Noise channels are applied in-place to the circuit.\n        \"\"\"\n        if noise_params is not None:\n            if isinstance(wires, int):\n                wires = [wires]  # single qubit gate\n\n            # noise on single qubits\n            for wire in wires:\n                bf = noise_params.get(\"BitFlip\", 0.0)\n                if bf &gt; 0:\n                    qml.BitFlip(bf, wires=wire)\n\n                pf = noise_params.get(\"PhaseFlip\", 0.0)\n                if pf &gt; 0:\n                    qml.PhaseFlip(pf, wires=wire)\n\n                dp = noise_params.get(\"Depolarizing\", 0.0)\n                if dp &gt; 0:\n                    qml.DepolarizingChannel(dp, wires=wire)\n\n            # noise on two-qubits\n            if len(wires) &gt; 1:\n                p = noise_params.get(\"MultiQubitDepolarizing\", 0.0)\n                if p &gt; 0:\n                    UnitaryGates.NQubitDepolarizingChannel(p, wires)\n\n    @staticmethod\n    def GateError(\n        w: Union[float, np.ndarray, List[float]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; Tuple[np.ndarray, jax.random.PRNGKey]:\n        \"\"\"\n        Apply gate error noise to rotation angle(s).\n\n        Adds Gaussian noise to gate rotation angles to simulate imperfect\n        gate implementations.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle(s) in radians.\n            noise_params (Optional[Dict[str, float]]): Dictionary with optional\n                \"GateError\" key specifying standard deviation of Gaussian noise.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for\n                stochastic noise generation.\n\n        Returns:\n            Tuple[np.ndarray, jax.random.PRNGKey]: Tuple containing:\n                - Modified rotation angle(s) with applied noise\n                - Updated JAX random key\n\n        Raises:\n            AssertionError: If noise_params contains \"GateError\" but random_key is None.\n        \"\"\"\n        if noise_params is not None and noise_params.get(\"GateError\", None) is not None:\n            assert (\n                random_key is not None\n            ), \"A random_key must be provided when using GateError\"\n\n            random_key, sub_key = safe_random_split(random_key)\n            w += noise_params[\"GateError\"] * jax.random.normal(\n                sub_key,\n                (\n                    w.shape\n                    if isinstance(w, np.ndarray) and UnitaryGates.batch_gate_error\n                    else (1,)\n                ),\n            )\n        return w, random_key\n\n    @staticmethod\n    def Rot(\n        phi: Union[float, np.ndarray, List[float]],\n        theta: Union[float, np.ndarray, List[float]],\n        omega: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply general rotation gate with optional noise.\n\n        Applies a three-angle rotation Rot(phi, theta, omega) with optional\n        gate errors and noise channels.\n\n        Args:\n            phi (Union[float, np.ndarray, List[float]]): First rotation angle.\n            theta (Union[float, np.ndarray, List[float]]): Second rotation angle.\n            omega (Union[float, np.ndarray, List[float]]): Third rotation angle.\n            wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n                Supports BitFlip, PhaseFlip, Depolarizing, and GateError.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        if noise_params is not None and \"GateError\" in noise_params:\n            phi, random_key = UnitaryGates.GateError(phi, noise_params, random_key)\n            theta, random_key = UnitaryGates.GateError(theta, noise_params, random_key)\n            omega, random_key = UnitaryGates.GateError(omega, noise_params, random_key)\n        qml.Rot(phi, theta, omega, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RX(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply X-axis rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Qubit index or indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.RX(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RY(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply Y-axis rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Qubit index or indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.RY(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RZ(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply Z-axis rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Qubit index or indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.RZ(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRX(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled X-rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.CRX(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRY(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled Y-rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.CRY(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRZ(\n        w: Union[float, np.ndarray, List[float]],\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled Z-rotation with optional noise.\n\n        Args:\n            w (Union[float, np.ndarray, List[float]]): Rotation angle.\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n        qml.CRZ(w, wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CX(\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-NOT (CNOT) gate with optional noise.\n\n        Args:\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n                (not used in this gate).\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        qml.CNOT(wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CY(\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-Y gate with optional noise.\n\n        Args:\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n                (not used in this gate).\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        qml.CY(wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CZ(\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-Z gate with optional noise.\n\n        Args:\n            wires (Union[int, List[int]]): Control and target qubit indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n                (not used in this gate).\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        qml.CZ(wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n\n    @staticmethod\n    def H(\n        wires: Union[int, List[int]],\n        noise_params: Optional[Dict[str, float]] = None,\n        random_key: Optional[jax.random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply Hadamard gate with optional noise.\n\n        Args:\n            wires (Union[int, List[int]]): Qubit index or indices.\n            noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n                (not used in this gate).\n\n        Returns:\n            None: Gate and noise are applied in-place to the circuit.\n        \"\"\"\n        qml.Hadamard(wires=wires)\n        UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CRX","title":"<code>CRX(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled X-rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRX(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled X-rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.CRX(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CRY","title":"<code>CRY(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled Y-rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRY(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled Y-rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.CRY(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CRZ","title":"<code>CRZ(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled Z-rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRZ(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled Z-rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.CRZ(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CX","title":"<code>CX(wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-NOT (CNOT) gate with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for compatibility (not used in this gate).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CX(\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled-NOT (CNOT) gate with optional noise.\n\n    Args:\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n            (not used in this gate).\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    qml.CNOT(wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CY","title":"<code>CY(wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-Y gate with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for compatibility (not used in this gate).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CY(\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled-Y gate with optional noise.\n\n    Args:\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n            (not used in this gate).\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    qml.CY(wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.CZ","title":"<code>CZ(wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-Z gate with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Control and target qubit indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for compatibility (not used in this gate).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CZ(\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply controlled-Z gate with optional noise.\n\n    Args:\n        wires (Union[int, List[int]]): Control and target qubit indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n            (not used in this gate).\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    qml.CZ(wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.GateError","title":"<code>GateError(w, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply gate error noise to rotation angle(s).</p> <p>Adds Gaussian noise to gate rotation angles to simulate imperfect gate implementations.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle(s) in radians.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary with optional \"GateError\" key specifying standard deviation of Gaussian noise.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for stochastic noise generation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, PRNGKey]</code> <p>Tuple[np.ndarray, jax.random.PRNGKey]: Tuple containing: - Modified rotation angle(s) with applied noise - Updated JAX random key</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If noise_params contains \"GateError\" but random_key is None.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef GateError(\n    w: Union[float, np.ndarray, List[float]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; Tuple[np.ndarray, jax.random.PRNGKey]:\n    \"\"\"\n    Apply gate error noise to rotation angle(s).\n\n    Adds Gaussian noise to gate rotation angles to simulate imperfect\n    gate implementations.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle(s) in radians.\n        noise_params (Optional[Dict[str, float]]): Dictionary with optional\n            \"GateError\" key specifying standard deviation of Gaussian noise.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for\n            stochastic noise generation.\n\n    Returns:\n        Tuple[np.ndarray, jax.random.PRNGKey]: Tuple containing:\n            - Modified rotation angle(s) with applied noise\n            - Updated JAX random key\n\n    Raises:\n        AssertionError: If noise_params contains \"GateError\" but random_key is None.\n    \"\"\"\n    if noise_params is not None and noise_params.get(\"GateError\", None) is not None:\n        assert (\n            random_key is not None\n        ), \"A random_key must be provided when using GateError\"\n\n        random_key, sub_key = safe_random_split(random_key)\n        w += noise_params[\"GateError\"] * jax.random.normal(\n            sub_key,\n            (\n                w.shape\n                if isinstance(w, np.ndarray) and UnitaryGates.batch_gate_error\n                else (1,)\n            ),\n        )\n    return w, random_key\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.H","title":"<code>H(wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply Hadamard gate with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for compatibility (not used in this gate).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef H(\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply Hadamard gate with optional noise.\n\n    Args:\n        wires (Union[int, List[int]]): Qubit index or indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for compatibility\n            (not used in this gate).\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    qml.Hadamard(wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.NQubitDepolarizingChannel","title":"<code>NQubitDepolarizingChannel(p, wires)</code>  <code>staticmethod</code>","text":"<p>Generate Kraus operators for n-qubit depolarizing channel.</p> <p>The n-qubit depolarizing channel models uniform depolarizing noise acting on n qubits simultaneously, useful for simulating realistic multi-qubit noise affecting entangling gates.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Total probability of depolarizing error (0 \u2264 p \u2264 1).</p> required <code>wires</code> <code>List[int]</code> <p>Qubit indices on which the channel acts. Must contain at least 2 qubits.</p> required <p>Returns:</p> Type Description <code>QubitChannel</code> <p>qml.QubitChannel: PennyLane QubitChannel with Kraus operators representing the depolarizing noise channel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If p is not in [0, 1] or if fewer than 2 qubits provided.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef NQubitDepolarizingChannel(p: float, wires: List[int]) -&gt; qml.QubitChannel:\n    \"\"\"\n    Generate Kraus operators for n-qubit depolarizing channel.\n\n    The n-qubit depolarizing channel models uniform depolarizing noise\n    acting on n qubits simultaneously, useful for simulating realistic\n    multi-qubit noise affecting entangling gates.\n\n    Args:\n        p (float): Total probability of depolarizing error (0 \u2264 p \u2264 1).\n        wires (List[int]): Qubit indices on which the channel acts.\n            Must contain at least 2 qubits.\n\n    Returns:\n        qml.QubitChannel: PennyLane QubitChannel with Kraus operators\n            representing the depolarizing noise channel.\n\n    Raises:\n        ValueError: If p is not in [0, 1] or if fewer than 2 qubits provided.\n    \"\"\"\n\n    def n_qubit_depolarizing_kraus(p: float, n: int) -&gt; List[np.ndarray]:\n        if not (0.0 &lt;= p &lt;= 1.0):\n            raise ValueError(f\"Probability p must be between 0 and 1, got {p}\")\n        if n &lt; 2:\n            raise ValueError(f\"Number of qubits must be &gt;= 2, got {n}\")\n\n        Id = np.eye(2)\n        X = qml.matrix(qml.PauliX(0))\n        Y = qml.matrix(qml.PauliY(0))\n        Z = qml.matrix(qml.PauliZ(0))\n        paulis = [Id, X, Y, Z]\n\n        dim = 2**n\n        all_ops = []\n\n        # Generate all n-qubit Pauli tensor products:\n        for indices in itertools.product(range(4), repeat=n):\n            P = np.eye(1)\n            for idx in indices:\n                P = np.kron(P, paulis[idx])\n            all_ops.append(P)\n\n        # Identity operator corresponds to all zeros indices (Id^n)\n        K0 = np.sqrt(1 - p * (4**n - 1) / (4**n)) * np.eye(dim)\n\n        kraus_ops = []\n        for i, P in enumerate(all_ops):\n            if i == 0:\n                # Skip the identity, already handled as K0\n                continue\n            kraus_ops.append(np.sqrt(p / (4**n)) * P)\n\n        return [K0] + kraus_ops\n\n    return qml.QubitChannel(n_qubit_depolarizing_kraus(p, len(wires)), wires=wires)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.Noise","title":"<code>Noise(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply noise channels to specified qubits.</p> <p>Applies various single-qubit and multi-qubit noise channels based on the provided noise parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or list of qubit indices to apply noise to.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Dictionary of noise parameters. Supported keys: - \"BitFlip\" (float): Bit flip error probability - \"PhaseFlip\" (float): Phase flip error probability - \"Depolarizing\" (float): Single-qubit depolarizing probability - \"MultiQubitDepolarizing\" (float): Multi-qubit depolarizing   probability (applies if len(wires) &gt; 1) All parameters default to 0.0 if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Noise channels are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Noise(\n    wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n) -&gt; None:\n    \"\"\"\n    Apply noise channels to specified qubits.\n\n    Applies various single-qubit and multi-qubit noise channels based on\n    the provided noise parameters dictionary.\n\n    Args:\n        wires (Union[int, List[int]]): Qubit index or list of qubit indices\n            to apply noise to.\n        noise_params (Optional[Dict[str, float]]): Dictionary of noise\n            parameters. Supported keys:\n            - \"BitFlip\" (float): Bit flip error probability\n            - \"PhaseFlip\" (float): Phase flip error probability\n            - \"Depolarizing\" (float): Single-qubit depolarizing probability\n            - \"MultiQubitDepolarizing\" (float): Multi-qubit depolarizing\n              probability (applies if len(wires) &gt; 1)\n            All parameters default to 0.0 if not provided.\n\n    Returns:\n        None: Noise channels are applied in-place to the circuit.\n    \"\"\"\n    if noise_params is not None:\n        if isinstance(wires, int):\n            wires = [wires]  # single qubit gate\n\n        # noise on single qubits\n        for wire in wires:\n            bf = noise_params.get(\"BitFlip\", 0.0)\n            if bf &gt; 0:\n                qml.BitFlip(bf, wires=wire)\n\n            pf = noise_params.get(\"PhaseFlip\", 0.0)\n            if pf &gt; 0:\n                qml.PhaseFlip(pf, wires=wire)\n\n            dp = noise_params.get(\"Depolarizing\", 0.0)\n            if dp &gt; 0:\n                qml.DepolarizingChannel(dp, wires=wire)\n\n        # noise on two-qubits\n        if len(wires) &gt; 1:\n            p = noise_params.get(\"MultiQubitDepolarizing\", 0.0)\n            if p &gt; 0:\n                UnitaryGates.NQubitDepolarizingChannel(p, wires)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.RX","title":"<code>RX(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply X-axis rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RX(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply X-axis rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Qubit index or indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.RX(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.RY","title":"<code>RY(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply Y-axis rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RY(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply Y-axis rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Qubit index or indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.RY(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.RZ","title":"<code>RZ(w, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply Z-axis rotation with optional noise.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>Union[float, ndarray, List[float]]</code> <p>Rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RZ(\n    w: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply Z-axis rotation with optional noise.\n\n    Args:\n        w (Union[float, np.ndarray, List[float]]): Rotation angle.\n        wires (Union[int, List[int]]): Qubit index or indices.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    w, random_key = UnitaryGates.GateError(w, noise_params, random_key)\n    qml.RZ(w, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.UnitaryGates.Rot","title":"<code>Rot(phi, theta, omega, wires, noise_params=None, random_key=None)</code>  <code>staticmethod</code>","text":"<p>Apply general rotation gate with optional noise.</p> <p>Applies a three-angle rotation Rot(phi, theta, omega) with optional gate errors and noise channels.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>Union[float, ndarray, List[float]]</code> <p>First rotation angle.</p> required <code>theta</code> <code>Union[float, ndarray, List[float]]</code> <p>Second rotation angle.</p> required <code>omega</code> <code>Union[float, ndarray, List[float]]</code> <p>Third rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply rotation to.</p> required <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>Noise parameters dictionary. Supports BitFlip, PhaseFlip, Depolarizing, and GateError.</p> <code>None</code> <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for noise.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate and noise are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Rot(\n    phi: Union[float, np.ndarray, List[float]],\n    theta: Union[float, np.ndarray, List[float]],\n    omega: Union[float, np.ndarray, List[float]],\n    wires: Union[int, List[int]],\n    noise_params: Optional[Dict[str, float]] = None,\n    random_key: Optional[jax.random.PRNGKey] = None,\n) -&gt; None:\n    \"\"\"\n    Apply general rotation gate with optional noise.\n\n    Applies a three-angle rotation Rot(phi, theta, omega) with optional\n    gate errors and noise channels.\n\n    Args:\n        phi (Union[float, np.ndarray, List[float]]): First rotation angle.\n        theta (Union[float, np.ndarray, List[float]]): Second rotation angle.\n        omega (Union[float, np.ndarray, List[float]]): Third rotation angle.\n        wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n        noise_params (Optional[Dict[str, float]]): Noise parameters dictionary.\n            Supports BitFlip, PhaseFlip, Depolarizing, and GateError.\n        random_key (Optional[jax.random.PRNGKey]): JAX random key for noise.\n\n    Returns:\n        None: Gate and noise are applied in-place to the circuit.\n    \"\"\"\n    if noise_params is not None and \"GateError\" in noise_params:\n        phi, random_key = UnitaryGates.GateError(phi, noise_params, random_key)\n        theta, random_key = UnitaryGates.GateError(theta, noise_params, random_key)\n        omega, random_key = UnitaryGates.GateError(omega, noise_params, random_key)\n    qml.Rot(phi, theta, omega, wires=wires)\n    UnitaryGates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#pulse_gates","title":"Pulse Gates","text":"<pre><code>from qml_essentials.ansaetze import PulseGates\n</code></pre> <p>Pulse-level implementations of quantum gates.</p> <p>Implements quantum gates using time-dependent Hamiltonians and pulse sequences, following the approach from https://doi.org/10.5445/IR/1000184129. Gates are decomposed using shaped Gaussian pulses with carrier modulation.</p> <p>Attributes:</p> Name Type Description <code>omega_q</code> <code>float</code> <p>Qubit frequency (10\u03c0).</p> <code>omega_c</code> <code>float</code> <p>Carrier frequency (10\u03c0).</p> <code>H_static</code> <code>ndarray</code> <p>Static Hamiltonian in qubit rotating frame.</p> <code>Id,</code> <code>X, Y, Z (np.ndarray</code> <p>Pauli matrices for gate construction.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class PulseGates:\n    \"\"\"\n    Pulse-level implementations of quantum gates.\n\n    Implements quantum gates using time-dependent Hamiltonians and pulse\n    sequences, following the approach from https://doi.org/10.5445/IR/1000184129.\n    Gates are decomposed using shaped Gaussian pulses with carrier modulation.\n\n    Attributes:\n        omega_q (float): Qubit frequency (10\u03c0).\n        omega_c (float): Carrier frequency (10\u03c0).\n        H_static (np.ndarray): Static Hamiltonian in qubit rotating frame.\n        Id, X, Y, Z (np.ndarray): Pauli matrices for gate construction.\n    \"\"\"\n\n    # NOTE: Implementation of S, RX, RY, RZ, CZ, CNOT/CX and H pulse level\n    #   gates closely follow https://doi.org/10.5445/IR/1000184129\n    # TODO: Mention deviations from the above?\n    omega_q = 10 * np.pi\n    omega_c = 10 * np.pi\n\n    H_static = np.array([[np.exp(1j * omega_q / 2), 0], [0, np.exp(-1j * omega_q / 2)]])\n\n    Id = np.eye(2, dtype=np.complex64)\n    X = np.array([[0, 1], [1, 0]])\n    Y = np.array([[0, -1j], [1j, 0]])\n    Z = np.array([[1, 0], [0, -1]])\n\n    @staticmethod\n    def _S(\n        p: Union[List[float], np.ndarray],\n        t: Union[float, List[float], np.ndarray],\n        phi_c: float,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Generate shaped Gaussian pulse envelope with carrier modulation.\n\n        Internal helper function for creating time-dependent pulse shapes\n        used in rotation gates. Not intended for direct circuit use.\n\n        Args:\n            p (Union[List[float], np.ndarray]): Pulse parameters [A, sigma]:\n                - A (float): Amplitude of the Gaussian envelope\n                - sigma (float): Width (standard deviation) of the Gaussian\n            t (Union[float, List[float], np.ndarray]): Time or time interval\n                for pulse application. If sequence, center is computed as midpoint.\n            phi_c (float): Phase offset for the cosine carrier.\n\n        Returns:\n            np.ndarray: Shaped pulse amplitude at time(s) t.\n        \"\"\"\n        A, sigma = p\n        t_c = (t[0] + t[1]) / 2 if isinstance(t, (list, tuple)) else t / 2\n\n        f = A * np.exp(-0.5 * ((t - t_c) / sigma) ** 2)\n        x = np.cos(PulseGates.omega_c * t + phi_c)\n\n        return f * x\n\n    @staticmethod\n    def Rot(\n        phi: float,\n        theta: float,\n        omega: float,\n        wires: Union[int, List[int]],\n        pulse_params: Optional[np.ndarray] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply general single-qubit rotation using pulse decomposition.\n\n        Decomposes a general rotation into RZ(phi) \u00b7 RY(theta) \u00b7 RZ(omega)\n        and applies each component using pulse-level implementations.\n\n        Args:\n            phi (float): First rotation angle.\n            theta (float): Second rotation angle.\n            omega (float): Third rotation angle.\n            wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gates are applied in-place to the circuit.\n        \"\"\"\n        params_RZ_1, params_RY, params_RZ_2 = PulseInformation.Rot.split_params(\n            pulse_params\n        )\n\n        PulseGates.RZ(phi, wires=wires, pulse_params=params_RZ_1)\n        PulseGates.RY(theta, wires=wires, pulse_params=params_RY)\n        PulseGates.RZ(omega, wires=wires, pulse_params=params_RZ_2)\n\n    @staticmethod\n    def RX(\n        w: float,\n        wires: Union[int, List[int]],\n        pulse_params: Optional[np.ndarray] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply X-axis rotation using pulse-level implementation.\n\n        Implements RX rotation using a shaped Gaussian pulse with optimized\n        envelope parameters.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n            pulse_params (Optional[np.ndarray]): Array containing pulse parameters\n                [A, sigma, t] for the Gaussian envelope. If None, uses optimized\n                parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        pulse_params = PulseInformation.RX.split_params(pulse_params)\n\n        def Sx(p, t):\n            return PulseGates._S(p, t, phi_c=np.pi) * w\n\n        _H = PulseGates.H_static.conj().T @ PulseGates.X @ PulseGates.H_static\n        _H = qml.Hermitian(_H, wires=wires)\n        H_eff = Sx * _H\n\n        qml.evolve(H_eff)([pulse_params[0:2]], pulse_params[2])\n\n    @staticmethod\n    def RY(\n        w: float,\n        wires: Union[int, List[int]],\n        pulse_params: Optional[np.ndarray] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply Y-axis rotation using pulse-level implementation.\n\n        Implements RY rotation using a shaped Gaussian pulse with optimized\n        envelope parameters.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n            pulse_params (Optional[np.ndarray]): Array containing pulse parameters\n                [A, sigma, t] for the Gaussian envelope. If None, uses optimized\n                parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        pulse_params = PulseInformation.RY.split_params(pulse_params)\n\n        def Sy(p, t):\n            return PulseGates._S(p, t, phi_c=-np.pi / 2) * w\n\n        _H = PulseGates.H_static.conj().T @ PulseGates.Y @ PulseGates.H_static\n        _H = qml.Hermitian(_H, wires=wires)\n        H_eff = Sy * _H\n\n        qml.evolve(H_eff)([pulse_params[0:2]], pulse_params[2])\n\n    @staticmethod\n    def RZ(\n        w: float, wires: Union[int, List[int]], pulse_params: Optional[float] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply Z-axis rotation using pulse-level implementation.\n\n        Implements RZ rotation using virtual Z rotations (phase tracking)\n        without physical pulse application.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n            pulse_params (Optional[float]): Duration parameter for the pulse.\n                Rotation angle = w * 2 * pulse_params. Defaults to 0.5 if None.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        pulse_params = PulseInformation.RZ.split_params(pulse_params)\n\n        _H = qml.Hermitian(PulseGates.Z, wires=wires)\n\n        def Sz(p, t):\n            return p * w\n\n        H_eff = Sz * _H\n\n        qml.evolve(H_eff)([pulse_params], 1)\n\n    @staticmethod\n    def H(\n        wires: Union[int, List[int]], pulse_params: Optional[np.ndarray] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply Hadamard gate using pulse decomposition.\n\n        Implements Hadamard as RZ(\u03c0) \u00b7 RY(\u03c0/2) with a correction phase,\n        using pulse-level implementations for each component.\n\n        Args:\n            wires (Union[int, List[int]]): Qubit index or indices to apply gate to.\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        pulse_params_RZ, pulse_params_RY = PulseInformation.H.split_params(pulse_params)\n\n        # qml.GlobalPhase(-np.pi / 2)  # this could act as substitute to Sc\n        PulseGates.RZ(np.pi, wires=wires, pulse_params=pulse_params_RZ)\n        PulseGates.RY(np.pi / 2, wires=wires, pulse_params=pulse_params_RY)\n\n        def Sc(p, t):\n            return -1.0\n\n        _H = np.pi / 2 * np.eye(2, dtype=np.complex64)\n        _H = qml.Hermitian(_H, wires=wires)\n        H_corr = Sc * _H\n\n        qml.evolve(H_corr)([0], 1)\n\n    @staticmethod\n    def CX(wires: List[int], pulse_params: Optional[np.ndarray] = None) -&gt; None:\n        \"\"\"\n        Apply CNOT gate using pulse decomposition.\n\n        Implements CNOT as H_target \u00b7 CZ \u00b7 H_target, where H and CZ are\n        applied using their respective pulse-level implementations.\n\n        Args:\n            wires (List[int]): Control and target qubit indices [control, target].\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        params_H_1, params_CZ, params_H_2 = PulseInformation.CX.split_params(\n            pulse_params\n        )\n\n        target = wires[1]\n\n        PulseGates.H(wires=target, pulse_params=params_H_1)\n        PulseGates.CZ(wires=wires, pulse_params=params_CZ)\n        PulseGates.H(wires=target, pulse_params=params_H_2)\n\n    @staticmethod\n    def CY(wires: List[int], pulse_params: Optional[np.ndarray] = None) -&gt; None:\n        \"\"\"\n        Apply controlled-Y gate using pulse decomposition.\n\n        Implements CY as RZ(-\u03c0/2)_target \u00b7 CX \u00b7 RZ(\u03c0/2)_target using\n        pulse-level implementations.\n\n        Args:\n            wires (List[int]): Control and target qubit indices [control, target].\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        params_RZ_1, params_CX, params_RZ_2 = PulseInformation.CY.split_params(\n            pulse_params\n        )\n\n        target = wires[1]\n\n        PulseGates.RZ(-np.pi / 2, wires=target, pulse_params=params_RZ_1)\n        PulseGates.CX(wires=wires, pulse_params=params_CX)\n        PulseGates.RZ(np.pi / 2, wires=target, pulse_params=params_RZ_2)\n\n    @staticmethod\n    def CZ(wires: List[int], pulse_params: Optional[float] = None) -&gt; None:\n        \"\"\"\n        Apply controlled-Z gate using pulse-level implementation.\n\n        Implements CZ using a two-qubit interaction Hamiltonian based on\n        ZZ coupling.\n\n        Args:\n            wires (List[int]): Control and target qubit indices.\n            pulse_params (Optional[float]): Time or duration parameter for\n                the pulse evolution. If None, uses optimized value.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        if pulse_params is None:\n            pulse_params = PulseInformation.CZ.params\n        else:\n            pulse_params = pulse_params\n\n        I_I = np.kron(PulseGates.Id, PulseGates.Id)\n        Z_I = np.kron(PulseGates.Z, PulseGates.Id)\n        I_Z = np.kron(PulseGates.Id, PulseGates.Z)\n        Z_Z = np.kron(PulseGates.Z, PulseGates.Z)\n\n        def Scz(p, t):\n            return p * np.pi\n\n        _H = (np.pi / 4) * (I_I - Z_I - I_Z + Z_Z)\n        _H = qml.Hermitian(_H, wires=wires)\n        H_eff = Scz * _H\n\n        qml.evolve(H_eff)([pulse_params], 1)\n\n    @staticmethod\n    def CRX(\n        w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-RX gate using pulse decomposition.\n\n        Implements CRX(w) as RZ(\u03c0/2) \u00b7 RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX \u00b7 RZ(-\u03c0/2)\n        applied to the target qubit, following arXiv:2408.01036.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (List[int]): Control and target qubit indices [control, target].\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        params_RZ_1, params_RY, params_CX_1, params_RY_2, params_CX_2, params_RZ_2 = (\n            PulseInformation.CRX.split_params(pulse_params)\n        )\n\n        target = wires[1]\n\n        PulseGates.RZ(np.pi / 2, wires=target, pulse_params=params_RZ_1)\n        PulseGates.RY(w / 2, wires=target, pulse_params=params_RY)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n        PulseGates.RY(-w / 2, wires=target, pulse_params=params_RY_2)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n        PulseGates.RZ(-np.pi / 2, wires=target, pulse_params=params_RZ_2)\n\n    @staticmethod\n    def CRY(\n        w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-RY gate using pulse decomposition.\n\n        Implements CRY(w) as RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX applied to the\n        target qubit, following arXiv:2408.01036.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (List[int]): Control and target qubit indices [control, target].\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        params_RY_1, params_CX_1, params_RY_2, params_CX_2 = (\n            PulseInformation.CRY.split_params(pulse_params)\n        )\n\n        target = wires[1]\n\n        PulseGates.RY(w / 2, wires=target, pulse_params=params_RY_1)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n        PulseGates.RY(-w / 2, wires=target, pulse_params=params_RY_2)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n\n    @staticmethod\n    def CRZ(\n        w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n    ) -&gt; None:\n        \"\"\"\n        Apply controlled-RZ gate using pulse decomposition.\n\n        Implements CRZ(w) as RZ(w/2) \u00b7 CX \u00b7 RZ(-w/2) \u00b7 CX applied to the\n        target qubit, following arXiv:2408.01036.\n\n        Args:\n            w (float): Rotation angle in radians.\n            wires (List[int]): Control and target qubit indices [control, target].\n            pulse_params (Optional[np.ndarray]): Pulse parameters for the\n                composing gates. If None, uses optimized parameters.\n\n        Returns:\n            None: Gate is applied in-place to the circuit.\n        \"\"\"\n        params_RZ_1, params_CX_1, params_RZ_2, params_CX_2 = (\n            PulseInformation.CRZ.split_params(pulse_params)\n        )\n\n        target = wires[1]\n\n        PulseGates.RZ(w / 2, wires=target, pulse_params=params_RZ_1)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n        PulseGates.RZ(-w / 2, wires=target, pulse_params=params_RZ_2)\n        PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CRX","title":"<code>CRX(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-RX gate using pulse decomposition.</p> <p>Implements CRX(w) as RZ(\u03c0/2) \u00b7 RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX \u00b7 RZ(-\u03c0/2) applied to the target qubit, following arXiv:2408.01036.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices [control, target].</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRX(\n    w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n) -&gt; None:\n    \"\"\"\n    Apply controlled-RX gate using pulse decomposition.\n\n    Implements CRX(w) as RZ(\u03c0/2) \u00b7 RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX \u00b7 RZ(-\u03c0/2)\n    applied to the target qubit, following arXiv:2408.01036.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (List[int]): Control and target qubit indices [control, target].\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    params_RZ_1, params_RY, params_CX_1, params_RY_2, params_CX_2, params_RZ_2 = (\n        PulseInformation.CRX.split_params(pulse_params)\n    )\n\n    target = wires[1]\n\n    PulseGates.RZ(np.pi / 2, wires=target, pulse_params=params_RZ_1)\n    PulseGates.RY(w / 2, wires=target, pulse_params=params_RY)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n    PulseGates.RY(-w / 2, wires=target, pulse_params=params_RY_2)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n    PulseGates.RZ(-np.pi / 2, wires=target, pulse_params=params_RZ_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CRY","title":"<code>CRY(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-RY gate using pulse decomposition.</p> <p>Implements CRY(w) as RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX applied to the target qubit, following arXiv:2408.01036.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices [control, target].</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRY(\n    w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n) -&gt; None:\n    \"\"\"\n    Apply controlled-RY gate using pulse decomposition.\n\n    Implements CRY(w) as RY(w/2) \u00b7 CX \u00b7 RY(-w/2) \u00b7 CX applied to the\n    target qubit, following arXiv:2408.01036.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (List[int]): Control and target qubit indices [control, target].\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    params_RY_1, params_CX_1, params_RY_2, params_CX_2 = (\n        PulseInformation.CRY.split_params(pulse_params)\n    )\n\n    target = wires[1]\n\n    PulseGates.RY(w / 2, wires=target, pulse_params=params_RY_1)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n    PulseGates.RY(-w / 2, wires=target, pulse_params=params_RY_2)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CRZ","title":"<code>CRZ(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-RZ gate using pulse decomposition.</p> <p>Implements CRZ(w) as RZ(w/2) \u00b7 CX \u00b7 RZ(-w/2) \u00b7 CX applied to the target qubit, following arXiv:2408.01036.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices [control, target].</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRZ(\n    w: float, wires: List[int], pulse_params: Optional[np.ndarray] = None\n) -&gt; None:\n    \"\"\"\n    Apply controlled-RZ gate using pulse decomposition.\n\n    Implements CRZ(w) as RZ(w/2) \u00b7 CX \u00b7 RZ(-w/2) \u00b7 CX applied to the\n    target qubit, following arXiv:2408.01036.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (List[int]): Control and target qubit indices [control, target].\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    params_RZ_1, params_CX_1, params_RZ_2, params_CX_2 = (\n        PulseInformation.CRZ.split_params(pulse_params)\n    )\n\n    target = wires[1]\n\n    PulseGates.RZ(w / 2, wires=target, pulse_params=params_RZ_1)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_1)\n    PulseGates.RZ(-w / 2, wires=target, pulse_params=params_RZ_2)\n    PulseGates.CX(wires=wires, pulse_params=params_CX_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CX","title":"<code>CX(wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply CNOT gate using pulse decomposition.</p> <p>Implements CNOT as H_target \u00b7 CZ \u00b7 H_target, where H and CZ are applied using their respective pulse-level implementations.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices [control, target].</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CX(wires: List[int], pulse_params: Optional[np.ndarray] = None) -&gt; None:\n    \"\"\"\n    Apply CNOT gate using pulse decomposition.\n\n    Implements CNOT as H_target \u00b7 CZ \u00b7 H_target, where H and CZ are\n    applied using their respective pulse-level implementations.\n\n    Args:\n        wires (List[int]): Control and target qubit indices [control, target].\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    params_H_1, params_CZ, params_H_2 = PulseInformation.CX.split_params(\n        pulse_params\n    )\n\n    target = wires[1]\n\n    PulseGates.H(wires=target, pulse_params=params_H_1)\n    PulseGates.CZ(wires=wires, pulse_params=params_CZ)\n    PulseGates.H(wires=target, pulse_params=params_H_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CY","title":"<code>CY(wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-Y gate using pulse decomposition.</p> <p>Implements CY as RZ(-\u03c0/2)_target \u00b7 CX \u00b7 RZ(\u03c0/2)_target using pulse-level implementations.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices [control, target].</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CY(wires: List[int], pulse_params: Optional[np.ndarray] = None) -&gt; None:\n    \"\"\"\n    Apply controlled-Y gate using pulse decomposition.\n\n    Implements CY as RZ(-\u03c0/2)_target \u00b7 CX \u00b7 RZ(\u03c0/2)_target using\n    pulse-level implementations.\n\n    Args:\n        wires (List[int]): Control and target qubit indices [control, target].\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    params_RZ_1, params_CX, params_RZ_2 = PulseInformation.CY.split_params(\n        pulse_params\n    )\n\n    target = wires[1]\n\n    PulseGates.RZ(-np.pi / 2, wires=target, pulse_params=params_RZ_1)\n    PulseGates.CX(wires=wires, pulse_params=params_CX)\n    PulseGates.RZ(np.pi / 2, wires=target, pulse_params=params_RZ_2)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.CZ","title":"<code>CZ(wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply controlled-Z gate using pulse-level implementation.</p> <p>Implements CZ using a two-qubit interaction Hamiltonian based on ZZ coupling.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>List[int]</code> <p>Control and target qubit indices.</p> required <code>pulse_params</code> <code>Optional[float]</code> <p>Time or duration parameter for the pulse evolution. If None, uses optimized value.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CZ(wires: List[int], pulse_params: Optional[float] = None) -&gt; None:\n    \"\"\"\n    Apply controlled-Z gate using pulse-level implementation.\n\n    Implements CZ using a two-qubit interaction Hamiltonian based on\n    ZZ coupling.\n\n    Args:\n        wires (List[int]): Control and target qubit indices.\n        pulse_params (Optional[float]): Time or duration parameter for\n            the pulse evolution. If None, uses optimized value.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    if pulse_params is None:\n        pulse_params = PulseInformation.CZ.params\n    else:\n        pulse_params = pulse_params\n\n    I_I = np.kron(PulseGates.Id, PulseGates.Id)\n    Z_I = np.kron(PulseGates.Z, PulseGates.Id)\n    I_Z = np.kron(PulseGates.Id, PulseGates.Z)\n    Z_Z = np.kron(PulseGates.Z, PulseGates.Z)\n\n    def Scz(p, t):\n        return p * np.pi\n\n    _H = (np.pi / 4) * (I_I - Z_I - I_Z + Z_Z)\n    _H = qml.Hermitian(_H, wires=wires)\n    H_eff = Scz * _H\n\n    qml.evolve(H_eff)([pulse_params], 1)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.H","title":"<code>H(wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply Hadamard gate using pulse decomposition.</p> <p>Implements Hadamard as RZ(\u03c0) \u00b7 RY(\u03c0/2) with a correction phase, using pulse-level implementations for each component.</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply gate to.</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef H(\n    wires: Union[int, List[int]], pulse_params: Optional[np.ndarray] = None\n) -&gt; None:\n    \"\"\"\n    Apply Hadamard gate using pulse decomposition.\n\n    Implements Hadamard as RZ(\u03c0) \u00b7 RY(\u03c0/2) with a correction phase,\n    using pulse-level implementations for each component.\n\n    Args:\n        wires (Union[int, List[int]]): Qubit index or indices to apply gate to.\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    pulse_params_RZ, pulse_params_RY = PulseInformation.H.split_params(pulse_params)\n\n    # qml.GlobalPhase(-np.pi / 2)  # this could act as substitute to Sc\n    PulseGates.RZ(np.pi, wires=wires, pulse_params=pulse_params_RZ)\n    PulseGates.RY(np.pi / 2, wires=wires, pulse_params=pulse_params_RY)\n\n    def Sc(p, t):\n        return -1.0\n\n    _H = np.pi / 2 * np.eye(2, dtype=np.complex64)\n    _H = qml.Hermitian(_H, wires=wires)\n    H_corr = Sc * _H\n\n    qml.evolve(H_corr)([0], 1)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.RX","title":"<code>RX(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply X-axis rotation using pulse-level implementation.</p> <p>Implements RX rotation using a shaped Gaussian pulse with optimized envelope parameters.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply rotation to.</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Array containing pulse parameters [A, sigma, t] for the Gaussian envelope. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RX(\n    w: float,\n    wires: Union[int, List[int]],\n    pulse_params: Optional[np.ndarray] = None,\n) -&gt; None:\n    \"\"\"\n    Apply X-axis rotation using pulse-level implementation.\n\n    Implements RX rotation using a shaped Gaussian pulse with optimized\n    envelope parameters.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n        pulse_params (Optional[np.ndarray]): Array containing pulse parameters\n            [A, sigma, t] for the Gaussian envelope. If None, uses optimized\n            parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    pulse_params = PulseInformation.RX.split_params(pulse_params)\n\n    def Sx(p, t):\n        return PulseGates._S(p, t, phi_c=np.pi) * w\n\n    _H = PulseGates.H_static.conj().T @ PulseGates.X @ PulseGates.H_static\n    _H = qml.Hermitian(_H, wires=wires)\n    H_eff = Sx * _H\n\n    qml.evolve(H_eff)([pulse_params[0:2]], pulse_params[2])\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.RY","title":"<code>RY(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply Y-axis rotation using pulse-level implementation.</p> <p>Implements RY rotation using a shaped Gaussian pulse with optimized envelope parameters.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply rotation to.</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Array containing pulse parameters [A, sigma, t] for the Gaussian envelope. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RY(\n    w: float,\n    wires: Union[int, List[int]],\n    pulse_params: Optional[np.ndarray] = None,\n) -&gt; None:\n    \"\"\"\n    Apply Y-axis rotation using pulse-level implementation.\n\n    Implements RY rotation using a shaped Gaussian pulse with optimized\n    envelope parameters.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n        pulse_params (Optional[np.ndarray]): Array containing pulse parameters\n            [A, sigma, t] for the Gaussian envelope. If None, uses optimized\n            parameters.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    pulse_params = PulseInformation.RY.split_params(pulse_params)\n\n    def Sy(p, t):\n        return PulseGates._S(p, t, phi_c=-np.pi / 2) * w\n\n    _H = PulseGates.H_static.conj().T @ PulseGates.Y @ PulseGates.H_static\n    _H = qml.Hermitian(_H, wires=wires)\n    H_eff = Sy * _H\n\n    qml.evolve(H_eff)([pulse_params[0:2]], pulse_params[2])\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.RZ","title":"<code>RZ(w, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply Z-axis rotation using pulse-level implementation.</p> <p>Implements RZ rotation using virtual Z rotations (phase tracking) without physical pulse application.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply rotation to.</p> required <code>pulse_params</code> <code>Optional[float]</code> <p>Duration parameter for the pulse. Rotation angle = w * 2 * pulse_params. Defaults to 0.5 if None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gate is applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RZ(\n    w: float, wires: Union[int, List[int]], pulse_params: Optional[float] = None\n) -&gt; None:\n    \"\"\"\n    Apply Z-axis rotation using pulse-level implementation.\n\n    Implements RZ rotation using virtual Z rotations (phase tracking)\n    without physical pulse application.\n\n    Args:\n        w (float): Rotation angle in radians.\n        wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n        pulse_params (Optional[float]): Duration parameter for the pulse.\n            Rotation angle = w * 2 * pulse_params. Defaults to 0.5 if None.\n\n    Returns:\n        None: Gate is applied in-place to the circuit.\n    \"\"\"\n    pulse_params = PulseInformation.RZ.split_params(pulse_params)\n\n    _H = qml.Hermitian(PulseGates.Z, wires=wires)\n\n    def Sz(p, t):\n        return p * w\n\n    H_eff = Sz * _H\n\n    qml.evolve(H_eff)([pulse_params], 1)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseGates.Rot","title":"<code>Rot(phi, theta, omega, wires, pulse_params=None)</code>  <code>staticmethod</code>","text":"<p>Apply general single-qubit rotation using pulse decomposition.</p> <p>Decomposes a general rotation into RZ(phi) \u00b7 RY(theta) \u00b7 RZ(omega) and applies each component using pulse-level implementations.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>First rotation angle.</p> required <code>theta</code> <code>float</code> <p>Second rotation angle.</p> required <code>omega</code> <code>float</code> <p>Third rotation angle.</p> required <code>wires</code> <code>Union[int, List[int]]</code> <p>Qubit index or indices to apply rotation to.</p> required <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameters for the composing gates. If None, uses optimized parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Gates are applied in-place to the circuit.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Rot(\n    phi: float,\n    theta: float,\n    omega: float,\n    wires: Union[int, List[int]],\n    pulse_params: Optional[np.ndarray] = None,\n) -&gt; None:\n    \"\"\"\n    Apply general single-qubit rotation using pulse decomposition.\n\n    Decomposes a general rotation into RZ(phi) \u00b7 RY(theta) \u00b7 RZ(omega)\n    and applies each component using pulse-level implementations.\n\n    Args:\n        phi (float): First rotation angle.\n        theta (float): Second rotation angle.\n        omega (float): Third rotation angle.\n        wires (Union[int, List[int]]): Qubit index or indices to apply rotation to.\n        pulse_params (Optional[np.ndarray]): Pulse parameters for the\n            composing gates. If None, uses optimized parameters.\n\n    Returns:\n        None: Gates are applied in-place to the circuit.\n    \"\"\"\n    params_RZ_1, params_RY, params_RZ_2 = PulseInformation.Rot.split_params(\n        pulse_params\n    )\n\n    PulseGates.RZ(phi, wires=wires, pulse_params=params_RZ_1)\n    PulseGates.RY(theta, wires=wires, pulse_params=params_RY)\n    PulseGates.RZ(omega, wires=wires, pulse_params=params_RZ_2)\n</code></pre>"},{"location":"references/#pulse_structure","title":"Pulse Structure","text":"<pre><code>from qml_essentials.ansaetze import PulseParams\n</code></pre> <p>Container for hierarchical pulse parameters.</p> <p>Manages pulse parameters for quantum gates, supporting both leaf nodes (gates with direct parameters) and composite nodes (gates decomposed into simpler gates). Enables hierarchical parameter access and manipulation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name identifier for the gate.</p> <code>_params</code> <code>ndarray</code> <p>Direct pulse parameters (leaf nodes only).</p> <code>_pulse_obj</code> <code>List</code> <p>Child PulseParams objects (composite nodes only).</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class PulseParams:\n    \"\"\"\n    Container for hierarchical pulse parameters.\n\n    Manages pulse parameters for quantum gates, supporting both leaf nodes\n    (gates with direct parameters) and composite nodes (gates decomposed\n    into simpler gates). Enables hierarchical parameter access and\n    manipulation.\n\n    Attributes:\n        name (str): Name identifier for the gate.\n        _params (np.ndarray): Direct pulse parameters (leaf nodes only).\n        _pulse_obj (List): Child PulseParams objects (composite nodes only).\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"\",\n        params: Optional[np.ndarray] = None,\n        pulse_obj: Optional[List] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize pulse parameters container.\n\n        Args:\n            name (str): Name identifier for the gate. Defaults to empty string.\n            params (Optional[np.ndarray]): Direct pulse parameters for leaf gates.\n                Mutually exclusive with pulse_obj.\n            pulse_obj (Optional[List]): List of child PulseParams for composite\n                gates. Mutually exclusive with params.\n\n        Raises:\n            AssertionError: If both or neither of params and pulse_obj are provided.\n        \"\"\"\n        assert (params is None and pulse_obj is not None) or (\n            params is not None and pulse_obj is None\n        ), \"Exactly one of `params` or `pulse_params` must be provided.\"\n\n        self._pulse_obj = pulse_obj\n\n        if params is not None:\n            self._params = params\n\n        self.name = name\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Get the total number of pulse parameters.\n\n        For composite gates, returns the accumulated count from all children.\n\n        Returns:\n            int: Total number of pulse parameters.\n        \"\"\"\n        return len(self.params)\n\n    def __getitem__(self, idx: int) -&gt; Union[float, np.ndarray]:\n        \"\"\"\n        Access pulse parameter(s) by index.\n\n        For leaf gates, returns the parameter at the given index.\n        For composite gates, returns parameters of the child at the given index.\n\n        Args:\n            idx (int): Index to access.\n\n        Returns:\n            Union[float, np.ndarray]: Parameter value or child parameters.\n        \"\"\"\n        if self.is_leaf:\n            return self.params[idx]\n        else:\n            return self.childs[idx].params\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation (gate name).\"\"\"\n        return self.name\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return repr string (gate name).\"\"\"\n        return self.name\n\n    @property\n    def is_leaf(self) -&gt; bool:\n        \"\"\"Check if this is a leaf node (direct parameters, no children).\"\"\"\n        return self._pulse_obj is None\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Get the total parameter count (alias for __len__).\"\"\"\n        return len(self)\n\n    @property\n    def leafs(self) -&gt; List[\"PulseParams\"]:\n        \"\"\"\n        Get all leaf nodes in the hierarchy.\n\n        Recursively collects all leaf PulseParams objects in the tree.\n\n        Returns:\n            List[PulseParams]: List of unique leaf nodes.\n        \"\"\"\n        if self.is_leaf:\n            return [self]\n\n        leafs = []\n        for obj in self._pulse_obj:\n            leafs.extend(obj.leafs)\n\n        return list(set(leafs))\n\n    @property\n    def childs(self) -&gt; List[\"PulseParams\"]:\n        \"\"\"\n        Get direct children of this node.\n\n        Returns:\n            List[PulseParams]: List of child PulseParams objects, or empty list\n                if this is a leaf node.\n        \"\"\"\n        if self.is_leaf:\n            return []\n\n        return self._pulse_obj\n\n    @property\n    def shape(self) -&gt; List[int]:\n        \"\"\"\n        Get the shape of pulse parameters.\n\n        For leaf nodes, returns list with parameter count.\n        For composite nodes, returns nested list of child shapes.\n\n        Returns:\n            List[int]: Parameter shape specification.\n        \"\"\"\n        if self.is_leaf:\n            return [len(self.params)]\n\n        shape = []\n        for obj in self.childs:\n            shape.append(*obj.shape())\n\n        return shape\n\n    @property\n    def params(self) -&gt; np.ndarray:\n        \"\"\"\n        Get or compute pulse parameters.\n\n        For leaf nodes, returns internal pulse parameters.\n        For composite nodes, returns concatenated parameters from all children.\n\n        Returns:\n            np.ndarray: Pulse parameters array.\n        \"\"\"\n        if self.is_leaf:\n            return self._params\n\n        params = self.split_params(params=None, leafs=False)\n\n        return np.concatenate(params)\n\n    @params.setter\n    def params(self, value: np.ndarray) -&gt; None:\n        \"\"\"\n        Set pulse parameters.\n\n        For leaf nodes, sets internal parameters directly.\n        For composite nodes, distributes values across children.\n\n        Args:\n            value (np.ndarray): Pulse parameters to set.\n\n        Raises:\n            AssertionError: If value is not np.ndarray for leaf nodes.\n        \"\"\"\n        if self.is_leaf:\n            assert isinstance(value, np.ndarray), \"params must be a np.ndarray\"\n            self._params = value\n            return\n\n        idx = 0\n        for obj in self.childs:\n            nidx = idx + obj.size\n            obj.params = value[idx:nidx]\n            idx = nidx\n\n    @property\n    def leaf_params(self) -&gt; np.ndarray:\n        \"\"\"\n        Get parameters from all leaf nodes.\n\n        Returns:\n            np.ndarray: Concatenated parameters from all leaf nodes.\n        \"\"\"\n        if self.is_leaf:\n            return self._params\n\n        params = self.split_params(None, leafs=True)\n\n        return np.concatenate(params)\n\n    @leaf_params.setter\n    def leaf_params(self, value: np.ndarray) -&gt; None:\n        \"\"\"\n        Set parameters for all leaf nodes.\n\n        Args:\n            value (np.ndarray): Parameters to distribute across leaf nodes.\n        \"\"\"\n        if self.is_leaf:\n            self._params = value\n            return\n\n        idx = 0\n        for obj in self.leafs:\n            nidx = idx + obj.size\n            obj.params = value[idx:nidx]\n            idx = nidx\n\n    def split_params(\n        self,\n        params: Optional[np.ndarray] = None,\n        leafs: bool = False,\n    ) -&gt; List[np.ndarray]:\n        \"\"\"\n        Split parameters into sub-arrays for children or leaves.\n\n        Args:\n            params (Optional[np.ndarray]): Parameters to split. If None,\n                uses internal parameters.\n            leafs (bool): If True, splits across leaf nodes; if False,\n                splits across direct children. Defaults to False.\n\n        Returns:\n            List[np.ndarray]: List of parameter arrays for children or leaves.\n        \"\"\"\n        if params is None:\n            if self.is_leaf:\n                return self._params\n\n            objs = self.leafs if leafs else self.childs\n            s_params = []\n            for obj in objs:\n                s_params.append(obj.params)\n\n            return s_params\n        else:\n            if self.is_leaf:\n                return params\n\n            objs = self.leafs if leafs else self.childs\n            s_params = []\n            idx = 0\n            for obj in objs:\n                nidx = idx + obj.size\n                s_params.append(params[idx:nidx])\n                idx = nidx\n\n            return s_params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.childs","title":"<code>childs</code>  <code>property</code>","text":"<p>Get direct children of this node.</p> <p>Returns:</p> Type Description <code>List[PulseParams]</code> <p>List[PulseParams]: List of child PulseParams objects, or empty list if this is a leaf node.</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.is_leaf","title":"<code>is_leaf</code>  <code>property</code>","text":"<p>Check if this is a leaf node (direct parameters, no children).</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.leaf_params","title":"<code>leaf_params</code>  <code>property</code> <code>writable</code>","text":"<p>Get parameters from all leaf nodes.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Concatenated parameters from all leaf nodes.</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.leafs","title":"<code>leafs</code>  <code>property</code>","text":"<p>Get all leaf nodes in the hierarchy.</p> <p>Recursively collects all leaf PulseParams objects in the tree.</p> <p>Returns:</p> Type Description <code>List[PulseParams]</code> <p>List[PulseParams]: List of unique leaf nodes.</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.params","title":"<code>params</code>  <code>property</code> <code>writable</code>","text":"<p>Get or compute pulse parameters.</p> <p>For leaf nodes, returns internal pulse parameters. For composite nodes, returns concatenated parameters from all children.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pulse parameters array.</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of pulse parameters.</p> <p>For leaf nodes, returns list with parameter count. For composite nodes, returns nested list of child shapes.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: Parameter shape specification.</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.size","title":"<code>size</code>  <code>property</code>","text":"<p>Get the total parameter count (alias for len).</p>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Access pulse parameter(s) by index.</p> <p>For leaf gates, returns the parameter at the given index. For composite gates, returns parameters of the child at the given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index to access.</p> required <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Union[float, np.ndarray]: Parameter value or child parameters.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; Union[float, np.ndarray]:\n    \"\"\"\n    Access pulse parameter(s) by index.\n\n    For leaf gates, returns the parameter at the given index.\n    For composite gates, returns parameters of the child at the given index.\n\n    Args:\n        idx (int): Index to access.\n\n    Returns:\n        Union[float, np.ndarray]: Parameter value or child parameters.\n    \"\"\"\n    if self.is_leaf:\n        return self.params[idx]\n    else:\n        return self.childs[idx].params\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.__init__","title":"<code>__init__(name='', params=None, pulse_obj=None)</code>","text":"<p>Initialize pulse parameters container.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the gate. Defaults to empty string.</p> <code>''</code> <code>params</code> <code>Optional[ndarray]</code> <p>Direct pulse parameters for leaf gates. Mutually exclusive with pulse_obj.</p> <code>None</code> <code>pulse_obj</code> <code>Optional[List]</code> <p>List of child PulseParams for composite gates. Mutually exclusive with params.</p> <code>None</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If both or neither of params and pulse_obj are provided.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"\",\n    params: Optional[np.ndarray] = None,\n    pulse_obj: Optional[List] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize pulse parameters container.\n\n    Args:\n        name (str): Name identifier for the gate. Defaults to empty string.\n        params (Optional[np.ndarray]): Direct pulse parameters for leaf gates.\n            Mutually exclusive with pulse_obj.\n        pulse_obj (Optional[List]): List of child PulseParams for composite\n            gates. Mutually exclusive with params.\n\n    Raises:\n        AssertionError: If both or neither of params and pulse_obj are provided.\n    \"\"\"\n    assert (params is None and pulse_obj is not None) or (\n        params is not None and pulse_obj is None\n    ), \"Exactly one of `params` or `pulse_params` must be provided.\"\n\n    self._pulse_obj = pulse_obj\n\n    if params is not None:\n        self._params = params\n\n    self.name = name\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.__len__","title":"<code>__len__()</code>","text":"<p>Get the total number of pulse parameters.</p> <p>For composite gates, returns the accumulated count from all children.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of pulse parameters.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the total number of pulse parameters.\n\n    For composite gates, returns the accumulated count from all children.\n\n    Returns:\n        int: Total number of pulse parameters.\n    \"\"\"\n    return len(self.params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.__repr__","title":"<code>__repr__()</code>","text":"<p>Return repr string (gate name).</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return repr string (gate name).\"\"\"\n    return self.name\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation (gate name).</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation (gate name).\"\"\"\n    return self.name\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.PulseParams.split_params","title":"<code>split_params(params=None, leafs=False)</code>","text":"<p>Split parameters into sub-arrays for children or leaves.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Optional[ndarray]</code> <p>Parameters to split. If None, uses internal parameters.</p> <code>None</code> <code>leafs</code> <code>bool</code> <p>If True, splits across leaf nodes; if False, splits across direct children. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of parameter arrays for children or leaves.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>def split_params(\n    self,\n    params: Optional[np.ndarray] = None,\n    leafs: bool = False,\n) -&gt; List[np.ndarray]:\n    \"\"\"\n    Split parameters into sub-arrays for children or leaves.\n\n    Args:\n        params (Optional[np.ndarray]): Parameters to split. If None,\n            uses internal parameters.\n        leafs (bool): If True, splits across leaf nodes; if False,\n            splits across direct children. Defaults to False.\n\n    Returns:\n        List[np.ndarray]: List of parameter arrays for children or leaves.\n    \"\"\"\n    if params is None:\n        if self.is_leaf:\n            return self._params\n\n        objs = self.leafs if leafs else self.childs\n        s_params = []\n        for obj in objs:\n            s_params.append(obj.params)\n\n        return s_params\n    else:\n        if self.is_leaf:\n            return params\n\n        objs = self.leafs if leafs else self.childs\n        s_params = []\n        idx = 0\n        for obj in objs:\n            nidx = idx + obj.size\n            s_params.append(params[idx:nidx])\n            idx = nidx\n\n        return s_params\n</code></pre>"},{"location":"references/#model","title":"Model","text":"<pre><code>from qml_essentials.model import Model\n</code></pre> <p>A quantum circuit model.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>class Model:\n    \"\"\"\n    A quantum circuit model.\n    \"\"\"\n\n    lightning_threshold = 12\n    cpu_scaler = 0.9  # default cpu scaler, =1 means full CPU for MP\n\n    def __init__(\n        self,\n        n_qubits: int,\n        n_layers: int,\n        circuit_type: Union[str, Circuit] = \"No_Ansatz\",\n        data_reupload: Union[bool, List[List[bool]], List[List[List[bool]]]] = True,\n        state_preparation: Union[\n            str, Callable, List[Union[str, Callable]], None\n        ] = None,\n        encoding: Union[Encoding, str, Callable, List[Union[str, Callable]]] = Gates.RX,\n        trainable_frequencies: bool = False,\n        initialization: str = \"random\",\n        initialization_domain: List[float] = [0, 2 * jnp.pi],\n        output_qubit: Union[List[int], int] = -1,\n        shots: Optional[int] = None,\n        random_seed: int = 1000,\n        remove_zero_encoding: bool = True,\n        use_multithreading: bool = False,\n        repeat_batch_axis: List[bool] = [True, True, True],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the quantum circuit model.\n        Parameters will have the shape [impl_n_layers, parameters_per_layer]\n        where impl_n_layers is the number of layers provided and added by one\n        depending if data_reupload is True and parameters_per_layer is given by\n        the chosen ansatz.\n\n        The model is initialized with the following parameters as defaults:\n        - noise_params: None\n        - execution_type: \"expval\"\n        - shots: None\n\n        Args:\n            n_qubits (int): The number of qubits in the circuit.\n            n_layers (int): The number of layers in the circuit.\n            circuit_type (str, Circuit): The type of quantum circuit to use.\n                If None, defaults to \"no_ansatz\".\n            data_reupload (Union[bool, List[bool], List[List[bool]]], optional):\n                Whether to reupload data to the quantum device on each\n                layer and qubit. Detailed re-uploading instructions can be given\n                as a list/array of 0/False and 1/True with shape (n_qubits,\n                n_layers) to specify where to upload the data. Defaults to True\n                for applying data re-uploading to the full circuit.\n            encoding (Union[str, Callable, List[str], List[Callable]], optional):\n                The unitary to use for encoding the input data. Can be a string\n                (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n                If input is multidimensional it is assumed to be a list of\n                unitaries or a list of strings.\n            trainable_frequencies (bool, optional):\n                Sets trainable encoding parameters for trainable frequencies.\n                Defaults to False.\n            initialization (str, optional): The strategy to initialize the parameters.\n                Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n                Defaults to \"random\".\n            output_qubit (List[int], int, optional): The index of the output\n                qubit (or qubits). When set to -1 all qubits are measured, or a\n                global measurement is conducted, depending on the execution\n                type.\n            shots (Optional[int], optional): The number of shots to use for\n                the quantum device. Defaults to None.\n            random_seed (int, optional): seed for the random number generator\n                in initialization is \"random\" and for random noise parameters.\n                Defaults to 1000.\n            remove_zero_encoding (bool, optional): whether to\n                remove the zero encoding from the circuit. Defaults to True.\n            use_multithreading (bool, optional): whether to use JAX\n                multithreading to parallelise over batch dimension.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialize default parameters needed for circuit evaluation\n        self.n_qubits: int = n_qubits\n        self.output_qubit: Union[List[int], int] = output_qubit\n        self.n_layers: int = n_layers\n        self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n        self.shots = shots\n        self.remove_zero_encoding = remove_zero_encoding\n        self.use_multithreading = use_multithreading\n        self.trainable_frequencies: bool = trainable_frequencies\n        self.execution_type: str = \"expval\"\n        self.repeat_batch_axis: List[bool] = repeat_batch_axis\n\n        # --- State Preparation ---\n        try:\n            self._sp = Gates.parse_gates(state_preparation, Gates)\n        except ValueError as e:\n            raise ValueError(f\"Error parsing encodings: {e}\")\n\n        # prepare corresponding pulse parameters (always optimized pulses)\n        self.sp_pulse_params = []\n        for sp in self._sp:\n            sp_name = sp.__name__ if hasattr(sp, \"__name__\") else str(sp)\n\n            if pinfo.gate_by_name(sp_name) is not None:\n                params = jnp.array(pinfo.gate_by_name(sp_name))\n                self.sp_pulse_params.append(params)\n            else:\n                # gate has no pulse parametrization\n                self.sp_pulse_params.append(None)\n\n        # --- Encoding ---\n        if isinstance(encoding, Encoding):\n            # user wants custom strategy? do it!\n            self._enc = encoding\n        else:\n            # use hammming encoding by default\n            self._enc = Encoding(\"hamming\", encoding)\n\n        # Number of possible inputs\n        self.n_input_feat = len(self._enc)\n        log.debug(f\"Number of input features: {self.n_input_feat}\")\n\n        # Trainable frequencies, default initialization as in arXiv:2309.03279v2\n        self.enc_params = jnp.ones((self.n_qubits, self.n_input_feat))\n\n        self._zero_inputs = False\n\n        # --- Data-Reuploading ---\n        # Process data reuploading strategy and set degree\n        if not isinstance(data_reupload, bool):\n            if not isinstance(data_reupload, np.ndarray):\n                data_reupload = np.array(data_reupload)\n\n            if len(data_reupload.shape) == 2:\n                assert data_reupload.shape == (\n                    n_layers,\n                    n_qubits,\n                ), f\"Data reuploading array has wrong shape. \\\n                    Expected {(n_layers, n_qubits)} or\\\n                    {(n_layers, n_qubits, self.n_input_feat)},\\\n                    got {data_reupload.shape}.\"\n                data_reupload = data_reupload.reshape(*data_reupload.shape, 1)\n                data_reupload = np.repeat(data_reupload, self.n_input_feat, axis=2)\n\n            assert data_reupload.shape == (\n                n_layers,\n                n_qubits,\n                self.n_input_feat,\n            ), f\"Data reuploading array has wrong shape. \\\n                Expected {(n_layers, n_qubits, self.n_input_feat)},\\\n                got {data_reupload.shape}.\"\n\n            log.debug(f\"Data reuploading array:\\n{data_reupload}\")\n        else:\n            if data_reupload:\n                impl_n_layers: int = (\n                    n_layers + 1\n                )  # we need L+1 according to Schuld et al.\n                data_reupload = np.ones((n_layers, n_qubits, self.n_input_feat))\n                log.debug(\"Full data reuploading.\")\n            else:\n                impl_n_layers: int = n_layers\n                data_reupload = np.zeros((n_layers, n_qubits, self.n_input_feat))\n                data_reupload[0][0] = 1\n                log.debug(\"No data reuploading.\")\n\n        # convert to boolean values\n        data_reupload = data_reupload.astype(bool)\n        self.data_reupload = jnp.array(data_reupload)\n\n        self.degree: Tuple = tuple(\n            self._enc.get_n_freqs(jnp.count_nonzero(self.data_reupload[..., i]))\n            for i in range(self.n_input_feat)\n        )\n\n        self.frequencies: Tuple = tuple(\n            self._enc.get_spectrum(jnp.count_nonzero(self.data_reupload[..., i]))\n            for i in range(self.n_input_feat)\n        )\n\n        self.has_dru = jnp.max(jnp.array([jnp.max(f) for f in self.frequencies])) &gt; 1\n\n        # check for the highest degree among all input dimensions\n        if self.has_dru:\n            impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n        else:\n            impl_n_layers = n_layers\n        log.info(f\"Number of implicit layers: {impl_n_layers}.\")\n\n        # --- Ansatz ---\n        # only weak check for str. We trust the user to provide sth useful\n        if isinstance(circuit_type, str):\n            self.pqc: Callable[[Optional[jnp.ndarray], int], int] = getattr(\n                Ansaetze, circuit_type or \"No_Ansatz\"\n            )()\n        else:\n            self.pqc = circuit_type()\n        log.info(f\"Using Ansatz {circuit_type}.\")\n\n        # calculate the shape of the parameter vector here, we will re-use this in init.\n        params_per_layer = self.pqc.n_params_per_layer(self.n_qubits)\n        self._params_shape: Tuple[int, int] = (impl_n_layers, params_per_layer)\n        log.info(f\"Parameters per layer: {params_per_layer}\")\n\n        pulse_params_per_layer = self.pqc.n_pulse_params_per_layer(self.n_qubits)\n        self._pulse_params_shape: Tuple[int, int] = (\n            impl_n_layers,\n            pulse_params_per_layer,\n        )\n\n        # intialize to None as we can't know this yet\n        self._batch_shape = None\n\n        # this will also be re-used in the init method,\n        # however, only if nothing is provided\n        self._inialization_strategy = initialization\n        self._initialization_domain = initialization_domain\n\n        # ..here! where we only require a JAX random key\n        self.random_key = self.initialize_params(random.key(random_seed))\n\n        # Initializing pulse params\n        self.pulse_params: jnp.ndarray = jnp.ones((*self._pulse_params_shape, 1))\n\n        log.info(f\"Initialized pulse parameters with shape {self.pulse_params.shape}.\")\n\n        # Initialize two circuits, one with the default device and\n        # one with the mixed device\n        # which allows us to later route depending on the state_vector flag\n        if self.n_qubits &lt; self.lightning_threshold:\n            device = \"default.qubit\"\n        else:\n            device = \"lightning.qubit\"\n            self.use_multithreading = False\n        self.circuit: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\n                device,\n                shots=self.shots,\n                wires=self.n_qubits,\n            ),\n            interface=\"jax-jit\",\n            diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n        )\n\n        self.circuit_mixed: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n            interface=\"jax-jit\",\n            diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n        )\n\n    @property\n    def noise_params(self) -&gt; Optional[Dict[str, Union[float, Dict[str, float]]]]:\n        \"\"\"\n        Gets the noise parameters of the model.\n\n        Returns:\n            Optional[Dict[str, float]]: A dictionary of\n            noise parameters or None if not set.\n        \"\"\"\n        return self._noise_params\n\n    @noise_params.setter\n    def noise_params(\n        self, kvs: Optional[Dict[str, Union[float, Dict[str, float]]]]\n    ) -&gt; None:\n        \"\"\"\n        Sets the noise parameters of the model.\n\n        Typically a \"noise parameter\" refers to the error probability.\n        ThermalRelaxation is a special case, and supports a dict as value with\n        structure:\n            \"ThermalRelaxation\":\n            {\n                \"t1\": 2000, # relative t1 time.\n                \"t2\": 1000, # relative t2 time\n                \"t_factor\" 1: # relative gate time factor\n            },\n\n        Args:\n            kvs (Optional[Dict[str, Union[float, Dict[str, float]]]]): A\n            dictionary of noise parameters. If all values are 0.0, the noise\n            parameters are set to None.\n\n        Returns:\n            None\n        \"\"\"\n        # set to None if only zero values provided\n        if kvs is not None and all(v == 0.0 for v in kvs.values()):\n            kvs = None\n\n        # set default values\n        if kvs is not None:\n            defaults = {\n                \"BitFlip\": 0.0,\n                \"PhaseFlip\": 0.0,\n                \"Depolarizing\": 0.0,\n                \"MultiQubitDepolarizing\": 0.0,\n                \"AmplitudeDamping\": 0.0,\n                \"PhaseDamping\": 0.0,\n                \"GateError\": 0.0,\n                \"ThermalRelaxation\": None,\n                \"StatePreparation\": 0.0,\n                \"Measurement\": 0.0,\n            }\n            for key, default_val in defaults.items():\n                kvs.setdefault(key, default_val)\n\n            # check if there are any keys not supported\n            for key in kvs.keys():\n                if key not in defaults:\n                    warnings.warn(\n                        f\"Noise type {key} is not supported by this package\",\n                        UserWarning,\n                    )\n\n            # check valid params for thermal relaxation noise channel\n            tr_params = kvs[\"ThermalRelaxation\"]\n            if isinstance(tr_params, dict):\n                tr_params.setdefault(\"t1\", 0.0)\n                tr_params.setdefault(\"t2\", 0.0)\n                tr_params.setdefault(\"t_factor\", 0.0)\n                valid_tr_keys = {\"t1\", \"t2\", \"t_factor\"}\n                for k in tr_params.keys():\n                    if k not in valid_tr_keys:\n                        warnings.warn(\n                            f\"Thermal Relaxation parameter {k} is not supported \"\n                            f\"by this package\",\n                            UserWarning,\n                        )\n                if not all(tr_params.values()) or tr_params[\"t2\"] &gt; 2 * tr_params[\"t1\"]:\n                    warnings.warn(\n                        \"Received invalid values for Thermal Relaxation noise \"\n                        \"parameter. Thermal relaxation is not applied!\",\n                        UserWarning,\n                    )\n                    kvs[\"ThermalRelaxation\"] = 0.0\n\n        self._noise_params = kvs\n\n    @property\n    def output_qubit(self) -&gt; List[int]:\n        \"\"\"Get the output qubit indices for measurement.\"\"\"\n        return self._output_qubit\n\n    @output_qubit.setter\n    def output_qubit(self, value: Union[int, List[int]]) -&gt; None:\n        \"\"\"\n        Set the output qubit(s) for measurement.\n\n        Args:\n            value: Qubit index or list of indices. Use -1 for all qubits.\n        \"\"\"\n        if isinstance(value, list):\n            assert (\n                len(value) &lt;= self.n_qubits\n            ), f\"Size of output_qubit {len(value)} cannot be\\\n            larger than number of qubits {self.n_qubits}.\"\n        elif isinstance(value, int):\n            if value == -1:\n                value = list(range(self.n_qubits))\n            else:\n                assert (\n                    value &lt; self.n_qubits\n                ), f\"Output qubit {value} cannot be larger than {self.n_qubits}.\"\n                value = [value]\n\n        self._output_qubit = value\n\n    @property\n    def execution_type(self) -&gt; str:\n        \"\"\"\n        Gets the execution type of the model.\n\n        Returns:\n            str: The execution type, one of 'density', 'expval', or 'probs'.\n        \"\"\"\n        return self._execution_type\n\n    @execution_type.setter\n    def execution_type(self, value: str) -&gt; None:\n        if value == \"density\":\n            self._result_shape = (\n                2 ** len(self.output_qubit),\n                2 ** len(self.output_qubit),\n            )\n        elif value == \"expval\":\n            # check if all qubits are used\n            if len(self.output_qubit) == self.n_qubits:\n                self._result_shape = (len(self.output_qubit),)\n            # if not -&gt; parity measurement with only 1D output per pair\n            # or n_local measurement\n            else:\n                self._result_shape = (len(self.output_qubit),)\n        elif value == \"probs\":\n            # in case this is a list of parities,\n            # each pair has 2^len(qubits) probabilities\n            n_parity = (\n                2 ** len(self.output_qubit[0])\n                if isinstance(self.output_qubit[0], Tuple)\n                else 2\n            )\n            self._result_shape = (len(self.output_qubit), n_parity)\n        elif value == \"state\":\n            self._result_shape = (2 ** len(self.output_qubit),)\n        else:\n            raise ValueError(f\"Invalid execution type: {value}.\")\n\n        if value == \"state\" and not self.all_qubit_measurement:\n            warnings.warn(\n                f\"{value} measurement does ignore output_qubit, which is \"\n                f\"{self.output_qubit}.\",\n                UserWarning,\n            )\n\n        if value == \"probs\" and self.shots is None:\n            warnings.warn(\n                \"Setting execution_type to probs without specifying shots.\",\n                UserWarning,\n            )\n\n        if value == \"density\" and self.shots is not None:\n            warnings.warn(\n                \"Setting execution_type to density with specified shots.\",\n                UserWarning,\n            )\n\n        self._execution_type = value\n\n    @property\n    def shots(self) -&gt; Optional[int]:\n        \"\"\"\n        Gets the number of shots to use for the quantum device.\n\n        Returns:\n            Optional[int]: The number of shots.\n        \"\"\"\n        return self._shots\n\n    @shots.setter\n    def shots(self, value: Optional[int]) -&gt; None:\n        \"\"\"\n        Sets the number of shots to use for the quantum device.\n\n        Args:\n            value (Optional[int]): The number of shots.\n            If an integer less than or equal to 0 is provided, it is set to None.\n\n        Returns:\n            None\n        \"\"\"\n        if type(value) is int and value &lt;= 0:\n            value = None\n        self._shots = value\n\n    @property\n    def params(self) -&gt; jnp.ndarray:\n        \"\"\"Get the variational parameters of the model.\"\"\"\n        return self._params\n\n    @params.setter\n    def params(self, value: jnp.ndarray) -&gt; None:\n        \"\"\"Set the variational parameters, ensuring batch dimension exists.\"\"\"\n        if len(value.shape) == 2:\n            value = value.reshape(*value.shape, 1)\n\n        self._params = value\n\n    @property\n    def enc_params(self) -&gt; jnp.ndarray:\n        \"\"\"Get the encoding parameters used for input transformation.\"\"\"\n        return self._enc_params\n\n    @enc_params.setter\n    def enc_params(self, value: jnp.ndarray) -&gt; None:\n        \"\"\"Set the encoding parameters.\"\"\"\n        self._enc_params = value\n\n    @property\n    def pulse_params(self) -&gt; jnp.ndarray:\n        \"\"\"Get the pulse parameters for pulse-mode gate execution.\"\"\"\n        return self._pulse_params\n\n    @pulse_params.setter\n    def pulse_params(self, value: jnp.ndarray) -&gt; None:\n        \"\"\"Set the pulse parameters.\"\"\"\n        self._pulse_params = value\n\n    @property\n    def all_qubit_measurement(self) -&gt; bool:\n        \"\"\"Check if measurement is performed on all qubits.\"\"\"\n        return self.output_qubit == list(range(self.n_qubits))\n\n    @property\n    def batch_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Get the batch shape (B_I, B_P, B_R).\n\n        Returns:\n            Tuple[int, ...]: Tuple of (input_batch, param_batch, pulse_batch).\n                Returns (1, 1, 1) if model has not been called yet.\n        \"\"\"\n        if self._batch_shape is None:\n            log.warning(\"Model was not called yet. Returning (1,1,1) as batch shape.\")\n            return (1, 1, 1)\n        return self._batch_shape\n\n    @property\n    def eff_batch_shape(self) -&gt; Tuple[int, ...]:\n        \"\"\"\n        Get the effective batch shape after applying repeat_batch_axis mask.\n\n        Returns:\n            Tuple[int, ...]: Effective batch dimensions, excluding zeros.\n        \"\"\"\n        batch_shape = np.array(self.batch_shape) * self.repeat_batch_axis\n        batch_shape = batch_shape[batch_shape != 0]\n        return batch_shape\n\n    def initialize_params(\n        self,\n        random_key: Optional[random.PRNGKey] = None,\n        repeat: int = 1,\n        initialization: Optional[str] = None,\n        initialization_domain: Optional[List[float]] = None,\n    ) -&gt; random.PRNGKey:\n        \"\"\"\n        Initialize the variational parameters of the model.\n\n        Args:\n            random_key (Optional[random.PRNGKey]): JAX random key for initialization.\n                If None, uses the model's internal random key.\n            repeat (int): Number of parameter sets to create (batch dimension).\n                Defaults to 1.\n            initialization (Optional[str]): Strategy for parameter initialization.\n                Options: \"random\", \"zeros\", \"pi\", \"zero-controlled\", \"pi-controlled\".\n                If None, uses the strategy specified in the constructor.\n            initialization_domain (Optional[List[float]]): Domain [min, max] for\n                random initialization. If None, uses the domain from constructor.\n\n        Returns:\n            random.PRNGKey: Updated random key after initialization.\n\n        Raises:\n            Exception: If an invalid initialization method is specified.\n        \"\"\"\n        # Initializing params\n        params_shape = (*self._params_shape, repeat)\n\n        # use existing strategy if not specified\n        initialization = initialization or self._inialization_strategy\n        initialization_domain = initialization_domain or self._initialization_domain\n\n        random_key, sub_key = safe_random_split(\n            random_key if random_key is not None else self.random_key\n        )\n\n        def set_control_params(params: jnp.ndarray, value: float) -&gt; jnp.ndarray:\n            indices = self.pqc.get_control_indices(self.n_qubits)\n            if indices is None:\n                warnings.warn(\n                    f\"Specified {initialization} but circuit\\\n                    does not contain controlled rotation gates.\\\n                    Parameters are intialized randomly.\",\n                    UserWarning,\n                )\n            else:\n                np_params = np.array(params)\n                np_params[:, indices[0] : indices[1] : indices[2]] = (\n                    np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                    * value\n                )\n                params = jnp.array(np_params)\n            return params\n\n        if initialization == \"random\":\n            self.params: jnp.ndarray = random.uniform(\n                sub_key,\n                params_shape,\n                minval=initialization_domain[0],\n                maxval=initialization_domain[1],\n            )\n        elif initialization == \"zeros\":\n            self.params: jnp.ndarray = jnp.zeros(params_shape)\n        elif initialization == \"pi\":\n            self.params: jnp.ndarray = jnp.ones(params_shape) * jnp.pi\n        elif initialization == \"zero-controlled\":\n            self.params: jnp.ndarray = random.uniform(\n                sub_key,\n                params_shape,\n                minval=initialization_domain[0],\n                maxval=initialization_domain[1],\n            )\n            self.params = set_control_params(self.params, 0)\n        elif initialization == \"pi-controlled\":\n            self.params: jnp.ndarray = random.uniform(\n                sub_key,\n                params_shape,\n                minval=initialization_domain[0],\n                maxval=initialization_domain[1],\n            )\n            self.params = set_control_params(self.params, jnp.pi)\n        else:\n            raise Exception(\"Invalid initialization method\")\n\n        log.info(\n            f\"Initialized parameters with shape {self.params.shape}\\\n            using strategy {initialization}.\"\n        )\n\n        return random_key\n\n    def transform_input(\n        self, inputs: jnp.ndarray, enc_params: jnp.ndarray\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Transform input data by scaling with encoding parameters.\n\n        Implements the input transformation as described in arXiv:2309.03279v2,\n        where inputs are linearly scaled by encoding parameters before being\n        used in the quantum circuit.\n\n        Args:\n            inputs (jnp.ndarray): Input data point of shape (n_input_feat,) or\n                (batch_size, n_input_feat).\n            enc_params (jnp.ndarray): Encoding weight scalar or vector used to\n                scale the input.\n\n        Returns:\n            jnp.ndarray: Transformed input, element-wise product of inputs\n                and enc_params.\n        \"\"\"\n        return inputs * enc_params\n\n    def _iec(\n        self,\n        inputs: jnp.ndarray,\n        data_reupload: jnp.ndarray,\n        enc: Encoding,\n        enc_params: jnp.ndarray,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        random_key: Optional[random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Apply Input Encoding Circuit (IEC) with angle encoding.\n\n        Encodes classical input data into the quantum circuit using rotation\n        gates (e.g., RX, RY, RZ). Supports data re-uploading at specified\n        positions in the circuit.\n\n        Args:\n            inputs (jnp.ndarray): Input data of shape (n_input_feat,) or\n                (batch_size, n_input_feat).\n            data_reupload (jnp.ndarray): Boolean array of shape (n_qubits, n_input_feat)\n                indicating where to apply encoding gates.\n            enc (Encoding): Encoding strategy containing the encoding gate functions.\n            enc_params (jnp.ndarray): Encoding parameters of shape\n                (n_qubits, n_input_feat) used to scale inputs.\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise parameters for gate-level noise simulation. Defaults to None.\n            random_key (Optional[random.PRNGKey]): JAX random key for stochastic\n                noise. Defaults to None.\n\n        Returns:\n            None: Gates are applied in-place to the quantum circuit.\n        \"\"\"\n        # check for zero, because due to input validation, input cannot be none\n        if self.remove_zero_encoding and self._zero_inputs and self.batch_shape[0] == 1:\n            return\n\n        for q in range(self.n_qubits):\n            # use the last dimension of the inputs (feature dimension)\n            for idx in range(inputs.shape[-1]):\n                if data_reupload[q, idx]:\n                    # use elipsis to indiex only the last dimension\n                    # as inputs are generally *not* qubit dependent\n                    random_key, sub_key = safe_random_split(random_key)\n                    enc[idx](\n                        self.transform_input(inputs[..., idx], enc_params[q, idx]),\n                        wires=q,\n                        noise_params=noise_params,\n                        random_key=sub_key,\n                    )\n\n    def _circuit(\n        self,\n        params: jnp.ndarray,\n        inputs: jnp.ndarray,\n        pulse_params: Optional[jnp.ndarray] = None,\n        enc_params: Optional[jnp.ndarray] = None,\n        gate_mode: str = \"unitary\",\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        random_key: Optional[random.PRNGKey] = None,\n    ) -&gt; Union[float, jnp.ndarray]:\n        \"\"\"\n        Build and execute the quantum circuit.\n\n        Constructs the full quantum circuit including variational layers and\n        encoding, then returns the measurement result based on the configured\n        execution type.\n\n        Args:\n            params (jnp.ndarray): Variational parameters of shape\n                (n_layers, n_params_per_layer).\n            inputs (jnp.ndarray): Input data of shape (n_input_feat,).\n            pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers of shape\n                (n_layers, n_pulse_params_per_layer) for pulse-mode execution.\n                Defaults to None.\n            enc_params (Optional[jnp.ndarray]): Encoding parameters of shape\n                (n_qubits, n_input_feat). Defaults to None (uses model's enc_params).\n            gate_mode (str): Gate execution mode, either \"unitary\" or \"pulse\".\n                Defaults to \"unitary\".\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise parameters for simulation. Defaults to None.\n            random_key (Optional[random.PRNGKey]): JAX random key for stochastic\n                operations. Defaults to None.\n\n        Returns:\n            Union[float, jnp.ndarray]: Circuit output depending on execution_type:\n                - \"expval\": Expectation value(s) of the observable(s)\n                - \"density\": Density matrix of output qubits\n                - \"probs\": Measurement probabilities\n                - \"state\": Full quantum state vector\n        \"\"\"\n        self._variational(\n            params=params,\n            inputs=inputs,\n            pulse_params=pulse_params,\n            enc_params=enc_params,\n            gate_mode=gate_mode,\n            noise_params=noise_params,\n            random_key=random_key,\n        )\n        return self._observable()\n\n    def _variational(\n        self,\n        params: jnp.ndarray,\n        inputs: jnp.ndarray,\n        pulse_params: Optional[jnp.ndarray] = None,\n        enc_params: Optional[jnp.ndarray] = None,\n        gate_mode: str = \"unitary\",\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        random_key: Optional[random.PRNGKey] = None,\n    ) -&gt; None:\n        \"\"\"\n        Build the variational quantum circuit structure.\n\n        Constructs the circuit by applying state preparation, alternating\n        variational ansatz layers with input encoding layers, and optional\n        noise channels.\n\n        Args:\n            params (jnp.ndarray): Variational parameters of shape\n                (n_layers, n_params_per_layer).\n            inputs (jnp.ndarray): Input data of shape (n_input_feat,).\n            pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers of shape\n                (n_layers, n_pulse_params_per_layer) for pulse-mode execution.\n                Defaults to None (uses model's pulse_params).\n            enc_params (Optional[jnp.ndarray]): Encoding parameters of shape\n                (n_qubits, n_input_feat). Defaults to None (uses model's enc_params).\n            gate_mode (str): Gate execution mode, either \"unitary\" or \"pulse\".\n                Defaults to \"unitary\".\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise parameters for simulation. Defaults to None.\n            random_key (Optional[random.PRNGKey]): JAX random key for stochastic\n                operations. Defaults to None.\n\n        Returns:\n            None: Gates are applied in-place to the quantum circuit.\n\n        Note:\n            Issues RuntimeWarning if called directly without providing parameters\n            that would normally be passed through the forward method.\n        \"\"\"\n        # TODO: rework and double check params shape\n        if len(params.shape) &gt; 2 and params.shape[2] == 1:\n            params = params[:, :, 0]\n\n        if len(inputs.shape) &gt; 1 and inputs.shape[0] == 1:\n            inputs = inputs[0]\n\n        if enc_params is None:\n            # TODO: Raise warning if trainable frequencies is True, or similar. I.e., no\n            #   warning if user does not care for frequencies or enc_params\n            if self.trainable_frequencies:\n                warnings.warn(\n                    \"Explicit call to `_circuit` or `_variational` detected: \"\n                    \"`enc_params` is None, using `self.enc_params` instead.\",\n                    RuntimeWarning,\n                )\n            enc_params = self.enc_params\n\n        if pulse_params is None:\n            if gate_mode == \"pulse\":\n                warnings.warn(\n                    \"Explicit call to `_circuit` or `_variational` detected: \"\n                    \"`pulse_params` is None, using `self.pulse_params` instead.\",\n                    RuntimeWarning,\n                )\n            pulse_params = self.pulse_params\n\n        if noise_params is None:\n            if self.noise_params is not None:\n                warnings.warn(\n                    \"Explicit call to `_circuit` or `_variational` detected: \"\n                    \"`noise_params` is None, using `self.noise_params` instead.\",\n                    RuntimeWarning,\n                )\n                noise_params = self.noise_params\n\n        if noise_params is not None:\n            if random_key is None:\n                warnings.warn(\n                    \"Explicit call to `_circuit` or `_variational` detected: \"\n                    \"`random_key` is None, using `random.PRNGKey(0)` instead.\",\n                    RuntimeWarning,\n                )\n                random_key = self.random_key\n            self._apply_state_prep_noise(noise_params=noise_params)\n\n        # state preparation\n        for q in range(self.n_qubits):\n            for _sp, sp_pulse_params in zip(self._sp, self.sp_pulse_params):\n                random_key, sub_key = safe_random_split(random_key)\n                _sp(\n                    wires=q,\n                    pulse_params=sp_pulse_params,\n                    noise_params=noise_params,\n                    random_key=sub_key,\n                    gate_mode=gate_mode,\n                )\n\n        # circuit building\n        for layer in range(0, self.n_layers):\n            self.random_key, sub_key = safe_random_split(self.random_key)\n            # ansatz layers\n            self.pqc(\n                params[layer],\n                self.n_qubits,\n                pulse_params=pulse_params[layer],\n                noise_params=noise_params,\n                random_key=sub_key,\n                gate_mode=gate_mode,\n            )\n\n            self.random_key, sub_key = safe_random_split(self.random_key)\n            # encoding layers\n            self._iec(\n                inputs,\n                data_reupload=self.data_reupload[layer],\n                enc=self._enc,\n                enc_params=enc_params,\n                noise_params=noise_params,\n                random_key=sub_key,\n            )\n\n            # visual barrier\n            if self.has_dru:\n                qml.Barrier(wires=list(range(self.n_qubits)), only_visual=True)\n\n        # final ansatz layer\n        if self.has_dru:  # same check as in init\n            self.random_key, sub_key = safe_random_split(self.random_key)\n            self.pqc(\n                params[self.n_layers],\n                self.n_qubits,\n                pulse_params=pulse_params[-1],\n                noise_params=noise_params,\n                random_key=sub_key,\n                gate_mode=gate_mode,\n            )\n\n        # channel noise\n        if noise_params is not None:\n            self._apply_general_noise(noise_params=noise_params)\n\n    def _observable(self) -&gt; Union[jnp.ndarray, List[jnp.ndarray]]:\n        \"\"\"\n        Define and return the measurement observable(s) for the circuit.\n\n        Constructs the appropriate PennyLane measurement based on the\n        configured execution_type and output_qubit settings.\n\n        Returns:\n            Union[jnp.ndarray, List[jnp.ndarray]]: Measurement result(s):\n                - \"density\": qml.density_matrix for output qubits\n                - \"state\": Full quantum state via qml.state()\n                - \"expval\": Expectation value(s) of PauliZ observable(s)\n                - \"probs\": Measurement probabilities\n\n        Raises:\n            ValueError: If execution_type or output_qubit configuration is invalid.\n        \"\"\"\n        # run mixed simulation and get density matrix\n        if self.execution_type == \"density\":\n            return qml.density_matrix(wires=self.output_qubit)\n        elif self.execution_type == \"state\":\n            return qml.state()\n        # run default simulation and get expectation value\n        elif self.execution_type == \"expval\":\n            # n-local measurement\n            if self.all_qubit_measurement:\n                return [qml.expval(qml.PauliZ(q)) for q in self.output_qubit]\n            # parity or local measurement(s)\n            elif isinstance(self.output_qubit, list):\n                ret = []\n                # list of parity pairs\n                for pair in self.output_qubit:\n                    if isinstance(pair, int):\n                        ret.append(qml.expval(qml.PauliZ(pair)))\n                    else:\n                        obs = qml.PauliZ(pair[0])\n                        for q in pair[1:]:\n                            obs = obs @ qml.PauliZ(q)\n                        ret.append(qml.expval(obs))\n                return ret\n            else:\n                raise ValueError(\n                    f\"Invalid parameter `output_qubit`: {self.output_qubit}.\\\n                        Must be int, list or -1.\"\n                )\n        # run default simulation and get probs\n        elif self.execution_type == \"probs\":\n            # n-local measurement\n            if self.all_qubit_measurement:\n                return qml.probs(wires=self.output_qubit)\n            # parity or local measurement(s)\n            elif isinstance(self.output_qubit, list):\n                ret = []\n                # list of parity pairs\n                for pair in self.output_qubit:\n                    if isinstance(pair, int):\n                        ret.append(qml.probs(wires=[pair]))\n                    else:\n                        ret.append(qml.probs(wires=pair))\n                return ret\n            else:\n                raise ValueError(\n                    f\"Invalid parameter `output_qubit`: {self.output_qubit}.\\\n                        Must be int, list or -1.\"\n                )\n        else:\n            raise ValueError(f\"Invalid execution_type: {self.execution_type}.\")\n\n    def _apply_state_prep_noise(\n        self, noise_params: Dict[str, Union[float, Dict[str, float]]]\n    ) -&gt; None:\n        \"\"\"\n        Apply state preparation noise to all qubits.\n\n        Simulates imperfect state preparation by applying BitFlip errors\n        to each qubit with the specified probability.\n\n        Args:\n            noise_params (Dict[str, Union[float, Dict[str, float]]]): Dictionary\n                containing noise parameters. Uses the \"StatePreparation\" key\n                for the BitFlip probability.\n\n        Returns:\n            None: Noise channels are applied in-place to the circuit.\n        \"\"\"\n        p = noise_params.get(\"StatePreparation\", 0.0)\n        if p &gt; 0:\n            for q in range(self.n_qubits):\n                qml.BitFlip(p, wires=q)\n\n    def _apply_general_noise(\n        self, noise_params: Dict[str, Union[float, Dict[str, float]]]\n    ) -&gt; None:\n        \"\"\"\n        Apply general noise channels to all qubits.\n\n        Applies various decoherence and error channels after the circuit\n        execution, simulating environmental noise effects.\n\n        Args:\n            noise_params (Dict[str, Union[float, Dict[str, float]]]): Dictionary\n                containing noise parameters with the following supported keys:\n                - \"AmplitudeDamping\" (float): Probability for amplitude damping.\n                - \"PhaseDamping\" (float): Probability for phase damping.\n                - \"Measurement\" (float): Probability for measurement error (BitFlip).\n                - \"ThermalRelaxation\" (Dict): Dictionary with keys \"t1\", \"t2\",\n                  \"t_factor\" for thermal relaxation simulation.\n\n        Returns:\n            None: Noise channels are applied in-place to the circuit.\n\n        Note:\n            Gate-level noise (e.g., GateError) is handled separately in the\n            Gates.Noise module and applied at the individual gate level.\n        \"\"\"\n        amp_damp = noise_params.get(\"AmplitudeDamping\", 0.0)\n        phase_damp = noise_params.get(\"PhaseDamping\", 0.0)\n        thermal_relax = noise_params.get(\"ThermalRelaxation\", 0.0)\n        meas = noise_params.get(\"Measurement\", 0.0)\n        for q in range(self.n_qubits):\n            if amp_damp &gt; 0:\n                qml.AmplitudeDamping(amp_damp, wires=q)\n            if phase_damp &gt; 0:\n                qml.PhaseDamping(phase_damp, wires=q)\n            if meas &gt; 0:\n                qml.BitFlip(meas, wires=q)\n            if isinstance(thermal_relax, dict):\n                t1 = thermal_relax[\"t1\"]\n                t2 = thermal_relax[\"t2\"]\n                t_factor = thermal_relax[\"t_factor\"]\n                circuit_depth = self._get_circuit_depth()\n                tg = circuit_depth * t_factor\n                qml.ThermalRelaxationError(1.0, t1, t2, tg, q)\n\n    def _get_circuit_depth(self, inputs: Optional[jnp.ndarray] = None) -&gt; int:\n        \"\"\"\n        Calculate the depth of the quantum circuit.\n\n        Creates a copy of the model without noise to accurately measure\n        the circuit depth using PennyLane's specs function.\n\n        Args:\n            inputs (Optional[jnp.ndarray]): Input data for circuit evaluation.\n                If None, default zero inputs are used.\n\n        Returns:\n            int: The circuit depth (longest path of gates in the circuit).\n        \"\"\"\n        inputs = self._inputs_validation(inputs)\n        spec_model = deepcopy(self)\n        spec_model.noise_params = None  # remove noise\n        specs = qml.specs(spec_model.circuit)(self.params, inputs)\n\n        return specs[\"resources\"].depth\n\n    def draw(\n        self,\n        inputs: Optional[jnp.ndarray] = None,\n        figure: str = \"text\",\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Union[str, Any]:\n        \"\"\"\n        Visualize the quantum circuit.\n\n        Generates a visual representation of the circuit using the specified\n        rendering method.\n\n        Args:\n            inputs (Optional[jnp.ndarray]): Input data for the circuit. If None,\n                default zero inputs are used. Defaults to None.\n            figure (str): Visualization format. Options:\n                - \"text\": ASCII text representation\n                - \"mpl\": Matplotlib figure\n                - \"tikz\": TikZ/LaTeX code for publication-quality figures\n                Defaults to \"text\".\n            *args (Any): Additional positional arguments passed to the\n                visualization backend.\n            **kwargs (Any): Additional keyword arguments passed to the\n                visualization backend. May include pulse_params, gate_mode,\n                enc_params, or noise_params.\n\n        Returns:\n            Union[str, Any]: Visualization output:\n                - \"text\": String with ASCII circuit diagram\n                - \"mpl\": Matplotlib Figure and Axes objects\n                - \"tikz\": TikZ code string\n\n        Raises:\n            AssertionError: If figure is not one of \"text\", \"mpl\", or \"tikz\".\n        \"\"\"\n\n        if not isinstance(self.circuit, qml.QNode):\n            # TODO: throws strange argument error if not catched\n            return \"\"\n\n        assert figure in [\n            \"text\",\n            \"mpl\",\n            \"tikz\",\n        ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n        inputs = self._inputs_validation(inputs)\n\n        if figure == \"mpl\":\n            return qml.draw_mpl(self.circuit)(\n                params=self.params,\n                inputs=inputs,\n                *args,\n                **kwargs,\n            )\n        elif figure == \"tikz\":\n            return QuanTikz.build(\n                self.circuit,\n                params=self.params,\n                inputs=inputs,\n                *args,\n                **kwargs,\n            )\n        else:\n            return qml.draw(self.circuit)(params=self.params, inputs=inputs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return text representation of the quantum circuit.\"\"\"\n        return self.draw(figure=\"text\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of the quantum circuit.\"\"\"\n        return self.draw(figure=\"text\")\n\n    def _params_validation(self, params: Optional[jnp.ndarray]) -&gt; jnp.ndarray:\n        \"\"\"\n        Validate and normalize variational parameters.\n\n        Ensures parameters have the correct shape with a batch dimension,\n        and updates the model's internal parameters if new ones are provided.\n\n        Args:\n            params (Optional[jnp.ndarray]): Variational parameters to validate.\n                If None, returns the model's current parameters.\n\n        Returns:\n            jnp.ndarray: Validated parameters with shape\n                (n_layers, n_params_per_layer, batch_size).\n        \"\"\"\n        # append batch axis if not provided\n        if params is not None:\n            if len(params.shape) == 2:\n                params = np.expand_dims(params, axis=-1)\n\n            self.params = params\n        else:\n            params = self.params\n\n        return params\n\n    def _pulse_params_validation(\n        self, pulse_params: Optional[jnp.ndarray]\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Validate and normalize pulse parameters.\n\n        Ensures pulse parameters are set, using model defaults if not provided.\n\n        Args:\n            pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers.\n                If None, returns the model's current pulse parameters.\n\n        Returns:\n            jnp.ndarray: Validated pulse parameters with shape\n                (n_layers, n_pulse_params_per_layer, batch_size).\n        \"\"\"\n        if pulse_params is None:\n            pulse_params = self.pulse_params\n        else:\n            self.pulse_params = pulse_params\n\n        return pulse_params\n\n    def _enc_params_validation(self, enc_params: Optional[jnp.ndarray]) -&gt; jnp.ndarray:\n        \"\"\"\n        Validate and normalize encoding parameters.\n\n        Ensures encoding parameters have the correct shape for the model's\n        input feature dimensions.\n\n        Args:\n            enc_params (Optional[jnp.ndarray]): Encoding parameters to validate.\n                If None, returns the model's current encoding parameters.\n\n        Returns:\n            jnp.ndarray: Validated encoding parameters with shape\n                (n_qubits, n_input_feat).\n\n        Raises:\n            ValueError: If enc_params shape is incompatible with n_input_feat &gt; 1.\n        \"\"\"\n        if enc_params is None:\n            enc_params = self.enc_params\n        else:\n            if self.trainable_frequencies:\n                self.enc_params = enc_params\n            else:\n                self.enc_params = jnp.array(enc_params)\n\n        if len(enc_params.shape) == 1 and self.n_input_feat == 1:\n            enc_params = enc_params.reshape(-1, 1)\n        elif len(enc_params.shape) == 1 and self.n_input_feat &gt; 1:\n            raise ValueError(\n                f\"Input dimension {self.n_input_feat} &gt;1 but \\\n                `enc_params` has shape {enc_params.shape}\"\n            )\n\n        return enc_params\n\n    def _inputs_validation(\n        self, inputs: Union[None, List, float, int, jnp.ndarray]\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Validate and normalize input data.\n\n        Converts various input formats to a standardized 2D array shape\n        suitable for batch processing in the quantum circuit.\n\n        Args:\n            inputs (Union[None, List, float, int, jnp.ndarray]): Input data in\n                various formats:\n                - None: Returns zeros with shape (1, n_input_feat)\n                - float/int: Single scalar value\n                - List: List of values or batched inputs\n                - jnp.ndarray: NumPy/JAX array\n\n        Returns:\n            jnp.ndarray: Validated inputs with shape (batch_size, n_input_feat).\n\n        Raises:\n            ValueError: If input shape is incompatible with expected n_input_feat.\n\n        Warns:\n            UserWarning: If input is replicated to match n_input_feat.\n        \"\"\"\n        self._zero_inputs = False\n        if isinstance(inputs, List):\n            inputs = jnp.array(np.stack(inputs))\n        elif isinstance(inputs, float) or isinstance(inputs, int):\n            inputs = jnp.array([inputs])\n        elif inputs is None:\n            inputs = jnp.array([[0] * self.n_input_feat])\n\n        if not inputs.any():\n            self._zero_inputs = True\n\n        if len(inputs.shape) &lt;= 1:\n            if self.n_input_feat == 1:\n                # add a batch dimension\n                inputs = inputs.reshape(-1, 1)\n            else:\n                if inputs.shape[0] == self.n_input_feat:\n                    inputs = inputs.reshape(1, -1)\n                else:\n                    inputs = inputs.reshape(-1, 1)\n                    inputs = inputs.repeat(self.n_input_feat, axis=1)\n                    warnings.warn(\n                        f\"Expected {self.n_input_feat} inputs, but {inputs.shape[0]} \"\n                        \"was provided, replicating input for all input features.\",\n                        UserWarning,\n                    )\n        else:\n            if inputs.shape[1] != self.n_input_feat:\n                raise ValueError(\n                    f\"Wrong number of inputs provided. Expected {self.n_input_feat} \"\n                    f\"inputs, but input has shape {inputs.shape}.\"\n                )\n\n        return inputs\n\n    def _mp_executor(\n        self,\n        f: Callable,\n        params: jnp.ndarray,\n        pulse_params: jnp.ndarray,\n        inputs: jnp.ndarray,\n        enc_params: jnp.ndarray,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]],\n        random_key: random.PRNGKey,\n        gate_mode: str,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Execute circuit function with optional parallelization over batches.\n\n        Uses JAX's vmap for vectorized execution when batching over inputs,\n        parameters, or pulse parameters. Falls back to sequential execution\n        for single samples or when multithreading is disabled.\n\n        Args:\n            f (Callable): Circuit function to execute (circuit or circuit_mixed).\n            params (jnp.ndarray): Variational parameters of shape\n                (n_layers, n_params_per_layer, batch_size).\n            pulse_params (jnp.ndarray): Pulse parameters of shape\n                (n_layers, n_pulse_params_per_layer, batch_size).\n            inputs (jnp.ndarray): Input data of shape (batch_size, n_input_feat).\n            enc_params (jnp.ndarray): Encoding parameters of shape\n                (n_qubits, n_input_feat).\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise configuration dictionary.\n            random_key (random.PRNGKey): JAX random key for stochastic operations.\n            gate_mode (str): Gate execution mode (\"unitary\" or \"pulse\").\n\n        Returns:\n            jnp.ndarray: Circuit execution results, post-processed for uniformity.\n        \"\"\"\n\n        def _f(\n            _params: jnp.ndarray,\n            _inputs: jnp.ndarray,\n            _pulse_params: jnp.ndarray,\n            _random_key: random.PRNGKey,\n        ) -&gt; jnp.ndarray:\n            return f(\n                params=_params,\n                inputs=_inputs,\n                pulse_params=_pulse_params,\n                random_key=_random_key,\n                noise_params=noise_params,\n                enc_params=enc_params,\n                gate_mode=gate_mode,\n            )\n\n        B = np.prod(self.eff_batch_shape)\n        if (gate_mode == \"pulse\" or self.use_multithreading) and B &gt; 1:\n            random_keys = safe_random_split(random_key, num=B)\n\n            # wrapper to allow kwargs (not supported by jax)\n            result = jax.vmap(\n                _f,\n                in_axes=(\n                    2 if self.batch_shape[1] &gt; 1 else None,  # params\n                    0 if self.batch_shape[0] &gt; 1 else None,  # inputs\n                    2 if self.batch_shape[2] &gt; 1 else None,  # pulse_params\n                    0,  # random_keys\n                ),\n            )(\n                params,\n                inputs,\n                pulse_params,\n                random_keys,\n            )\n        else:\n            result = f(\n                params=params,\n                pulse_params=pulse_params,\n                inputs=inputs,\n                enc_params=enc_params,\n                noise_params=noise_params,\n                random_key=random_key,\n                gate_mode=gate_mode,\n            )\n\n        return self._postprocess_res(result)\n\n    def _postprocess_res(self, result: Union[List, jnp.ndarray]) -&gt; jnp.ndarray:\n        \"\"\"\n        Post-process circuit execution results for uniform shape.\n\n        Converts list outputs (from multiple measurements) to stacked arrays\n        and reorders axes for consistent batch dimension placement.\n\n        Args:\n            result (Union[List, jnp.ndarray]): Raw circuit output, either a\n                list of measurement results or a single array.\n\n        Returns:\n            jnp.ndarray: Uniformly shaped result array with batch dimension first.\n        \"\"\"\n        if isinstance(result, list):\n            # we use moveaxis here because in case of parity measure,\n            # there is another dimension appended to the end and\n            # simply transposing would result in a wrong shape\n            result = jnp.stack(result)\n            if len(result.shape) &gt; 1:\n                result = jnp.moveaxis(result, 0, 1)\n        return result\n\n    def _assimilate_batch(\n        self,\n        inputs: jnp.ndarray,\n        params: jnp.ndarray,\n        pulse_params: jnp.ndarray,\n    ) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n        \"\"\"\n        Align batch dimensions across inputs, parameters, and pulse parameters.\n\n        Broadcasts and reshapes arrays to have compatible batch dimensions\n        for vectorized circuit execution. Sets the internal batch_shape.\n\n        Args:\n            inputs (jnp.ndarray): Input data of shape (B_I, n_input_feat).\n            params (jnp.ndarray): Parameters of shape (n_layers, n_params, B_P).\n            pulse_params (jnp.ndarray): Pulse params of shape (n_layers, n_pulse, B_R).\n\n        Returns:\n            Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]: Tuple containing:\n                - inputs: Reshaped to (B, n_input_feat) where B = B_I * B_P * B_R\n                - params: Reshaped to (n_layers, n_params, B)\n                - pulse_params: Reshaped to (n_layers, n_pulse, B)\n\n        Note:\n            The effective batch shape depends on repeat_batch_axis configuration.\n            This is the only method that sets self._batch_shape.\n        \"\"\"\n        B_I = inputs.shape[0]\n        # we check for the product because there is a chance that\n        # there are no params. In this case we want B_P to be 1\n        B_P = 1 if 0 in params.shape else params.shape[-1]\n        B_R = pulse_params.shape[-1]\n\n        # THIS is the only place where we set the batch shape\n        self._batch_shape = (B_I, B_P, B_R)\n        B = np.prod(self.eff_batch_shape)\n\n        # [B_I, ...] -&gt; [B_I, B_P, B_R, ...] -&gt; [B, ...]\n        if B_I &gt; 1 and self.repeat_batch_axis[0]:\n            if self.repeat_batch_axis[1]:\n                inputs = jnp.repeat(inputs[:, None, None, ...], B_P, axis=1)\n            if self.repeat_batch_axis[2]:\n                inputs = jnp.repeat(inputs, B_R, axis=2)\n            inputs = inputs.reshape(B, *inputs.shape[3:])\n\n        # [..., ..., B_P] -&gt; [..., ..., B_I, B_P, B_R] -&gt; [..., ..., B]\n        if B_P &gt; 1 and self.repeat_batch_axis[1]:\n            # add B_I axis before last, and B_R axis after last\n            params = params[..., None, :, None]  # [..., B_I(=1), B_P, B_R(=1)]\n            if self.repeat_batch_axis[0]:\n                params = jnp.repeat(params, B_I, axis=-3)  # [..., B_I, B_P, 1]\n            if self.repeat_batch_axis[2]:\n                params = jnp.repeat(params, B_R, axis=-1)  # [..., B_I, B_P, B_R]\n            params = params.reshape(*params.shape[:-3], B)\n\n        # [..., ..., B_R] -&gt; [..., ..., B_I, B_P, B_R] -&gt; [..., ..., B]\n        if B_R &gt; 1 and self.repeat_batch_axis[2]:\n            # add B_I axis before last, and B_P axis before last (after adding B_I)\n            pulse_params = pulse_params[\n                ..., None, None, :\n            ]  # [..., B_I(=1), B_P(=1), B_R]\n            if self.repeat_batch_axis[0]:\n                pulse_params = jnp.repeat(\n                    pulse_params, B_I, axis=-3\n                )  # [..., B_I, 1, B_R]\n            if self.repeat_batch_axis[1]:\n                pulse_params = jnp.repeat(\n                    pulse_params, B_P, axis=-2\n                )  # [..., B_I, B_P, B_R]\n            pulse_params = pulse_params.reshape(*pulse_params.shape[:-3], B)\n\n        return inputs, params, pulse_params\n\n    def _requires_density(self) -&gt; bool:\n        \"\"\"\n        Check if density matrix simulation is required.\n\n        Determines whether the circuit must be executed with the mixed-state\n        simulator based on execution type and noise configuration.\n\n        Returns:\n            bool: True if density matrix simulation is required, False otherwise.\n                Returns True if:\n                - execution_type is \"density\", or\n                - Any non-coherent noise channel has non-zero probability\n        \"\"\"\n        if self.execution_type == \"density\":\n            return True\n\n        if self.noise_params is None:\n            return False\n\n        coherent_noise = {\"GateError\"}\n        for k, v in self.noise_params.items():\n            if k in coherent_noise:\n                continue\n            if v is not None and v &gt; 0:\n                return True\n        return False\n\n    def __call__(\n        self,\n        params: Optional[jnp.ndarray] = None,\n        inputs: Optional[jnp.ndarray] = None,\n        pulse_params: Optional[jnp.ndarray] = None,\n        enc_params: Optional[jnp.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n        gate_mode: str = \"unitary\",\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Execute the quantum circuit (callable interface).\n\n        Provides a convenient callable interface for circuit execution,\n        delegating to the _forward method.\n\n        Args:\n            params (Optional[jnp.ndarray]): Variational parameters of shape\n                (n_layers, n_params_per_layer) or (n_layers, n_params_per_layer, batch).\n                If None, uses model's internal parameters.\n            inputs (Optional[jnp.ndarray]): Input data of shape\n                (batch_size, n_input_feat). If None, uses zero inputs.\n            pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers for\n                pulse-mode gate execution.\n            enc_params (Optional[jnp.ndarray]): Encoding parameters of shape\n                (n_qubits, n_input_feat). If None, uses model's encoding parameters.\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise configuration. If None, uses previously set noise parameters.\n            execution_type (Optional[str]): Measurement type: \"expval\", \"density\",\n                \"probs\", or \"state\". If None, uses current execution_type setting.\n            force_mean (bool): If True, averages results over measurement qubits.\n                Defaults to False.\n            gate_mode (str): Gate execution backend, \"unitary\" or \"pulse\".\n                Defaults to \"unitary\".\n\n        Returns:\n            jnp.ndarray: Circuit output with shape depending on execution_type:\n                - \"expval\": (n_output_qubits,) or scalar\n                - \"density\": (2^n_output, 2^n_output)\n                - \"probs\": (2^n_output,) or (n_pairs, 2^pair_size)\n                - \"state\": (2^n_qubits,)\n        \"\"\"\n        # Call forward method which handles the actual caching etc.\n        return self._forward(\n            params=params,\n            inputs=inputs,\n            pulse_params=pulse_params,\n            enc_params=enc_params,\n            noise_params=noise_params,\n            execution_type=execution_type,\n            force_mean=force_mean,\n            gate_mode=gate_mode,\n        )\n\n    def _forward(\n        self,\n        params: Optional[jnp.ndarray] = None,\n        inputs: Optional[jnp.ndarray] = None,\n        pulse_params: Optional[jnp.ndarray] = None,\n        enc_params: Optional[jnp.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n        gate_mode: str = \"unitary\",\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Execute the quantum circuit forward pass.\n\n        Internal implementation of the forward pass that handles parameter\n        validation, batch alignment, and circuit execution routing.\n\n        Args:\n            params (Optional[jnp.ndarray]): Variational parameters of shape\n                (n_layers, n_params_per_layer) or\n                (n_layers, n_params_per_layer, batch).\n                If None, uses model's internal parameters.\n            inputs (Optional[jnp.ndarray]): Input data of shape\n                (batch_size, n_input_feat).\n                If None, uses zero inputs.\n            pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers for\n                pulse-mode gate execution.\n            enc_params (Optional[jnp.ndarray]): Encoding parameters of shape\n                (n_qubits, n_input_feat). If None, uses model's encoding parameters.\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                Noise configuration. If None, uses previously set noise parameters.\n            execution_type (Optional[str]): Measurement type: \"expval\", \"density\",\n                \"probs\", or \"state\". If None, uses current execution_type setting.\n            force_mean (bool): If True, averages results over measurement qubits.\n                Defaults to False.\n            gate_mode (str): Gate execution backend, \"unitary\" or \"pulse\".\n                Defaults to \"unitary\".\n\n        Returns:\n            jnp.ndarray: Circuit output with shape depending on execution_type:\n                - \"expval\": (n_output_qubits,) or scalar\n                - \"density\": (2^n_output, 2^n_output)\n                - \"probs\": (2^n_output,) or (n_pairs, 2^pair_size)\n                - \"state\": (2^n_qubits,)\n\n        Raises:\n            ValueError: If pulse_params provided without pulse gate_mode, or\n                if noise_params provided with pulse gate_mode.\n        \"\"\"\n        # set the parameters as object attributes\n        if noise_params is not None:\n            self.noise_params = noise_params\n        if execution_type is not None:\n            self.execution_type = execution_type\n        self.gate_mode = gate_mode\n\n        # consistency checks\n        if pulse_params is not None and gate_mode != \"pulse\":\n            raise ValueError(\n                \"pulse_params were provided but gate_mode is not 'pulse'. \"\n                \"Either switch gate_mode='pulse' or do not pass pulse_params.\"\n            )\n\n        if noise_params is not None and gate_mode == \"pulse\":\n            raise ValueError(\n                \"Noise is not supported in 'pulse' gate_mode. \"\n                \"Either remove noise_params or use gate_mode='unitary'.\"\n            )\n\n        params = self._params_validation(params)\n        pulse_params = self._pulse_params_validation(pulse_params)\n        inputs = self._inputs_validation(inputs)\n        enc_params = self._enc_params_validation(enc_params)\n\n        inputs, params, pulse_params = self._assimilate_batch(\n            inputs,\n            params,\n            pulse_params,\n        )\n\n        result: Optional[jnp.ndarray] = None\n        self.random_key, subkey = safe_random_split(self.random_key)\n\n        # if density matrix requested or noise params used\n        if self._requires_density():\n            result = self._mp_executor(\n                f=self.circuit_mixed,\n                params=params,\n                pulse_params=pulse_params,\n                inputs=inputs,\n                enc_params=enc_params,\n                noise_params=self.noise_params,\n                random_key=subkey,\n                gate_mode=gate_mode,\n            )\n        else:\n            if not isinstance(self.circuit, qml.QNode):\n                result = self.circuit(\n                    inputs=inputs,\n                )\n            else:\n                result = self._mp_executor(\n                    f=self.circuit,\n                    params=params,\n                    pulse_params=pulse_params,\n                    inputs=inputs,\n                    enc_params=enc_params,\n                    noise_params=self.noise_params,\n                    random_key=subkey,\n                    gate_mode=gate_mode,\n                )\n\n        result = result.reshape((*self.eff_batch_shape, *self._result_shape)).squeeze()\n\n        if (\n            self.execution_type in (\"expval\", \"probs\")\n            and force_mean\n            and len(result.shape) &gt; 0\n            and self._result_shape[0] &gt; 1\n        ):\n            result = result.mean(axis=-1)\n\n        return result\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.all_qubit_measurement","title":"<code>all_qubit_measurement</code>  <code>property</code>","text":"<p>Check if measurement is performed on all qubits.</p>"},{"location":"references/#qml_essentials.model.Model.batch_shape","title":"<code>batch_shape</code>  <code>property</code>","text":"<p>Get the batch shape (B_I, B_P, B_R).</p> <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple[int, ...]: Tuple of (input_batch, param_batch, pulse_batch). Returns (1, 1, 1) if model has not been called yet.</p>"},{"location":"references/#qml_essentials.model.Model.eff_batch_shape","title":"<code>eff_batch_shape</code>  <code>property</code>","text":"<p>Get the effective batch shape after applying repeat_batch_axis mask.</p> <p>Returns:</p> Type Description <code>Tuple[int, ...]</code> <p>Tuple[int, ...]: Effective batch dimensions, excluding zeros.</p>"},{"location":"references/#qml_essentials.model.Model.enc_params","title":"<code>enc_params</code>  <code>property</code> <code>writable</code>","text":"<p>Get the encoding parameters used for input transformation.</p>"},{"location":"references/#qml_essentials.model.Model.execution_type","title":"<code>execution_type</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the execution type of the model.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The execution type, one of 'density', 'expval', or 'probs'.</p>"},{"location":"references/#qml_essentials.model.Model.noise_params","title":"<code>noise_params</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the noise parameters of the model.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>Optional[Dict[str, float]]: A dictionary of</p> <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>noise parameters or None if not set.</p>"},{"location":"references/#qml_essentials.model.Model.output_qubit","title":"<code>output_qubit</code>  <code>property</code> <code>writable</code>","text":"<p>Get the output qubit indices for measurement.</p>"},{"location":"references/#qml_essentials.model.Model.params","title":"<code>params</code>  <code>property</code> <code>writable</code>","text":"<p>Get the variational parameters of the model.</p>"},{"location":"references/#qml_essentials.model.Model.pulse_params","title":"<code>pulse_params</code>  <code>property</code> <code>writable</code>","text":"<p>Get the pulse parameters for pulse-mode gate execution.</p>"},{"location":"references/#qml_essentials.model.Model.shots","title":"<code>shots</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the number of shots to use for the quantum device.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The number of shots.</p>"},{"location":"references/#qml_essentials.model.Model.__call__","title":"<code>__call__(params=None, inputs=None, pulse_params=None, enc_params=None, noise_params=None, execution_type=None, force_mean=False, gate_mode='unitary')</code>","text":"<p>Execute the quantum circuit (callable interface).</p> <p>Provides a convenient callable interface for circuit execution, delegating to the _forward method.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Optional[ndarray]</code> <p>Variational parameters of shape (n_layers, n_params_per_layer) or (n_layers, n_params_per_layer, batch). If None, uses model's internal parameters.</p> <code>None</code> <code>inputs</code> <code>Optional[ndarray]</code> <p>Input data of shape (batch_size, n_input_feat). If None, uses zero inputs.</p> <code>None</code> <code>pulse_params</code> <code>Optional[ndarray]</code> <p>Pulse parameter scalers for pulse-mode gate execution.</p> <code>None</code> <code>enc_params</code> <code>Optional[ndarray]</code> <p>Encoding parameters of shape (n_qubits, n_input_feat). If None, uses model's encoding parameters.</p> <code>None</code> <code>noise_params</code> <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>Noise configuration. If None, uses previously set noise parameters.</p> <code>None</code> <code>execution_type</code> <code>Optional[str]</code> <p>Measurement type: \"expval\", \"density\", \"probs\", or \"state\". If None, uses current execution_type setting.</p> <code>None</code> <code>force_mean</code> <code>bool</code> <p>If True, averages results over measurement qubits. Defaults to False.</p> <code>False</code> <code>gate_mode</code> <code>str</code> <p>Gate execution backend, \"unitary\" or \"pulse\". Defaults to \"unitary\".</p> <code>'unitary'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Circuit output with shape depending on execution_type: - \"expval\": (n_output_qubits,) or scalar - \"density\": (2^n_output, 2^n_output) - \"probs\": (2^n_output,) or (n_pairs, 2^pair_size) - \"state\": (2^n_qubits,)</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __call__(\n    self,\n    params: Optional[jnp.ndarray] = None,\n    inputs: Optional[jnp.ndarray] = None,\n    pulse_params: Optional[jnp.ndarray] = None,\n    enc_params: Optional[jnp.ndarray] = None,\n    noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n    execution_type: Optional[str] = None,\n    force_mean: bool = False,\n    gate_mode: str = \"unitary\",\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Execute the quantum circuit (callable interface).\n\n    Provides a convenient callable interface for circuit execution,\n    delegating to the _forward method.\n\n    Args:\n        params (Optional[jnp.ndarray]): Variational parameters of shape\n            (n_layers, n_params_per_layer) or (n_layers, n_params_per_layer, batch).\n            If None, uses model's internal parameters.\n        inputs (Optional[jnp.ndarray]): Input data of shape\n            (batch_size, n_input_feat). If None, uses zero inputs.\n        pulse_params (Optional[jnp.ndarray]): Pulse parameter scalers for\n            pulse-mode gate execution.\n        enc_params (Optional[jnp.ndarray]): Encoding parameters of shape\n            (n_qubits, n_input_feat). If None, uses model's encoding parameters.\n        noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n            Noise configuration. If None, uses previously set noise parameters.\n        execution_type (Optional[str]): Measurement type: \"expval\", \"density\",\n            \"probs\", or \"state\". If None, uses current execution_type setting.\n        force_mean (bool): If True, averages results over measurement qubits.\n            Defaults to False.\n        gate_mode (str): Gate execution backend, \"unitary\" or \"pulse\".\n            Defaults to \"unitary\".\n\n    Returns:\n        jnp.ndarray: Circuit output with shape depending on execution_type:\n            - \"expval\": (n_output_qubits,) or scalar\n            - \"density\": (2^n_output, 2^n_output)\n            - \"probs\": (2^n_output,) or (n_pairs, 2^pair_size)\n            - \"state\": (2^n_qubits,)\n    \"\"\"\n    # Call forward method which handles the actual caching etc.\n    return self._forward(\n        params=params,\n        inputs=inputs,\n        pulse_params=pulse_params,\n        enc_params=enc_params,\n        noise_params=noise_params,\n        execution_type=execution_type,\n        force_mean=force_mean,\n        gate_mode=gate_mode,\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.__init__","title":"<code>__init__(n_qubits, n_layers, circuit_type='No_Ansatz', data_reupload=True, state_preparation=None, encoding=Gates.RX, trainable_frequencies=False, initialization='random', initialization_domain=[0, 2 * jnp.pi], output_qubit=-1, shots=None, random_seed=1000, remove_zero_encoding=True, use_multithreading=False, repeat_batch_axis=[True, True, True])</code>","text":"<p>Initialize the quantum circuit model. Parameters will have the shape [impl_n_layers, parameters_per_layer] where impl_n_layers is the number of layers provided and added by one depending if data_reupload is True and parameters_per_layer is given by the chosen ansatz.</p> <p>The model is initialized with the following parameters as defaults: - noise_params: None - execution_type: \"expval\" - shots: None</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits in the circuit.</p> required <code>n_layers</code> <code>int</code> <p>The number of layers in the circuit.</p> required <code>circuit_type</code> <code>(str, Circuit)</code> <p>The type of quantum circuit to use. If None, defaults to \"no_ansatz\".</p> <code>'No_Ansatz'</code> <code>data_reupload</code> <code>Union[bool, List[bool], List[List[bool]]]</code> <p>Whether to reupload data to the quantum device on each layer and qubit. Detailed re-uploading instructions can be given as a list/array of 0/False and 1/True with shape (n_qubits, n_layers) to specify where to upload the data. Defaults to True for applying data re-uploading to the full circuit.</p> <code>True</code> <code>encoding</code> <code>Union[str, Callable, List[str], List[Callable]]</code> <p>The unitary to use for encoding the input data. Can be a string (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX. If input is multidimensional it is assumed to be a list of unitaries or a list of strings.</p> <code>RX</code> <code>trainable_frequencies</code> <code>bool</code> <p>Sets trainable encoding parameters for trainable frequencies. Defaults to False.</p> <code>False</code> <code>initialization</code> <code>str</code> <p>The strategy to initialize the parameters. Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\". Defaults to \"random\".</p> <code>'random'</code> <code>output_qubit</code> <code>(List[int], int)</code> <p>The index of the output qubit (or qubits). When set to -1 all qubits are measured, or a global measurement is conducted, depending on the execution type.</p> <code>-1</code> <code>shots</code> <code>Optional[int]</code> <p>The number of shots to use for the quantum device. Defaults to None.</p> <code>None</code> <code>random_seed</code> <code>int</code> <p>seed for the random number generator in initialization is \"random\" and for random noise parameters. Defaults to 1000.</p> <code>1000</code> <code>remove_zero_encoding</code> <code>bool</code> <p>whether to remove the zero encoding from the circuit. Defaults to True.</p> <code>True</code> <code>use_multithreading</code> <code>bool</code> <p>whether to use JAX multithreading to parallelise over batch dimension.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __init__(\n    self,\n    n_qubits: int,\n    n_layers: int,\n    circuit_type: Union[str, Circuit] = \"No_Ansatz\",\n    data_reupload: Union[bool, List[List[bool]], List[List[List[bool]]]] = True,\n    state_preparation: Union[\n        str, Callable, List[Union[str, Callable]], None\n    ] = None,\n    encoding: Union[Encoding, str, Callable, List[Union[str, Callable]]] = Gates.RX,\n    trainable_frequencies: bool = False,\n    initialization: str = \"random\",\n    initialization_domain: List[float] = [0, 2 * jnp.pi],\n    output_qubit: Union[List[int], int] = -1,\n    shots: Optional[int] = None,\n    random_seed: int = 1000,\n    remove_zero_encoding: bool = True,\n    use_multithreading: bool = False,\n    repeat_batch_axis: List[bool] = [True, True, True],\n) -&gt; None:\n    \"\"\"\n    Initialize the quantum circuit model.\n    Parameters will have the shape [impl_n_layers, parameters_per_layer]\n    where impl_n_layers is the number of layers provided and added by one\n    depending if data_reupload is True and parameters_per_layer is given by\n    the chosen ansatz.\n\n    The model is initialized with the following parameters as defaults:\n    - noise_params: None\n    - execution_type: \"expval\"\n    - shots: None\n\n    Args:\n        n_qubits (int): The number of qubits in the circuit.\n        n_layers (int): The number of layers in the circuit.\n        circuit_type (str, Circuit): The type of quantum circuit to use.\n            If None, defaults to \"no_ansatz\".\n        data_reupload (Union[bool, List[bool], List[List[bool]]], optional):\n            Whether to reupload data to the quantum device on each\n            layer and qubit. Detailed re-uploading instructions can be given\n            as a list/array of 0/False and 1/True with shape (n_qubits,\n            n_layers) to specify where to upload the data. Defaults to True\n            for applying data re-uploading to the full circuit.\n        encoding (Union[str, Callable, List[str], List[Callable]], optional):\n            The unitary to use for encoding the input data. Can be a string\n            (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n            If input is multidimensional it is assumed to be a list of\n            unitaries or a list of strings.\n        trainable_frequencies (bool, optional):\n            Sets trainable encoding parameters for trainable frequencies.\n            Defaults to False.\n        initialization (str, optional): The strategy to initialize the parameters.\n            Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n            Defaults to \"random\".\n        output_qubit (List[int], int, optional): The index of the output\n            qubit (or qubits). When set to -1 all qubits are measured, or a\n            global measurement is conducted, depending on the execution\n            type.\n        shots (Optional[int], optional): The number of shots to use for\n            the quantum device. Defaults to None.\n        random_seed (int, optional): seed for the random number generator\n            in initialization is \"random\" and for random noise parameters.\n            Defaults to 1000.\n        remove_zero_encoding (bool, optional): whether to\n            remove the zero encoding from the circuit. Defaults to True.\n        use_multithreading (bool, optional): whether to use JAX\n            multithreading to parallelise over batch dimension.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize default parameters needed for circuit evaluation\n    self.n_qubits: int = n_qubits\n    self.output_qubit: Union[List[int], int] = output_qubit\n    self.n_layers: int = n_layers\n    self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n    self.shots = shots\n    self.remove_zero_encoding = remove_zero_encoding\n    self.use_multithreading = use_multithreading\n    self.trainable_frequencies: bool = trainable_frequencies\n    self.execution_type: str = \"expval\"\n    self.repeat_batch_axis: List[bool] = repeat_batch_axis\n\n    # --- State Preparation ---\n    try:\n        self._sp = Gates.parse_gates(state_preparation, Gates)\n    except ValueError as e:\n        raise ValueError(f\"Error parsing encodings: {e}\")\n\n    # prepare corresponding pulse parameters (always optimized pulses)\n    self.sp_pulse_params = []\n    for sp in self._sp:\n        sp_name = sp.__name__ if hasattr(sp, \"__name__\") else str(sp)\n\n        if pinfo.gate_by_name(sp_name) is not None:\n            params = jnp.array(pinfo.gate_by_name(sp_name))\n            self.sp_pulse_params.append(params)\n        else:\n            # gate has no pulse parametrization\n            self.sp_pulse_params.append(None)\n\n    # --- Encoding ---\n    if isinstance(encoding, Encoding):\n        # user wants custom strategy? do it!\n        self._enc = encoding\n    else:\n        # use hammming encoding by default\n        self._enc = Encoding(\"hamming\", encoding)\n\n    # Number of possible inputs\n    self.n_input_feat = len(self._enc)\n    log.debug(f\"Number of input features: {self.n_input_feat}\")\n\n    # Trainable frequencies, default initialization as in arXiv:2309.03279v2\n    self.enc_params = jnp.ones((self.n_qubits, self.n_input_feat))\n\n    self._zero_inputs = False\n\n    # --- Data-Reuploading ---\n    # Process data reuploading strategy and set degree\n    if not isinstance(data_reupload, bool):\n        if not isinstance(data_reupload, np.ndarray):\n            data_reupload = np.array(data_reupload)\n\n        if len(data_reupload.shape) == 2:\n            assert data_reupload.shape == (\n                n_layers,\n                n_qubits,\n            ), f\"Data reuploading array has wrong shape. \\\n                Expected {(n_layers, n_qubits)} or\\\n                {(n_layers, n_qubits, self.n_input_feat)},\\\n                got {data_reupload.shape}.\"\n            data_reupload = data_reupload.reshape(*data_reupload.shape, 1)\n            data_reupload = np.repeat(data_reupload, self.n_input_feat, axis=2)\n\n        assert data_reupload.shape == (\n            n_layers,\n            n_qubits,\n            self.n_input_feat,\n        ), f\"Data reuploading array has wrong shape. \\\n            Expected {(n_layers, n_qubits, self.n_input_feat)},\\\n            got {data_reupload.shape}.\"\n\n        log.debug(f\"Data reuploading array:\\n{data_reupload}\")\n    else:\n        if data_reupload:\n            impl_n_layers: int = (\n                n_layers + 1\n            )  # we need L+1 according to Schuld et al.\n            data_reupload = np.ones((n_layers, n_qubits, self.n_input_feat))\n            log.debug(\"Full data reuploading.\")\n        else:\n            impl_n_layers: int = n_layers\n            data_reupload = np.zeros((n_layers, n_qubits, self.n_input_feat))\n            data_reupload[0][0] = 1\n            log.debug(\"No data reuploading.\")\n\n    # convert to boolean values\n    data_reupload = data_reupload.astype(bool)\n    self.data_reupload = jnp.array(data_reupload)\n\n    self.degree: Tuple = tuple(\n        self._enc.get_n_freqs(jnp.count_nonzero(self.data_reupload[..., i]))\n        for i in range(self.n_input_feat)\n    )\n\n    self.frequencies: Tuple = tuple(\n        self._enc.get_spectrum(jnp.count_nonzero(self.data_reupload[..., i]))\n        for i in range(self.n_input_feat)\n    )\n\n    self.has_dru = jnp.max(jnp.array([jnp.max(f) for f in self.frequencies])) &gt; 1\n\n    # check for the highest degree among all input dimensions\n    if self.has_dru:\n        impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n    else:\n        impl_n_layers = n_layers\n    log.info(f\"Number of implicit layers: {impl_n_layers}.\")\n\n    # --- Ansatz ---\n    # only weak check for str. We trust the user to provide sth useful\n    if isinstance(circuit_type, str):\n        self.pqc: Callable[[Optional[jnp.ndarray], int], int] = getattr(\n            Ansaetze, circuit_type or \"No_Ansatz\"\n        )()\n    else:\n        self.pqc = circuit_type()\n    log.info(f\"Using Ansatz {circuit_type}.\")\n\n    # calculate the shape of the parameter vector here, we will re-use this in init.\n    params_per_layer = self.pqc.n_params_per_layer(self.n_qubits)\n    self._params_shape: Tuple[int, int] = (impl_n_layers, params_per_layer)\n    log.info(f\"Parameters per layer: {params_per_layer}\")\n\n    pulse_params_per_layer = self.pqc.n_pulse_params_per_layer(self.n_qubits)\n    self._pulse_params_shape: Tuple[int, int] = (\n        impl_n_layers,\n        pulse_params_per_layer,\n    )\n\n    # intialize to None as we can't know this yet\n    self._batch_shape = None\n\n    # this will also be re-used in the init method,\n    # however, only if nothing is provided\n    self._inialization_strategy = initialization\n    self._initialization_domain = initialization_domain\n\n    # ..here! where we only require a JAX random key\n    self.random_key = self.initialize_params(random.key(random_seed))\n\n    # Initializing pulse params\n    self.pulse_params: jnp.ndarray = jnp.ones((*self._pulse_params_shape, 1))\n\n    log.info(f\"Initialized pulse parameters with shape {self.pulse_params.shape}.\")\n\n    # Initialize two circuits, one with the default device and\n    # one with the mixed device\n    # which allows us to later route depending on the state_vector flag\n    if self.n_qubits &lt; self.lightning_threshold:\n        device = \"default.qubit\"\n    else:\n        device = \"lightning.qubit\"\n        self.use_multithreading = False\n    self.circuit: qml.QNode = qml.QNode(\n        self._circuit,\n        qml.device(\n            device,\n            shots=self.shots,\n            wires=self.n_qubits,\n        ),\n        interface=\"jax-jit\",\n        diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n    )\n\n    self.circuit_mixed: qml.QNode = qml.QNode(\n        self._circuit,\n        qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n        interface=\"jax-jit\",\n        diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.__repr__","title":"<code>__repr__()</code>","text":"<p>Return text representation of the quantum circuit.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return text representation of the quantum circuit.\"\"\"\n    return self.draw(figure=\"text\")\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation of the quantum circuit.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of the quantum circuit.\"\"\"\n    return self.draw(figure=\"text\")\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.draw","title":"<code>draw(inputs=None, figure='text', *args, **kwargs)</code>","text":"<p>Visualize the quantum circuit.</p> <p>Generates a visual representation of the circuit using the specified rendering method.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>Input data for the circuit. If None, default zero inputs are used. Defaults to None.</p> <code>None</code> <code>figure</code> <code>str</code> <p>Visualization format. Options: - \"text\": ASCII text representation - \"mpl\": Matplotlib figure - \"tikz\": TikZ/LaTeX code for publication-quality figures Defaults to \"text\".</p> <code>'text'</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments passed to the visualization backend.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the visualization backend. May include pulse_params, gate_mode, enc_params, or noise_params.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[str, Any]</code> <p>Union[str, Any]: Visualization output: - \"text\": String with ASCII circuit diagram - \"mpl\": Matplotlib Figure and Axes objects - \"tikz\": TikZ code string</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If figure is not one of \"text\", \"mpl\", or \"tikz\".</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def draw(\n    self,\n    inputs: Optional[jnp.ndarray] = None,\n    figure: str = \"text\",\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Union[str, Any]:\n    \"\"\"\n    Visualize the quantum circuit.\n\n    Generates a visual representation of the circuit using the specified\n    rendering method.\n\n    Args:\n        inputs (Optional[jnp.ndarray]): Input data for the circuit. If None,\n            default zero inputs are used. Defaults to None.\n        figure (str): Visualization format. Options:\n            - \"text\": ASCII text representation\n            - \"mpl\": Matplotlib figure\n            - \"tikz\": TikZ/LaTeX code for publication-quality figures\n            Defaults to \"text\".\n        *args (Any): Additional positional arguments passed to the\n            visualization backend.\n        **kwargs (Any): Additional keyword arguments passed to the\n            visualization backend. May include pulse_params, gate_mode,\n            enc_params, or noise_params.\n\n    Returns:\n        Union[str, Any]: Visualization output:\n            - \"text\": String with ASCII circuit diagram\n            - \"mpl\": Matplotlib Figure and Axes objects\n            - \"tikz\": TikZ code string\n\n    Raises:\n        AssertionError: If figure is not one of \"text\", \"mpl\", or \"tikz\".\n    \"\"\"\n\n    if not isinstance(self.circuit, qml.QNode):\n        # TODO: throws strange argument error if not catched\n        return \"\"\n\n    assert figure in [\n        \"text\",\n        \"mpl\",\n        \"tikz\",\n    ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n    inputs = self._inputs_validation(inputs)\n\n    if figure == \"mpl\":\n        return qml.draw_mpl(self.circuit)(\n            params=self.params,\n            inputs=inputs,\n            *args,\n            **kwargs,\n        )\n    elif figure == \"tikz\":\n        return QuanTikz.build(\n            self.circuit,\n            params=self.params,\n            inputs=inputs,\n            *args,\n            **kwargs,\n        )\n    else:\n        return qml.draw(self.circuit)(params=self.params, inputs=inputs)\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.initialize_params","title":"<code>initialize_params(random_key=None, repeat=1, initialization=None, initialization_domain=None)</code>","text":"<p>Initialize the variational parameters of the model.</p> <p>Parameters:</p> Name Type Description Default <code>random_key</code> <code>Optional[PRNGKey]</code> <p>JAX random key for initialization. If None, uses the model's internal random key.</p> <code>None</code> <code>repeat</code> <code>int</code> <p>Number of parameter sets to create (batch dimension). Defaults to 1.</p> <code>1</code> <code>initialization</code> <code>Optional[str]</code> <p>Strategy for parameter initialization. Options: \"random\", \"zeros\", \"pi\", \"zero-controlled\", \"pi-controlled\". If None, uses the strategy specified in the constructor.</p> <code>None</code> <code>initialization_domain</code> <code>Optional[List[float]]</code> <p>Domain [min, max] for random initialization. If None, uses the domain from constructor.</p> <code>None</code> <p>Returns:</p> Type Description <code>PRNGKey</code> <p>random.PRNGKey: Updated random key after initialization.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an invalid initialization method is specified.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def initialize_params(\n    self,\n    random_key: Optional[random.PRNGKey] = None,\n    repeat: int = 1,\n    initialization: Optional[str] = None,\n    initialization_domain: Optional[List[float]] = None,\n) -&gt; random.PRNGKey:\n    \"\"\"\n    Initialize the variational parameters of the model.\n\n    Args:\n        random_key (Optional[random.PRNGKey]): JAX random key for initialization.\n            If None, uses the model's internal random key.\n        repeat (int): Number of parameter sets to create (batch dimension).\n            Defaults to 1.\n        initialization (Optional[str]): Strategy for parameter initialization.\n            Options: \"random\", \"zeros\", \"pi\", \"zero-controlled\", \"pi-controlled\".\n            If None, uses the strategy specified in the constructor.\n        initialization_domain (Optional[List[float]]): Domain [min, max] for\n            random initialization. If None, uses the domain from constructor.\n\n    Returns:\n        random.PRNGKey: Updated random key after initialization.\n\n    Raises:\n        Exception: If an invalid initialization method is specified.\n    \"\"\"\n    # Initializing params\n    params_shape = (*self._params_shape, repeat)\n\n    # use existing strategy if not specified\n    initialization = initialization or self._inialization_strategy\n    initialization_domain = initialization_domain or self._initialization_domain\n\n    random_key, sub_key = safe_random_split(\n        random_key if random_key is not None else self.random_key\n    )\n\n    def set_control_params(params: jnp.ndarray, value: float) -&gt; jnp.ndarray:\n        indices = self.pqc.get_control_indices(self.n_qubits)\n        if indices is None:\n            warnings.warn(\n                f\"Specified {initialization} but circuit\\\n                does not contain controlled rotation gates.\\\n                Parameters are intialized randomly.\",\n                UserWarning,\n            )\n        else:\n            np_params = np.array(params)\n            np_params[:, indices[0] : indices[1] : indices[2]] = (\n                np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                * value\n            )\n            params = jnp.array(np_params)\n        return params\n\n    if initialization == \"random\":\n        self.params: jnp.ndarray = random.uniform(\n            sub_key,\n            params_shape,\n            minval=initialization_domain[0],\n            maxval=initialization_domain[1],\n        )\n    elif initialization == \"zeros\":\n        self.params: jnp.ndarray = jnp.zeros(params_shape)\n    elif initialization == \"pi\":\n        self.params: jnp.ndarray = jnp.ones(params_shape) * jnp.pi\n    elif initialization == \"zero-controlled\":\n        self.params: jnp.ndarray = random.uniform(\n            sub_key,\n            params_shape,\n            minval=initialization_domain[0],\n            maxval=initialization_domain[1],\n        )\n        self.params = set_control_params(self.params, 0)\n    elif initialization == \"pi-controlled\":\n        self.params: jnp.ndarray = random.uniform(\n            sub_key,\n            params_shape,\n            minval=initialization_domain[0],\n            maxval=initialization_domain[1],\n        )\n        self.params = set_control_params(self.params, jnp.pi)\n    else:\n        raise Exception(\"Invalid initialization method\")\n\n    log.info(\n        f\"Initialized parameters with shape {self.params.shape}\\\n        using strategy {initialization}.\"\n    )\n\n    return random_key\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.transform_input","title":"<code>transform_input(inputs, enc_params)</code>","text":"<p>Transform input data by scaling with encoding parameters.</p> <p>Implements the input transformation as described in arXiv:2309.03279v2, where inputs are linearly scaled by encoding parameters before being used in the quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ndarray</code> <p>Input data point of shape (n_input_feat,) or (batch_size, n_input_feat).</p> required <code>enc_params</code> <code>ndarray</code> <p>Encoding weight scalar or vector used to scale the input.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Transformed input, element-wise product of inputs and enc_params.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def transform_input(\n    self, inputs: jnp.ndarray, enc_params: jnp.ndarray\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Transform input data by scaling with encoding parameters.\n\n    Implements the input transformation as described in arXiv:2309.03279v2,\n    where inputs are linearly scaled by encoding parameters before being\n    used in the quantum circuit.\n\n    Args:\n        inputs (jnp.ndarray): Input data point of shape (n_input_feat,) or\n            (batch_size, n_input_feat).\n        enc_params (jnp.ndarray): Encoding weight scalar or vector used to\n            scale the input.\n\n    Returns:\n        jnp.ndarray: Transformed input, element-wise product of inputs\n            and enc_params.\n    \"\"\"\n    return inputs * enc_params\n</code></pre>"},{"location":"references/#entanglement","title":"Entanglement","text":"<pre><code>from qml_essentials.entanglement import Entanglement\n</code></pre> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>class Entanglement:\n    @staticmethod\n    def meyer_wallach(\n        model: Model,\n        n_samples: Optional[int | None],\n        seed: Optional[int],\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the entangling capacity of a given quantum circuit\n        using Meyer-Wallach measure.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (Optional[int]): Number of samples per qubit.\n                If None or &lt; 0, the current parameters of the model are used.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        if \"noise_params\" in kwargs:\n            log.warning(\n                \"Meyer-Wallach measure not suitable for noisy circuits.\\\n                    Consider 'relative_entropy' instead.\"\n            )\n\n        if scale:\n            n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n        random_key = jax.random.key(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            random_key = model.initialize_params(random_key, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        # explicitly set execution type because everything else won't work\n        rhos = model(execution_type=\"density\", **kwargs).reshape(\n            -1, 2**model.n_qubits, 2**model.n_qubits\n        )\n\n        ent = Entanglement._compute_meyer_wallach_meas(\n            rhos, model.n_qubits, model.use_multithreading\n        )\n\n        log.debug(f\"Variance of measure: {ent.var()}\")\n\n        return ent.mean()\n\n    @staticmethod\n    def _compute_meyer_wallach_meas(\n        rhos: jnp.ndarray, n_qubits: int, use_multithreading: bool = False\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Computes the Meyer-Wallach entangling capability measure for a given\n        set of density matrices.\n\n        Args:\n            rhos (jnp.ndarray): Density matrices of the sample quantum states.\n                The shape is (B_s, 2^n, 2^n), where B_s is the number of samples\n                (batch) and n the number of qubits\n            n_qubits (int): The number of qubits\n            use_multithreading (bool): Whether to use JAX vectorisation.\n\n        Returns:\n            jnp.ndarray: Entangling capability for each sample, array with\n                shape (B_s,)\n        \"\"\"\n        qb = list(range(n_qubits))\n\n        def _f(rhos):\n            entropy = 0\n            for j in range(n_qubits):\n                # Formula 6 in https://doi.org/10.48550/arXiv.quant-ph/0305094\n                density = qml.math.partial_trace(rhos, qb[:j] + qb[j + 1 :])\n                # only real values, because imaginary part will be separate\n                # in all following calculations anyway\n                # entropy should be 1/2 &lt;= entropy &lt;= 1\n                entropy += jnp.trace((density @ density).real, axis1=-2, axis2=-1)\n\n            # inverse averaged entropy and scale to [0, 1]\n            return 2 * (1 - entropy / n_qubits)\n\n        if use_multithreading:\n            return jax.vmap(_f)(rhos)\n        else:\n            return _f(rhos)\n\n    @staticmethod\n    def bell_measurements(\n        model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n    ) -&gt; float:\n        \"\"\"\n        Compute the Bell measurement for a given model.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): The number of samples to compute the measure for.\n            seed (int): The seed for the random number generator.\n            scale (bool): Whether to scale the number of samples\n                according to the number of qubits.\n            **kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: The Bell measurement value.\n        \"\"\"\n        if \"noise_params\" in kwargs:\n            log.warning(\n                \"Bell Measurements not suitable for noisy circuits.\\\n                    Consider 'relative_entropy' instead.\"\n            )\n\n        if scale:\n            n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n        def _circuit(\n            params: jnp.ndarray, inputs: jnp.ndarray, **kwargs\n        ) -&gt; List[jnp.ndarray]:\n            \"\"\"\n            Compute the Bell measurement circuit.\n\n            Args:\n                params (jnp.ndarray): The model parameters.\n                inputs (jnp.ndarray): The input to the model.\n                pulse_params (jnp.ndarray): The model pulse parameters.\n                enc_params (Optional[jnp.ndarray]): The frequency encoding parameters.\n\n            Returns:\n                List[jnp.ndarray]: The probabilities of the Bell measurement.\n            \"\"\"\n            model._variational(params, inputs, **kwargs)\n\n            qml.map_wires(\n                model._variational,\n                {i: i + model.n_qubits for i in range(model.n_qubits)},\n            )(params, inputs)\n\n            for q in range(model.n_qubits):\n                qml.CNOT(wires=[q, q + model.n_qubits])\n                qml.H(q)\n\n            # look at the auxiliary qubits\n            return model._observable()\n\n        prev_output_qubit = model.output_qubit\n        model.output_qubit = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n        model.circuit = qml.QNode(\n            _circuit,\n            qml.device(\n                \"default.qubit\",\n                shots=model.shots,\n                wires=model.n_qubits * 2,\n            ),\n        )\n\n        random_key = jax.random.key(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            random_key = model.initialize_params(random_key, repeat=n_samples)\n            params = model.params\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n                params = model.params\n\n        n_samples = params.shape[-1]\n        measure = jnp.zeros(n_samples)\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        exp = model(params=params, execution_type=\"probs\", **kwargs)\n        exp = 1 - 2 * exp[..., -1]\n\n        if not jnp.isclose(jnp.sum(exp.imag), 0, atol=1e-6):\n            log.warning(\"Imaginary part of probabilities detected\")\n            exp = jnp.abs(exp)\n\n        measure = 2 * (1 - exp.mean(axis=0))\n        entangling_capability = min(max(measure.mean(), 0.0), 1.0)\n        log.debug(f\"Variance of measure: {measure.var()}\")\n\n        # restore state\n        model.output_qubit = prev_output_qubit\n        return float(entangling_capability)\n\n    @staticmethod\n    def relative_entropy(\n        model: Model,\n        n_samples: int,\n        n_sigmas: int,\n        seed: Optional[int],\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the relative entropy of entanglement of a given quantum\n        circuit. This measure is also applicable to mixed state, albeit it\n        might me not fully accurate in this simplified case.\n\n        As the relative entropy is generally defined as the smallest relative\n        entropy from the state in question to the set of separable states.\n        However, as computing the nearest separable state is NP-hard, we select\n        n_sigmas of random separable states to compute the distance to, which\n        is not necessarily the nearest. Thus, this measure of entanglement\n        presents an upper limit of entanglement.\n\n        As the relative entropy is not necessarily between zero and one, this\n        function also normalises by the relative entroy to the GHZ state.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): Number of samples per qubit.\n                If &lt;= 0, the current parameters of the model are used.\n            n_sigmas (int): Number of random separable pure states to compare against.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        dim = jnp.power(2, model.n_qubits)\n        if scale:\n            n_samples = dim * n_samples\n            n_sigmas = dim * n_sigmas\n\n        random_key = jax.random.key(seed)\n\n        # Random separable states\n        log_sigmas = sample_random_separable_states(\n            model.n_qubits, n_samples=n_sigmas, random_key=random_key, take_log=True\n        )\n\n        random_key, _ = jax.random.split(random_key)\n\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            model.initialize_params(random_key, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                model.params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n        rhos, log_rhos = Entanglement._compute_log_density(model, **kwargs)\n\n        rel_entropies = jnp.zeros((n_sigmas, model.params.shape[-1]))\n\n        for i, log_sigma in enumerate(log_sigmas):\n            rel_entropies = rel_entropies.at[i].set(\n                Entanglement._compute_rel_entropies(\n                    rhos, log_rhos, log_sigma, model.use_multithreading\n                )\n            )\n\n        # Entropy of GHZ states should be maximal\n        ghz_model = Model(model.n_qubits, 1, \"GHZ\", data_reupload=False)\n        rho_ghz, log_rho_ghz = Entanglement._compute_log_density(ghz_model, **kwargs)\n        ghz_entropies = Entanglement._compute_rel_entropies(\n            rho_ghz, log_rho_ghz, log_sigmas, use_multithreading=False\n        )\n\n        normalised_entropies = rel_entropies / ghz_entropies\n\n        # Average all iterated states\n        entangling_capability = normalised_entropies.T.min(axis=1)\n        log.debug(f\"Variance of measure: {entangling_capability.var()}\")\n\n        return entangling_capability.mean()\n\n    @staticmethod\n    def _compute_log_density(model: Model, **kwargs) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:\n        \"\"\"\n        Obtains the density matrix of a model and computes its logarithm.\n\n        Args:\n            model (Model): The model for which to compute the density matrix.\n\n        Returns:\n            Tuple[jnp.ndarray, jnp.ndarray]:\n                - jnp.ndarray: density matrix.\n                - jnp.ndarray: logarithm of the density matrix.\n        \"\"\"\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        # explicitly set execution type because everything else won't work\n        rho = model(execution_type=\"density\", **kwargs)\n        rho = rho.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n        log_rho = logm_v(rho) / jnp.log(2)\n        return rho, log_rho\n\n    @staticmethod\n    def _compute_rel_entropies(\n        rhos: jnp.ndarray,\n        log_rhos: jnp.ndarray,\n        log_sigmas: jnp.ndarray,\n        use_multithreading: bool,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Compute the relative entropy for a given model.\n\n        Args:\n            rhos (jnp.ndarray): Density matrix result of the circuit, has shape\n                (R, 2^n, 2^n), with the batch size R and number of qubits n\n            log_rhos (jnp.ndarray): Corresponding logarithm of the density\n                matrix, has shape (R, 2^n, 2^n).\n            log_sigmas (jnp.ndarray): Density matrix of next separable state,\n                has shape (2^n, 2^n) if it's a single sigma or (S, 2^n, 2^n),\n                with the batch size S (number of sigmas).\n\n        Returns:\n            jnp.ndarray: Relative Entropy for each sample\n        \"\"\"\n        n_rhos = rhos.shape[0]\n        if len(log_sigmas.shape) == 3:\n            n_sigmas = log_sigmas.shape[0]\n            rhos = jnp.tile(rhos, (n_sigmas, 1, 1))\n            log_rhos = jnp.tile(log_rhos, (n_sigmas, 1, 1))\n            einsum_subscript = \"ij,jk-&gt;ik\" if use_multithreading else \"sij,sjk-&gt;sik\"\n        else:\n            n_sigmas = 1\n            log_sigmas = log_sigmas[jnp.newaxis, ...].repeat(n_rhos, axis=0)\n\n        einsum_subscript = \"ij,jk-&gt;ik\" if use_multithreading else \"sij,sjk-&gt;sik\"\n\n        def _f(rhos, log_rhos, log_sigmas):\n            prod = jnp.einsum(einsum_subscript, rhos, log_rhos - log_sigmas)\n            rel_entropies = jnp.abs(jnp.trace(prod, axis1=-2, axis2=-1))\n            return rel_entropies\n\n        if use_multithreading:\n            rel_entropies = jax.vmap(_f, in_axes=(0, 0, 0))(rhos, log_rhos, log_sigmas)\n        else:\n            rel_entropies = _f(rhos, log_rhos, log_sigmas)\n\n        if n_sigmas &gt; 1:\n            rel_entropies = rel_entropies.reshape(n_sigmas, n_rhos)\n        return rel_entropies\n\n    @staticmethod\n    def entanglement_of_formation(\n        model: Model,\n        n_samples: int,\n        seed: Optional[int],\n        scale: bool = False,\n        always_decompose: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        This function implements the entanglement of formation for mixed\n        quantum systems.\n        In that a mixed state gets decomposed into pure states with respective\n        probabilities using the eigendecomposition of the density matrix.\n        Then, the Meyer-Wallach measure is computed for each pure state,\n        weighted by the eigenvalue.\n        See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163\n\n        Note that the decomposition is *not unique*! Therefore, this measure\n        presents the entanglement for *some* decomposition into pure states,\n        not necessarily the one that is anticipated when applying the Kraus\n        channels.\n        If a pure state is provided, this results in the same value as the\n        Entanglement.meyer_wallach function if `always_decompose` flag is not set.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): Number of samples per qubit.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            always_decompose (bool): Whether to explicitly compute the\n                entantlement of formation for the eigendecomposition of a pure\n                state.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n\n        if scale:\n            n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n        random_key = jax.random.key(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            model.initialize_params(random_key, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                model.params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        rhos = model(execution_type=\"density\", **kwargs)\n        rhos = rhos.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n        ent = Entanglement._compute_entanglement_of_formation(\n            rhos, model.n_qubits, always_decompose, model.use_multithreading\n        )\n        return ent.mean()\n\n    @staticmethod\n    def _compute_entanglement_of_formation(\n        rhos: jnp.ndarray,\n        n_qubits: int,\n        always_decompose: bool,\n        use_multithreading: bool,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Computes the entanglement of formation for a given batch of density\n        matrices.\n\n        Args:\n            rho (jnp.ndarray): The density matrices, has shape (B_s, 2^n, 2^n),\n                where B_s is the batch size and n the number of qubits.\n            n_qubits (int): Number of qubits\n            always_decompose (bool): Whether to explicitly compute the\n                entantlement of formation for the eigendecomposition of a pure\n                state.\n            use_multithreading (bool): Whether to use JAX vectorisation.\n\n        Returns:\n            jnp.ndarray: Entanglement for the provided density matrices.\n        \"\"\"\n        eigenvalues, eigenvectors = jnp.linalg.eigh(rhos)\n        if not always_decompose and jnp.isclose(eigenvalues, 1.0).any(axis=-1).all():\n            return Entanglement._compute_meyer_wallach_meas(\n                rhos, n_qubits, use_multithreading\n            )\n\n        rhos = np.einsum(\"sij,sik-&gt;sijk\", eigenvectors, eigenvectors.conjugate())\n        measures = Entanglement._compute_meyer_wallach_meas(\n            rhos.reshape(-1, 2**n_qubits, 2**n_qubits), n_qubits, use_multithreading\n        )\n        ent = np.einsum(\"si,si-&gt;s\", measures.reshape(-1, 2**n_qubits), eigenvalues)\n        return ent\n\n    @staticmethod\n    def concentratable_entanglement(\n        model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n    ) -&gt; float:\n        \"\"\"\n        Computes the concentratable entanglement of a given model.\n\n        This method utilizes the Concentratable Entanglement measure from\n        https://arxiv.org/abs/2104.06923.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): The number of samples to compute the measure for.\n            seed (int): The seed for the random number generator.\n            scale (bool): Whether to scale the number of samples according to\n                the number of qubits.\n            **kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capability of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        n = model.n_qubits\n        N = 2**n\n\n        if scale:\n            n_samples = N * n_samples\n\n        dev = qml.device(\n            \"default.mixed\",\n            shots=model.shots,\n            wires=n * 3,\n        )\n\n        @qml.qnode(device=dev)\n        def _swap_test(\n            params: jnp.ndarray, inputs: jnp.ndarray, **kwargs\n        ) -&gt; jnp.ndarray:\n            \"\"\"\n            Constructs a circuit to compute the concentratable entanglement using the\n            swap test by creating two copies of a state given by a density matrix rho\n            and mapping the output wires accordingly.\n\n            Args:\n                rho (jnp.ndarray): the density matrix of the state on which the swap\n                    test is performed.\n\n            Returns:\n                List[jnp.ndarray]: Probabilities obtained from the swap test circuit.\n            \"\"\"\n\n            qml.map_wires(model._variational, wire_map={o: o + n for o in range(n)})(\n                params, inputs, **kwargs\n            )\n            qml.map_wires(\n                model._variational, wire_map={o: o + 2 * n for o in range(n)}\n            )(params, inputs, **kwargs)\n\n            # Perform swap test\n            for i in range(n):\n                qml.H(i)\n\n            for i in range(n):\n                qml.CSWAP([i, i + n, i + 2 * n])\n\n            for i in range(n):\n                qml.H(i)\n\n            return qml.probs(wires=[i for i in range(n)])\n\n        random_key = jax.random.key(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            model.initialize_params(random_key, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                model.params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n        def _f(params):\n            probs = _swap_test(params, model._inputs_validation(None), **kwargs)\n            ent = 1 - probs[..., 0]\n            return ent\n\n        if model.use_multithreading:\n            ent = jax.vmap(_f, in_axes=2)(model.params)\n        else:\n            ent = _f(model.params)\n\n        # Catch floating point errors\n        log.debug(f\"Variance of measure: {ent.var()}\")\n\n        return ent.mean()\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.bell_measurements","title":"<code>bell_measurements(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Compute the Bell measurement for a given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>The number of samples to compute the measure for.</p> required <code>seed</code> <code>int</code> <p>The seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples according to the number of qubits.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Bell measurement value.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef bell_measurements(\n    model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n) -&gt; float:\n    \"\"\"\n    Compute the Bell measurement for a given model.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): The number of samples to compute the measure for.\n        seed (int): The seed for the random number generator.\n        scale (bool): Whether to scale the number of samples\n            according to the number of qubits.\n        **kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: The Bell measurement value.\n    \"\"\"\n    if \"noise_params\" in kwargs:\n        log.warning(\n            \"Bell Measurements not suitable for noisy circuits.\\\n                Consider 'relative_entropy' instead.\"\n        )\n\n    if scale:\n        n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n    def _circuit(\n        params: jnp.ndarray, inputs: jnp.ndarray, **kwargs\n    ) -&gt; List[jnp.ndarray]:\n        \"\"\"\n        Compute the Bell measurement circuit.\n\n        Args:\n            params (jnp.ndarray): The model parameters.\n            inputs (jnp.ndarray): The input to the model.\n            pulse_params (jnp.ndarray): The model pulse parameters.\n            enc_params (Optional[jnp.ndarray]): The frequency encoding parameters.\n\n        Returns:\n            List[jnp.ndarray]: The probabilities of the Bell measurement.\n        \"\"\"\n        model._variational(params, inputs, **kwargs)\n\n        qml.map_wires(\n            model._variational,\n            {i: i + model.n_qubits for i in range(model.n_qubits)},\n        )(params, inputs)\n\n        for q in range(model.n_qubits):\n            qml.CNOT(wires=[q, q + model.n_qubits])\n            qml.H(q)\n\n        # look at the auxiliary qubits\n        return model._observable()\n\n    prev_output_qubit = model.output_qubit\n    model.output_qubit = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n    model.circuit = qml.QNode(\n        _circuit,\n        qml.device(\n            \"default.qubit\",\n            shots=model.shots,\n            wires=model.n_qubits * 2,\n        ),\n    )\n\n    random_key = jax.random.key(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        random_key = model.initialize_params(random_key, repeat=n_samples)\n        params = model.params\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n            params = model.params\n\n    n_samples = params.shape[-1]\n    measure = jnp.zeros(n_samples)\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    exp = model(params=params, execution_type=\"probs\", **kwargs)\n    exp = 1 - 2 * exp[..., -1]\n\n    if not jnp.isclose(jnp.sum(exp.imag), 0, atol=1e-6):\n        log.warning(\"Imaginary part of probabilities detected\")\n        exp = jnp.abs(exp)\n\n    measure = 2 * (1 - exp.mean(axis=0))\n    entangling_capability = min(max(measure.mean(), 0.0), 1.0)\n    log.debug(f\"Variance of measure: {measure.var()}\")\n\n    # restore state\n    model.output_qubit = prev_output_qubit\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.concentratable_entanglement","title":"<code>concentratable_entanglement(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Computes the concentratable entanglement of a given model.</p> <p>This method utilizes the Concentratable Entanglement measure from https://arxiv.org/abs/2104.06923.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>The number of samples to compute the measure for.</p> required <code>seed</code> <code>int</code> <p>The seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples according to the number of qubits.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capability of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef concentratable_entanglement(\n    model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n) -&gt; float:\n    \"\"\"\n    Computes the concentratable entanglement of a given model.\n\n    This method utilizes the Concentratable Entanglement measure from\n    https://arxiv.org/abs/2104.06923.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): The number of samples to compute the measure for.\n        seed (int): The seed for the random number generator.\n        scale (bool): Whether to scale the number of samples according to\n            the number of qubits.\n        **kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capability of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    n = model.n_qubits\n    N = 2**n\n\n    if scale:\n        n_samples = N * n_samples\n\n    dev = qml.device(\n        \"default.mixed\",\n        shots=model.shots,\n        wires=n * 3,\n    )\n\n    @qml.qnode(device=dev)\n    def _swap_test(\n        params: jnp.ndarray, inputs: jnp.ndarray, **kwargs\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Constructs a circuit to compute the concentratable entanglement using the\n        swap test by creating two copies of a state given by a density matrix rho\n        and mapping the output wires accordingly.\n\n        Args:\n            rho (jnp.ndarray): the density matrix of the state on which the swap\n                test is performed.\n\n        Returns:\n            List[jnp.ndarray]: Probabilities obtained from the swap test circuit.\n        \"\"\"\n\n        qml.map_wires(model._variational, wire_map={o: o + n for o in range(n)})(\n            params, inputs, **kwargs\n        )\n        qml.map_wires(\n            model._variational, wire_map={o: o + 2 * n for o in range(n)}\n        )(params, inputs, **kwargs)\n\n        # Perform swap test\n        for i in range(n):\n            qml.H(i)\n\n        for i in range(n):\n            qml.CSWAP([i, i + n, i + 2 * n])\n\n        for i in range(n):\n            qml.H(i)\n\n        return qml.probs(wires=[i for i in range(n)])\n\n    random_key = jax.random.key(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        model.initialize_params(random_key, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            model.params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n    def _f(params):\n        probs = _swap_test(params, model._inputs_validation(None), **kwargs)\n        ent = 1 - probs[..., 0]\n        return ent\n\n    if model.use_multithreading:\n        ent = jax.vmap(_f, in_axes=2)(model.params)\n    else:\n        ent = _f(model.params)\n\n    # Catch floating point errors\n    log.debug(f\"Variance of measure: {ent.var()}\")\n\n    return ent.mean()\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.entanglement_of_formation","title":"<code>entanglement_of_formation(model, n_samples, seed, scale=False, always_decompose=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>This function implements the entanglement of formation for mixed quantum systems. In that a mixed state gets decomposed into pure states with respective probabilities using the eigendecomposition of the density matrix. Then, the Meyer-Wallach measure is computed for each pure state, weighted by the eigenvalue. See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163</p> <p>Note that the decomposition is not unique! Therefore, this measure presents the entanglement for some decomposition into pure states, not necessarily the one that is anticipated when applying the Kraus channels. If a pure state is provided, this results in the same value as the Entanglement.meyer_wallach function if <code>always_decompose</code> flag is not set.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>Number of samples per qubit.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>always_decompose</code> <code>bool</code> <p>Whether to explicitly compute the entantlement of formation for the eigendecomposition of a pure state.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef entanglement_of_formation(\n    model: Model,\n    n_samples: int,\n    seed: Optional[int],\n    scale: bool = False,\n    always_decompose: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    This function implements the entanglement of formation for mixed\n    quantum systems.\n    In that a mixed state gets decomposed into pure states with respective\n    probabilities using the eigendecomposition of the density matrix.\n    Then, the Meyer-Wallach measure is computed for each pure state,\n    weighted by the eigenvalue.\n    See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163\n\n    Note that the decomposition is *not unique*! Therefore, this measure\n    presents the entanglement for *some* decomposition into pure states,\n    not necessarily the one that is anticipated when applying the Kraus\n    channels.\n    If a pure state is provided, this results in the same value as the\n    Entanglement.meyer_wallach function if `always_decompose` flag is not set.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): Number of samples per qubit.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        always_decompose (bool): Whether to explicitly compute the\n            entantlement of formation for the eigendecomposition of a pure\n            state.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n\n    if scale:\n        n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n    random_key = jax.random.key(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        model.initialize_params(random_key, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            model.params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    rhos = model(execution_type=\"density\", **kwargs)\n    rhos = rhos.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n    ent = Entanglement._compute_entanglement_of_formation(\n        rhos, model.n_qubits, always_decompose, model.use_multithreading\n    )\n    return ent.mean()\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.meyer_wallach","title":"<code>meyer_wallach(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Calculates the entangling capacity of a given quantum circuit using Meyer-Wallach measure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>Optional[int]</code> <p>Number of samples per qubit. If None or &lt; 0, the current parameters of the model are used.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef meyer_wallach(\n    model: Model,\n    n_samples: Optional[int | None],\n    seed: Optional[int],\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Calculates the entangling capacity of a given quantum circuit\n    using Meyer-Wallach measure.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (Optional[int]): Number of samples per qubit.\n            If None or &lt; 0, the current parameters of the model are used.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    if \"noise_params\" in kwargs:\n        log.warning(\n            \"Meyer-Wallach measure not suitable for noisy circuits.\\\n                Consider 'relative_entropy' instead.\"\n        )\n\n    if scale:\n        n_samples = jnp.power(2, model.n_qubits) * n_samples\n\n    random_key = jax.random.key(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        random_key = model.initialize_params(random_key, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    # explicitly set execution type because everything else won't work\n    rhos = model(execution_type=\"density\", **kwargs).reshape(\n        -1, 2**model.n_qubits, 2**model.n_qubits\n    )\n\n    ent = Entanglement._compute_meyer_wallach_meas(\n        rhos, model.n_qubits, model.use_multithreading\n    )\n\n    log.debug(f\"Variance of measure: {ent.var()}\")\n\n    return ent.mean()\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.relative_entropy","title":"<code>relative_entropy(model, n_samples, n_sigmas, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Calculates the relative entropy of entanglement of a given quantum circuit. This measure is also applicable to mixed state, albeit it might me not fully accurate in this simplified case.</p> <p>As the relative entropy is generally defined as the smallest relative entropy from the state in question to the set of separable states. However, as computing the nearest separable state is NP-hard, we select n_sigmas of random separable states to compute the distance to, which is not necessarily the nearest. Thus, this measure of entanglement presents an upper limit of entanglement.</p> <p>As the relative entropy is not necessarily between zero and one, this function also normalises by the relative entroy to the GHZ state.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>Number of samples per qubit. If &lt;= 0, the current parameters of the model are used.</p> required <code>n_sigmas</code> <code>int</code> <p>Number of random separable pure states to compare against.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef relative_entropy(\n    model: Model,\n    n_samples: int,\n    n_sigmas: int,\n    seed: Optional[int],\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Calculates the relative entropy of entanglement of a given quantum\n    circuit. This measure is also applicable to mixed state, albeit it\n    might me not fully accurate in this simplified case.\n\n    As the relative entropy is generally defined as the smallest relative\n    entropy from the state in question to the set of separable states.\n    However, as computing the nearest separable state is NP-hard, we select\n    n_sigmas of random separable states to compute the distance to, which\n    is not necessarily the nearest. Thus, this measure of entanglement\n    presents an upper limit of entanglement.\n\n    As the relative entropy is not necessarily between zero and one, this\n    function also normalises by the relative entroy to the GHZ state.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): Number of samples per qubit.\n            If &lt;= 0, the current parameters of the model are used.\n        n_sigmas (int): Number of random separable pure states to compare against.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    dim = jnp.power(2, model.n_qubits)\n    if scale:\n        n_samples = dim * n_samples\n        n_sigmas = dim * n_sigmas\n\n    random_key = jax.random.key(seed)\n\n    # Random separable states\n    log_sigmas = sample_random_separable_states(\n        model.n_qubits, n_samples=n_sigmas, random_key=random_key, take_log=True\n    )\n\n    random_key, _ = jax.random.split(random_key)\n\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        model.initialize_params(random_key, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            model.params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n    rhos, log_rhos = Entanglement._compute_log_density(model, **kwargs)\n\n    rel_entropies = jnp.zeros((n_sigmas, model.params.shape[-1]))\n\n    for i, log_sigma in enumerate(log_sigmas):\n        rel_entropies = rel_entropies.at[i].set(\n            Entanglement._compute_rel_entropies(\n                rhos, log_rhos, log_sigma, model.use_multithreading\n            )\n        )\n\n    # Entropy of GHZ states should be maximal\n    ghz_model = Model(model.n_qubits, 1, \"GHZ\", data_reupload=False)\n    rho_ghz, log_rho_ghz = Entanglement._compute_log_density(ghz_model, **kwargs)\n    ghz_entropies = Entanglement._compute_rel_entropies(\n        rho_ghz, log_rho_ghz, log_sigmas, use_multithreading=False\n    )\n\n    normalised_entropies = rel_entropies / ghz_entropies\n\n    # Average all iterated states\n    entangling_capability = normalised_entropies.T.min(axis=1)\n    log.debug(f\"Variance of measure: {entangling_capability.var()}\")\n\n    return entangling_capability.mean()\n</code></pre>"},{"location":"references/#expressibility","title":"Expressibility","text":"<pre><code>from qml_essentials.expressibility import Expressibility\n</code></pre> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>class Expressibility:\n    @staticmethod\n    def _sample_state_fidelities(\n        model: Model,\n        x_samples: jnp.ndarray,\n        n_samples: int,\n        seed: int,\n        kwargs: Any,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Compute the fidelities for each pair of input samples and parameter sets.\n\n        Args:\n            model (Callable): Function that models the quantum circuit.\n            x_samples (jnp.ndarray): Array of shape (n_input_samples, n_features)\n                containing the input samples.\n            n_samples (int): Number of parameter sets to generate.\n            seed (int): Random number generator seed.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            jnp.ndarray: Array of shape (n_input_samples, n_samples)\n            containing the fidelities.\n        \"\"\"\n        random_key = random.key(seed)\n\n        # Generate random parameter sets\n        # We need two sets of parameters, as we are computing fidelities for a\n        # pair of random state vectors\n        model.initialize_params(random_key, repeat=n_samples * 2)\n\n        # Initialize array to store fidelities\n        fidelities: jnp.ndarray = jnp.zeros((len(x_samples), n_samples))\n\n        # Compute the fidelity for each pair of input samples and parameters\n        for idx, x_sample in enumerate(x_samples):\n            # Evaluate the model for the current pair of input samples and parameters\n            # Execution type is explicitly set to density\n            sv: jnp.ndarray = model(\n                inputs=x_sample,\n                params=model.params,\n                execution_type=\"density\",\n                **kwargs,\n            )\n\n            # $\\sqrt{\\rho}$\n            sqrt_sv1: jnp.ndarray = jnp.array([sqrtm(m) for m in sv[:n_samples]])\n\n            # $\\sqrt{\\rho} \\sigma \\sqrt{\\rho}$\n            inner_fidelity = sqrt_sv1 @ sv[n_samples:] @ sqrt_sv1\n\n            # Compute the fidelity using the partial trace of the statevector\n            fidelity: jnp.ndarray = (\n                jnp.trace(\n                    jnp.array([sqrtm(m) for m in inner_fidelity]),\n                    axis1=1,\n                    axis2=2,\n                )\n                ** 2\n            )\n\n            fidelities = fidelities.at[idx].set(jnp.abs(fidelity))\n\n        return fidelities\n\n    @staticmethod\n    def state_fidelities(\n        seed: int,\n        n_samples: int,\n        n_bins: int,\n        model: Model,\n        n_input_samples: int = 0,\n        input_domain: List[float] = None,\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n        \"\"\"\n        Sample the state fidelities and histogram them into a 2D array.\n\n        Args:\n            seed (int): Random number generator seed.\n            n_samples (int): Number of parameter sets to generate.\n            n_bins (int): Number of histogram bins.\n            n_input_samples (int): Number of input samples.\n            input_domain (List[float]): Input domain.\n            model (Callable): Function that models the quantum circuit.\n            scale (bool): Whether to scale the number of samples and bins.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]: Tuple containing the\n                input samples, bin edges, and histogram values.\n        \"\"\"\n        if scale:\n            n_samples = jnp.power(2, model.n_qubits) * n_samples\n            n_bins = model.n_qubits * n_bins\n\n        if input_domain is None or n_input_samples is None or n_input_samples == 0:\n            x = jnp.zeros((1))\n            n_input_samples = 1\n        else:\n            x = jnp.linspace(*input_domain, n_input_samples)\n\n        fidelities = Expressibility._sample_state_fidelities(\n            x_samples=x,\n            n_samples=n_samples,\n            seed=seed,\n            model=model,\n            kwargs=kwargs,\n        )\n        z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n        y: jnp.ndarray = jnp.linspace(0, 1, n_bins + 1)\n\n        for i, f in enumerate(fidelities):\n            z[i], _ = jnp.histogram(f, bins=y)\n\n        z = z / n_samples\n\n        if z.shape[0] == 1:\n            z = z.flatten()\n\n        return x, y, z\n\n    @staticmethod\n    def _haar_probability(fidelity: float, n_qubits: int) -&gt; float:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876).\n\n        Args:\n            fidelity (float): fidelity of two parameter assignments in [0, 1]\n            n_qubits (int): number of qubits in the quantum system\n\n        Returns:\n            float: probability for a given fidelity\n        \"\"\"\n        N = 2**n_qubits\n\n        prob = (N - 1) * (1 - fidelity) ** (N - 2)\n        return prob\n\n    @staticmethod\n    def _sample_haar_integral(n_qubits: int, n_bins: int) -&gt; jnp.ndarray:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 2D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n\n        Returns:\n            jnp.ndarray: probability distribution for all fidelities\n        \"\"\"\n        dist = np.zeros(n_bins)\n        for idx in range(n_bins):\n            v = idx / n_bins\n            u = (idx + 1) / n_bins\n            dist[idx], _ = integrate.quad(\n                Expressibility._haar_probability, v, u, args=(n_qubits,)\n            )\n\n        return dist\n\n    @staticmethod\n    def haar_integral(\n        n_qubits: int,\n        n_bins: int,\n        cache: bool = True,\n        scale: bool = False,\n    ) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 3D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n            cache (bool): whether to cache the haar integral\n            scale (bool): whether to scale the number of bins\n\n        Returns:\n            Tuple[jnp.ndarray, jnp.ndarray]:\n                - x component (bins): the input domain\n                - y component (probabilities): the haar probability density\n                  funtion for random Haar states\n        \"\"\"\n        if scale:\n            n_bins = n_qubits * n_bins\n\n        x = jnp.linspace(0, 1, n_bins)\n\n        if cache:\n            name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n            cache_folder = \".cache\"\n            if not os.path.exists(cache_folder):\n                os.mkdir(cache_folder)\n\n            file_path = os.path.join(cache_folder, name)\n\n            if os.path.isfile(file_path):\n                y = jnp.load(file_path)\n                return x, y\n\n        y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n        if cache:\n            jnp.save(file_path, y)\n\n        return x, y\n\n    @staticmethod\n    def kullback_leibler_divergence(\n        vqc_prob_dist: jnp.ndarray,\n        haar_dist: jnp.ndarray,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Calculates the KL divergence between two probability distributions (Haar\n        probability distribution and the fidelity distribution sampled from a VQC).\n\n        Args:\n            vqc_prob_dist (jnp.ndarray): VQC fidelity probability distribution.\n                Should have shape (n_inputs_samples, n_bins)\n            haar_dist (jnp.ndarray): Haar probability distribution with shape.\n                Should have shape (n_bins, )\n\n        Returns:\n            jnp.ndarray: Array of KL-Divergence values for all values in axis 1\n        \"\"\"\n        if len(vqc_prob_dist.shape) &gt; 1:\n            assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n                \"All probabilities for inputs should have the same shape as Haar. \"\n                f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n            )\n        else:\n            vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n        kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n        for idx, p in enumerate(vqc_prob_dist):\n            kl_divergence[idx] = jnp.sum(rel_entr(p, haar_dist))\n\n        return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.haar_integral","title":"<code>haar_integral(n_qubits, n_bins, cache=True, scale=False)</code>  <code>staticmethod</code>","text":"<p>Calculates theoretical probability density function for random Haar states as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it into a 3D-histogram.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>number of qubits in the quantum system</p> required <code>n_bins</code> <code>int</code> <p>number of histogram bins</p> required <code>cache</code> <code>bool</code> <p>whether to cache the haar integral</p> <code>True</code> <code>scale</code> <code>bool</code> <p>whether to scale the number of bins</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[jnp.ndarray, jnp.ndarray]: - x component (bins): the input domain - y component (probabilities): the haar probability density   funtion for random Haar states</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef haar_integral(\n    n_qubits: int,\n    n_bins: int,\n    cache: bool = True,\n    scale: bool = False,\n) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:\n    \"\"\"\n    Calculates theoretical probability density function for random Haar states\n    as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n    into a 3D-histogram.\n\n    Args:\n        n_qubits (int): number of qubits in the quantum system\n        n_bins (int): number of histogram bins\n        cache (bool): whether to cache the haar integral\n        scale (bool): whether to scale the number of bins\n\n    Returns:\n        Tuple[jnp.ndarray, jnp.ndarray]:\n            - x component (bins): the input domain\n            - y component (probabilities): the haar probability density\n              funtion for random Haar states\n    \"\"\"\n    if scale:\n        n_bins = n_qubits * n_bins\n\n    x = jnp.linspace(0, 1, n_bins)\n\n    if cache:\n        name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n        cache_folder = \".cache\"\n        if not os.path.exists(cache_folder):\n            os.mkdir(cache_folder)\n\n        file_path = os.path.join(cache_folder, name)\n\n        if os.path.isfile(file_path):\n            y = jnp.load(file_path)\n            return x, y\n\n    y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n    if cache:\n        jnp.save(file_path, y)\n\n    return x, y\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.kullback_leibler_divergence","title":"<code>kullback_leibler_divergence(vqc_prob_dist, haar_dist)</code>  <code>staticmethod</code>","text":"<p>Calculates the KL divergence between two probability distributions (Haar probability distribution and the fidelity distribution sampled from a VQC).</p> <p>Parameters:</p> Name Type Description Default <code>vqc_prob_dist</code> <code>ndarray</code> <p>VQC fidelity probability distribution. Should have shape (n_inputs_samples, n_bins)</p> required <code>haar_dist</code> <code>ndarray</code> <p>Haar probability distribution with shape. Should have shape (n_bins, )</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Array of KL-Divergence values for all values in axis 1</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef kullback_leibler_divergence(\n    vqc_prob_dist: jnp.ndarray,\n    haar_dist: jnp.ndarray,\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Calculates the KL divergence between two probability distributions (Haar\n    probability distribution and the fidelity distribution sampled from a VQC).\n\n    Args:\n        vqc_prob_dist (jnp.ndarray): VQC fidelity probability distribution.\n            Should have shape (n_inputs_samples, n_bins)\n        haar_dist (jnp.ndarray): Haar probability distribution with shape.\n            Should have shape (n_bins, )\n\n    Returns:\n        jnp.ndarray: Array of KL-Divergence values for all values in axis 1\n    \"\"\"\n    if len(vqc_prob_dist.shape) &gt; 1:\n        assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n            \"All probabilities for inputs should have the same shape as Haar. \"\n            f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n        )\n    else:\n        vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n    kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n    for idx, p in enumerate(vqc_prob_dist):\n        kl_divergence[idx] = jnp.sum(rel_entr(p, haar_dist))\n\n    return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.state_fidelities","title":"<code>state_fidelities(seed, n_samples, n_bins, model, n_input_samples=0, input_domain=None, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Sample the state fidelities and histogram them into a 2D array.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>Random number generator seed.</p> required <code>n_samples</code> <code>int</code> <p>Number of parameter sets to generate.</p> required <code>n_bins</code> <code>int</code> <p>Number of histogram bins.</p> required <code>n_input_samples</code> <code>int</code> <p>Number of input samples.</p> <code>0</code> <code>input_domain</code> <code>List[float]</code> <p>Input domain.</p> <code>None</code> <code>model</code> <code>Callable</code> <p>Function that models the quantum circuit.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples and bins.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]: Tuple containing the input samples, bin edges, and histogram values.</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef state_fidelities(\n    seed: int,\n    n_samples: int,\n    n_bins: int,\n    model: Model,\n    n_input_samples: int = 0,\n    input_domain: List[float] = None,\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n    \"\"\"\n    Sample the state fidelities and histogram them into a 2D array.\n\n    Args:\n        seed (int): Random number generator seed.\n        n_samples (int): Number of parameter sets to generate.\n        n_bins (int): Number of histogram bins.\n        n_input_samples (int): Number of input samples.\n        input_domain (List[float]): Input domain.\n        model (Callable): Function that models the quantum circuit.\n        scale (bool): Whether to scale the number of samples and bins.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]: Tuple containing the\n            input samples, bin edges, and histogram values.\n    \"\"\"\n    if scale:\n        n_samples = jnp.power(2, model.n_qubits) * n_samples\n        n_bins = model.n_qubits * n_bins\n\n    if input_domain is None or n_input_samples is None or n_input_samples == 0:\n        x = jnp.zeros((1))\n        n_input_samples = 1\n    else:\n        x = jnp.linspace(*input_domain, n_input_samples)\n\n    fidelities = Expressibility._sample_state_fidelities(\n        x_samples=x,\n        n_samples=n_samples,\n        seed=seed,\n        model=model,\n        kwargs=kwargs,\n    )\n    z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n    y: jnp.ndarray = jnp.linspace(0, 1, n_bins + 1)\n\n    for i, f in enumerate(fidelities):\n        z[i], _ = jnp.histogram(f, bins=y)\n\n    z = z / n_samples\n\n    if z.shape[0] == 1:\n        z = z.flatten()\n\n    return x, y, z\n</code></pre>"},{"location":"references/#coefficients","title":"Coefficients","text":"<pre><code>from qml_essentials.coefficients import Coefficients\n</code></pre> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>class Coefficients:\n    @staticmethod\n    def get_spectrum(\n        model: Model,\n        mfs: int = 1,\n        mts: int = 1,\n        shift=False,\n        trim=False,\n        **kwargs,\n    ) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:\n        \"\"\"\n        Extracts the coefficients of a given model using a FFT (jnp-fft).\n\n        Note that the coefficients are complex numbers, but the imaginary part\n        of the coefficients should be very close to zero, since the expectation\n        values of the Pauli operators are real numbers.\n\n        It can perform oversampling in both the frequency and time domain\n        using the `mfs` and `mts` arguments.\n\n        Args:\n            model (Model): The model to sample.\n            mfs (int): Multiplicator for the highest frequency. Default is 2.\n            mts (int): Multiplicator for the number of time samples. Default is 1.\n            shift (bool): Whether to apply jnp-fftshift. Default is False.\n            trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n                Default is False.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            Tuple[jnp.ndarray, jnp.ndarray]: Tuple containing the coefficients\n            and frequencies.\n        \"\"\"\n        kwargs.setdefault(\"force_mean\", True)\n        kwargs.setdefault(\"execution_type\", \"expval\")\n\n        coeffs, freqs = Coefficients._fourier_transform(\n            model, mfs=mfs, mts=mts, **kwargs\n        )\n\n        if not jnp.isclose(jnp.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n            raise ValueError(\n                f\"Spectrum is not real. Imaginary part of coefficients is:\\\n                {jnp.sum(coeffs).imag}\"\n            )\n\n        if trim:\n            for ax in range(model.n_input_feat):\n                if coeffs.shape[ax] % 2 == 0:\n                    coeffs = np.delete(coeffs, len(coeffs) // 2, axis=ax)\n                    freqs = [np.delete(freq, len(freq) // 2, axis=ax) for freq in freqs]\n\n        if shift:\n            coeffs = jnp.fft.fftshift(coeffs, axes=list(range(model.n_input_feat)))\n            freqs = np.fft.fftshift(freqs)\n\n        if len(freqs) == 1:\n            freqs = freqs[0]\n\n        return coeffs, freqs\n\n    @staticmethod\n    def _fourier_transform(\n        model: Model, mfs: int, mts: int, **kwargs: Any\n    ) -&gt; jnp.ndarray:\n        # Create a frequency vector with as many frequencies as model degrees,\n        # oversampled by mfs\n        n_freqs: jnp.ndarray = jnp.array(\n            [mfs * model.degree[i] for i in range(model.n_input_feat)]\n        )\n\n        start, stop, step = 0, 2 * mts * jnp.pi, 2 * jnp.pi / n_freqs\n        # Stretch according to the number of frequencies\n        inputs: List = [\n            jnp.arange(start, stop, step[i]) for i in range(model.n_input_feat)\n        ]\n\n        # permute with input dimensionality\n        nd_inputs = jnp.array(\n            jnp.meshgrid(*[inputs[i] for i in range(model.n_input_feat)])\n        ).T.reshape(-1, model.n_input_feat)\n\n        # Output vector is not necessarily the same length as input\n        outputs = model(inputs=nd_inputs, **kwargs)\n        outputs = outputs.reshape(\n            *[inputs[i].shape[0] for i in range(model.n_input_feat)], -1\n        ).squeeze()\n\n        coeffs = jnp.fft.fftn(outputs, axes=list(range(model.n_input_feat)))\n\n        freqs = [\n            jnp.fft.fftfreq(int(mts * n_freqs[i]), 1 / n_freqs[i])\n            for i in range(model.n_input_feat)\n        ]\n        # freqs = jnp.fft.fftfreq(mts * n_freqs, 1 / n_freqs)\n\n        # TODO: this could cause issues with multidim input\n        # FIXME: account for different frequencies in multidim input scenarios\n        # Run the fft and rearrange +\n        # normalize the output (using product if multidim)\n        return (\n            coeffs / math.prod(outputs.shape[0 : model.n_input_feat]),\n            freqs,\n        )\n\n    @staticmethod\n    def get_psd(coeffs: jnp.ndarray) -&gt; jnp.ndarray:\n        \"\"\"\n        Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n        Args:\n            coeffs (jnp.ndarray): The Fourier coefficients.\n\n        Returns:\n            jnp.ndarray: The power spectral density.\n        \"\"\"\n        # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n        def abs2(x):\n            return x.real**2 + x.imag**2\n\n        scale = 2.0 / (len(coeffs) ** 2)\n        return scale * abs2(coeffs)\n\n    @staticmethod\n    def evaluate_Fourier_series(\n        coefficients: jnp.ndarray,\n        frequencies: jnp.ndarray,\n        inputs: Union[jnp.ndarray, list, float],\n    ) -&gt; float:\n        \"\"\"\n        Evaluate the function value of a Fourier series at one point.\n\n        Args:\n            coefficients (jnp.ndarray): Coefficients of the Fourier series.\n            frequencies (jnp.ndarray): Corresponding frequencies.\n            inputs (jnp.ndarray): Point at which to evaluate the function.\n        Returns:\n            float: The function value at the input point.\n        \"\"\"\n        if isinstance(frequencies, list):\n            if len(coefficients.shape) &lt;= len(frequencies):\n                coefficients = coefficients[..., jnp.newaxis]\n        else:\n            if len(coefficients.shape) == 1:\n                coefficients = coefficients[..., jnp.newaxis]\n\n        if isinstance(inputs, list):\n            inputs = jnp.array(inputs)\n        if len(inputs.shape) &lt; 1:\n            inputs = inputs[jnp.newaxis, ...]\n\n        if isinstance(frequencies, list):\n            input_dim = len(frequencies)\n            frequencies = jnp.stack(jnp.meshgrid(*frequencies))\n            if input_dim != len(inputs):\n                frequencies = jnp.repeat(\n                    frequencies[jnp.newaxis, ...], inputs.shape[0], axis=0\n                )\n                freq_inputs = jnp.einsum(\"bi...,b-&gt;b...\", frequencies, inputs)\n                exponents = jnp.exp(1j * freq_inputs).T\n                exp = jnp.einsum(\"jl...k,jl...b-&gt;b...k\", coefficients, exponents)\n            else:\n                freq_inputs = jnp.einsum(\"i...,i-&gt;...\", frequencies, inputs)\n                exponents = jnp.exp(1j * freq_inputs).T\n                exp = jnp.einsum(\"jl...k,jl...-&gt;k...\", coefficients, exponents)\n        else:\n            frequencies = jnp.repeat(\n                frequencies[jnp.newaxis, ...], inputs.shape[0], axis=0\n            )\n            freq_inputs = jnp.einsum(\"i...,i-&gt;i...\", frequencies, inputs)\n            exponents = jnp.exp(1j * freq_inputs)\n            exp = jnp.einsum(\"j...k,ij...-&gt;ik...\", coefficients, exponents)\n\n        return jnp.squeeze(jnp.real(exp))\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.evaluate_Fourier_series","title":"<code>evaluate_Fourier_series(coefficients, frequencies, inputs)</code>  <code>staticmethod</code>","text":"<p>Evaluate the function value of a Fourier series at one point.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>Coefficients of the Fourier series.</p> required <code>frequencies</code> <code>ndarray</code> <p>Corresponding frequencies.</p> required <code>inputs</code> <code>ndarray</code> <p>Point at which to evaluate the function.</p> required <p>Returns:     float: The function value at the input point.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef evaluate_Fourier_series(\n    coefficients: jnp.ndarray,\n    frequencies: jnp.ndarray,\n    inputs: Union[jnp.ndarray, list, float],\n) -&gt; float:\n    \"\"\"\n    Evaluate the function value of a Fourier series at one point.\n\n    Args:\n        coefficients (jnp.ndarray): Coefficients of the Fourier series.\n        frequencies (jnp.ndarray): Corresponding frequencies.\n        inputs (jnp.ndarray): Point at which to evaluate the function.\n    Returns:\n        float: The function value at the input point.\n    \"\"\"\n    if isinstance(frequencies, list):\n        if len(coefficients.shape) &lt;= len(frequencies):\n            coefficients = coefficients[..., jnp.newaxis]\n    else:\n        if len(coefficients.shape) == 1:\n            coefficients = coefficients[..., jnp.newaxis]\n\n    if isinstance(inputs, list):\n        inputs = jnp.array(inputs)\n    if len(inputs.shape) &lt; 1:\n        inputs = inputs[jnp.newaxis, ...]\n\n    if isinstance(frequencies, list):\n        input_dim = len(frequencies)\n        frequencies = jnp.stack(jnp.meshgrid(*frequencies))\n        if input_dim != len(inputs):\n            frequencies = jnp.repeat(\n                frequencies[jnp.newaxis, ...], inputs.shape[0], axis=0\n            )\n            freq_inputs = jnp.einsum(\"bi...,b-&gt;b...\", frequencies, inputs)\n            exponents = jnp.exp(1j * freq_inputs).T\n            exp = jnp.einsum(\"jl...k,jl...b-&gt;b...k\", coefficients, exponents)\n        else:\n            freq_inputs = jnp.einsum(\"i...,i-&gt;...\", frequencies, inputs)\n            exponents = jnp.exp(1j * freq_inputs).T\n            exp = jnp.einsum(\"jl...k,jl...-&gt;k...\", coefficients, exponents)\n    else:\n        frequencies = jnp.repeat(\n            frequencies[jnp.newaxis, ...], inputs.shape[0], axis=0\n        )\n        freq_inputs = jnp.einsum(\"i...,i-&gt;i...\", frequencies, inputs)\n        exponents = jnp.exp(1j * freq_inputs)\n        exp = jnp.einsum(\"j...k,ij...-&gt;ik...\", coefficients, exponents)\n\n    return jnp.squeeze(jnp.real(exp))\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_psd","title":"<code>get_psd(coeffs)</code>  <code>staticmethod</code>","text":"<p>Calculates the power spectral density (PSD) from given Fourier coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>The Fourier coefficients.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: The power spectral density.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_psd(coeffs: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"\n    Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n    Args:\n        coeffs (jnp.ndarray): The Fourier coefficients.\n\n    Returns:\n        jnp.ndarray: The power spectral density.\n    \"\"\"\n    # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n    def abs2(x):\n        return x.real**2 + x.imag**2\n\n    scale = 2.0 / (len(coeffs) ** 2)\n    return scale * abs2(coeffs)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_spectrum","title":"<code>get_spectrum(model, mfs=1, mts=1, shift=False, trim=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Extracts the coefficients of a given model using a FFT (jnp-fft).</p> <p>Note that the coefficients are complex numbers, but the imaginary part of the coefficients should be very close to zero, since the expectation values of the Pauli operators are real numbers.</p> <p>It can perform oversampling in both the frequency and time domain using the <code>mfs</code> and <code>mts</code> arguments.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to sample.</p> required <code>mfs</code> <code>int</code> <p>Multiplicator for the highest frequency. Default is 2.</p> <code>1</code> <code>mts</code> <code>int</code> <p>Multiplicator for the number of time samples. Default is 1.</p> <code>1</code> <code>shift</code> <code>bool</code> <p>Whether to apply jnp-fftshift. Default is False.</p> <code>False</code> <code>trim</code> <code>bool</code> <p>Whether to remove the Nyquist frequency if spectrum is even. Default is False.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[jnp.ndarray, jnp.ndarray]: Tuple containing the coefficients</p> <code>ndarray</code> <p>and frequencies.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_spectrum(\n    model: Model,\n    mfs: int = 1,\n    mts: int = 1,\n    shift=False,\n    trim=False,\n    **kwargs,\n) -&gt; Tuple[jnp.ndarray, jnp.ndarray]:\n    \"\"\"\n    Extracts the coefficients of a given model using a FFT (jnp-fft).\n\n    Note that the coefficients are complex numbers, but the imaginary part\n    of the coefficients should be very close to zero, since the expectation\n    values of the Pauli operators are real numbers.\n\n    It can perform oversampling in both the frequency and time domain\n    using the `mfs` and `mts` arguments.\n\n    Args:\n        model (Model): The model to sample.\n        mfs (int): Multiplicator for the highest frequency. Default is 2.\n        mts (int): Multiplicator for the number of time samples. Default is 1.\n        shift (bool): Whether to apply jnp-fftshift. Default is False.\n        trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n            Default is False.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        Tuple[jnp.ndarray, jnp.ndarray]: Tuple containing the coefficients\n        and frequencies.\n    \"\"\"\n    kwargs.setdefault(\"force_mean\", True)\n    kwargs.setdefault(\"execution_type\", \"expval\")\n\n    coeffs, freqs = Coefficients._fourier_transform(\n        model, mfs=mfs, mts=mts, **kwargs\n    )\n\n    if not jnp.isclose(jnp.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n        raise ValueError(\n            f\"Spectrum is not real. Imaginary part of coefficients is:\\\n            {jnp.sum(coeffs).imag}\"\n        )\n\n    if trim:\n        for ax in range(model.n_input_feat):\n            if coeffs.shape[ax] % 2 == 0:\n                coeffs = np.delete(coeffs, len(coeffs) // 2, axis=ax)\n                freqs = [np.delete(freq, len(freq) // 2, axis=ax) for freq in freqs]\n\n    if shift:\n        coeffs = jnp.fft.fftshift(coeffs, axes=list(range(model.n_input_feat)))\n        freqs = np.fft.fftshift(freqs)\n\n    if len(freqs) == 1:\n        freqs = freqs[0]\n\n    return coeffs, freqs\n</code></pre>"},{"location":"training/","title":"Training","text":"<p>This section describes how to use the model provided with this package, using a simple training scenario as an example.</p> <p>We consider a Fourier series with \\(n\\) frequencies defined as follows:</p> \\[ f(x, \\boldsymbol{\\theta})=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) e^{i \\omega x}=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) \\left(\\cos(\\omega x) + i \\sin(\\omega x)\\right) \\] <p>Here, \\(\\omega \\in \\boldsymbol{\\Omega}\\) are the frequencies in the spectrum with the Fourier coefficients \\(c_{\\omega}(\\boldsymbol{\\theta})\\), parameterized by the set of trainable parameters \\(\\boldsymbol{\\theta}\\).</p> <p>As shown by Schuld et al. (2020), a quantum circuit, parametrised by \\(\\boldsymbol{\\theta}\\) and input \\(x\\) and is equivalent to the Fourier series representation. Such circuits must be of the following form:</p> \\[ f(x, \\boldsymbol{\\theta})=\\langle 0\\vert^{\\otimes n} U^{\\dagger}(x, \\boldsymbol{\\theta}) \\mathcal{M} U(x, \\boldsymbol{\\theta})\\vert 0\\rangle^{\\otimes n} \\] <p>Therefore, training such a model on a Fourier series is a proof-of-concept which we want to demonstrate here.</p> <p>Let's start with building our dataset. A Fourier series with \\(4\\) frequencies: <pre><code>import pennylane.numpy as np\nimport matplotlib.pyplot as plt\n\ndomain = [-np.pi, np.pi]\nomegas = np.array([1, 2, 3, 4])\ncoefficients = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Calculate the number of required samples to satisfy the Nyquist criterium\nn_d = int(np.ceil(2 * np.max(np.abs(domain)) * np.max(omegas)))\n# Sample the domain linearly\nx = np.linspace(domain[0], domain[1], num=n_d)\n\n# define our Fourier series f(x)\ndef f(x):\n    return 1 / np.linalg.norm(omegas) * np.sum(coefficients * np.cos(omegas.T * x))\n\n# evaluate f(x) on the domain samples\ny = np.stack([f(sample) for sample in x])\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.show()\n</code></pre></p> <p> </p> <p>Note that we chose the coefficients to be all \\(0.5\\). Play around with those values to change the magnitude of each frequency component. Also note that we're using the Pennylane version of Numpy, which is required because of the optimizer that we will be using later. Now that we have our \"dataset\", let's move on and build a model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n)\n</code></pre></p> <p>This is the minimal amout of information needed. According to the work referenced above, a model with \\(4\\) qubits should be capable of learning a Fourier series with \\(4\\) frequencies, considering single qubit Pauli encoding (which we have by default).</p> <p>Now, let's train our model: <pre><code>import pennylane as qml\n\nopt = qml.AdamOptimizer(stepsize=0.01)\n\ndef cost_fct(params):\n    y_hat = model(params=params, inputs=x, force_mean=True)\n\n    return np.mean((y_hat - y) ** 2)\n\nfor epoch in range(1, 1001):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n\nplt.plot(x, y, label=\"True function\")\nplt.plot(x, model(params=model.params, inputs=x, force_mean=True), label=\"Model prediction\")\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.legend()\nplt.show()\n</code></pre></p> <pre><code>Epoch: 100, Cost: 0.0081\nEpoch: 200, Cost: 0.0073\nEpoch: 300, Cost: 0.0051\nEpoch: 400, Cost: 0.0043\nEpoch: 500, Cost: 0.0036\nEpoch: 600, Cost: 0.0022\nEpoch: 700, Cost: 0.0014\nEpoch: 800, Cost: 0.0008\nEpoch: 900, Cost: 0.0006\nEpoch: 1000, Cost: 0.0001\n</code></pre> <p> </p> <p>As you can see, the model is able to learn the Fourier series with the \\(4\\) frequencies.</p>"},{"location":"training/#trainable_frequencies","title":"Trainable frequencies","text":"<p>For the model we just trained, we considered the best possible scenario: evenly spaced, integer omegas. But, as shown by Schuld et al. (2020), we'll need an increasing and inefficient amount of qubits for larger omegas. What is more, the model will fail altogether if the frequencies are un-evenly spaced. Luckily, Jaderberg et al. (2024) showed how we can let the model choose its own frequencies by including a set of encoding parameters that act on the input before the encoding layers of the circuit. We demonstrate this functionality below. </p> <p>First, let's slighly modify the omegas from the first example and re-generate the data: <pre><code>domain = [-np.pi, np.pi]\nomegas = np.array([1.2, 2.6, 3.4, 4.9])\ncoefficients = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Calculate the number of required samples to satisfy the Nyquist criterium\nn_d = int(np.ceil(2 * np.max(np.abs(domain)) * np.max(omegas)))\n# Sample the domain linearly\nx = np.linspace(domain[0], domain[1], num=n_d)\n\n# define our Fourier series f(x)\ndef f(x):\n    return 1 / np.linalg.norm(omegas) * np.sum(coefficients * np.cos(omegas.T * x))\n\n# evaluate f(x) on the domain samples\ny = np.stack([f(sample) for sample in x])\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.show()\n</code></pre></p> <p> </p> <p>Now, let's build a model with fixed frequencies, as before, and one with trainable frequencies: <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n)\nmodel_tf = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    trainable_frequencies=True # &lt;---!\n)\n</code></pre></p> <p>Let's train both models: <pre><code># - Fixed Frequencies -\nopt = qml.AdamOptimizer(stepsize=0.01)\n\nprint(\"Training fixed frequency model\")\nfor epoch in range(1, 1001):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n\n# - Trainable Frequencies -\nopt = qml.AdamOptimizer(stepsize=0.01)\n\ndef cost_fct_tf(params, enc_params):\n    y_hat = model_tf(params=params, enc_params=enc_params, inputs=x, force_mean=True)\n    return np.mean((y_hat - y) ** 2)\n\nprint(f\"\\nTraining trainable frequency model\")\nfor epoch in range(1, 1001):\n    (model_tf.params, model_tf.enc_params), cost_val_tf = opt.step_and_cost(cost_fct_tf, model_tf.params, model_tf.enc_params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val_tf:.6f}\")\n\nplt.plot(x, y, label=\"True function\")\nplt.plot(x, model(params=model.params, inputs=x, force_mean=True), label=\"Fixed frequencies model prediction\")\nplt.plot(x, model_tf(params=model_tf.params, enc_params=model_tf.enc_params, inputs=x, force_mean=True), label=\"Trainable frequencies model prediction\")\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.legend()\nplt.show()\n</code></pre></p> <pre><code>Training fixed frequency model\nEpoch: 100, Cost: 0.0082\nEpoch: 200, Cost: 0.0067\nEpoch: 300, Cost: 0.0038\nEpoch: 400, Cost: 0.0031\nEpoch: 500, Cost: 0.0027\nEpoch: 600, Cost: 0.0026\nEpoch: 700, Cost: 0.0025\nEpoch: 800, Cost: 0.0024\nEpoch: 900, Cost: 0.0023\nEpoch: 1000, Cost: 0.0023\n\nTraining trainable frequency model\nEpoch: 100, Cost: 0.008454\nEpoch: 200, Cost: 0.002759\nEpoch: 300, Cost: 0.002382\nEpoch: 400, Cost: 0.001655\nEpoch: 500, Cost: 0.000232\nEpoch: 600, Cost: 0.000019\nEpoch: 700, Cost: 0.000010\nEpoch: 800, Cost: 0.000003\nEpoch: 900, Cost: 0.000001\nEpoch: 1000, Cost: 0.000001\n</code></pre> <p> </p> <p>As you can see, the fixed frequencies model was not able to find the underlying function representing the data, while the trainable frequencies model was successful in its training.</p> <p>Let's quickly check the final encoding parameter of both models: <pre><code>print(f\"Encoding parameters of the fixed frequencies model: {model.enc_params}\")\nprint(f\"Encoding parameters of the trainable frequencies model: {np.round(model_tf.enc_params, 3)}\")\n</code></pre></p> <pre><code>Encoding parameters of the fixed frequencies model: [1. 1. 1. 1.]\nEncoding parameters of the trainable frequencies model: [1.001 2.065 2.817 0.364]\n</code></pre> <p>Clearly, the trainable frequencies model found the set of encoding parameters that allowed it to represent the given arbitrary frequency spectrum. </p> <p>One last thing that might be interesting! Currently, the model applies  <pre><code>enc_params[qubit] * inputs[:, idx]\n</code></pre> to allow for trainable frequencies. You may try different input transformations before the encoding by modifying the <code>model.transform_input</code> method. For example, if an <code>RX</code> gate performs the encoding, you may apply the identity operator by  <pre><code>model.transform_input = lambda inputs, qubit, idx, enc_params: np.arccos(inputs[:, idx])\n</code></pre></p>"},{"location":"training/#using_the_built-in_dataset","title":"Using the built-in Dataset","text":"<p>Previous examples considered a very simplified version of a training dataset. Extending this to multi-dimensional inputs and different encoding schemes of the model can be quite a tedious work to implement. For this purpose, we provide a ready-to-use Fourier series dataset in the <code>qml_essentials.datasets</code> module. This dataset uses the model properties to generate a Fourier series that matches what the model can learn, meaning that the frequencies are inferred from <code>model.frequencies</code>. Furthermore, it is possible to control the magnitude of the coefficients, sampled from a complex unit circle, by setting <code>coefficients_min</code> and <code>coefficients_max</code>. Calling <code>generate_fourier_series</code> will return the domain samples, Fourier series samples and the coefficients of the Fourier series.</p> <p>The code snippet below provides a minimal example on how to use this dataset:</p> <pre><code>from qml_essentials.coefficients import Datasets\n\n# generate a Fourier series dataset\ndomain_samples, fourier_samples, coefficients = (\n                    Datasets.generate_fourier_series(\n                        rng=np.random.default_rng(1000),\n                        model=model,\n                    )\n                )\n\n# cost function uses the domain samples as input and compares with the\n# Fourier series samples obtained from the dataset\ndef cost_fct(params):\n    y_hat = model(params=params, inputs=domain_samples, force_mean=True)\n\n    return np.mean((y_hat - fourier_samples) ** 2)\n\nfor epoch in range(1, 1000):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n</code></pre> <p> </p> <p>Note that it's more difficult for the model to fit this specific dataset as it, opposed to the previous datasets, also contains complex parts in the coefficients, effectively causing a phase shift.</p>"},{"location":"training/#pulse_level","title":"Pulse Level","text":"<p>Note: Not implemented yet</p> <ul> <li>How to train pulse parameters</li> </ul> <p>Btw, if you're in a hurry, we have a Jupyter notebook with the exact same examples here .</p> <p>Wondering what to do next? You can try a few different models, and see how they perform. If you're curious, checkout how this correlates with the Entanglement and Expressibility of the model.</p>"},{"location":"usage/","title":"Usage","text":"<p>Central component of our package is the Fourier model which you can import with  <pre><code>from qml_essentials.model import Model\n</code></pre></p> <p>In the simplest scenario, one would instantiate such a model with \\(4\\) qubits and a single layer using the \"Hardware Efficient\" ansatz by: <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Hardware_Efficient\",\n)\n</code></pre></p> <p>You can take a look at your model, by simply calling <pre><code>model.draw(figure=\"mpl\")\n</code></pre></p> <p> </p> <p>Looks good to you?  Head over to the Training page for getting started with an easy example, where we also show how to implement trainable frequencies  If you want to learn more about, why we get the above results, checkout the Data-Reuploading section.</p> <p>Note that calling the model without any (<code>None</code>) values for the <code>params</code> and <code>inputs</code> argument, will implicitly call the model with the recently (or initial) parameters and <code>0</code>s as input. I.e. simply running the following <pre><code>model()\n</code></pre> will return the combined expectation value of a n-local measurement (<code>output_qubit=-1</code> is default). </p> <p>In the following we will describe some concepts of the <code>Model</code> class. For a more detailled reference on the methods and arguments that are available, please see the references page.</p>"},{"location":"usage/#the_essentials","title":"The essentials","text":"<p>There is much more to this package than just providing a Fourier model. You can calculate the Expressibility or Entangling Capability besides the Coefficients which are unique to this kind of QML interpretation. You can also provide a custom circuit, by instantiating from the <code>Circuit</code> class in <code>qml_essentials.ansaetze.Circuit</code>. See page Ansaetze for more details and a list of available Ansatzes that we provide with this package.</p>"},{"location":"usage/#data-reuploading","title":"Data-Reuploading","text":"<p>The idea of repeating the input encoding is one of the core features of our framework and builds upon the work by Schuld et al. (2020). Essentially, it allows us to represent a quantum circuit as a truncated Fourier series, which is a powerful feature that enables the model to mimic arbitrary non-linear functions. The number of frequencies that the model can represent is constrained by the number of data encoding steps within the circuit.</p> <p>Typically, there is a reuploading step after each layer and on each qubit (<code>data_reupload=True</code>). However, our package also allows you to specify an array with the number of rows representing the qubits and number of columns representing the layers. Then, a <code>True</code> means that encoding is applied at the corresponding position within the circuit.</p> <p>In the following example, we disable two instances of the data-reuploading step, thus leaving the model with <code>model.degree = (5)</code> frequencies (2 negative + zero frequency + 2 positive).</p> <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=2,\n    circuit_type=\"Hardware_Efficient\",\n    data_reupload=[[True, False], [False, True]],\n)\n</code></pre> <p>Checkout the Coefficients page for more details on how you can visualize such a model using tools from signal analysis. If you want to encode multi-dimensional data (check out the Encoding section on how to do that), you can specify another dimension in the <code>data_reupload</code> argument (which just extents naturally). <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=2,\n    circuit_type=\"Hardware_Efficient\",\n    data_reupload=[[[0, 1], [1, 1]], [[1, 1], [0, 1]]],\n)\n</code></pre> Now, the first input will have two frequencies (<code>sum([0,1,1,0]) = 2</code>), and the second input will have four frequencies (<code>sum([1,1,1,1]) = 4</code>). Of course, this is just a rule of thumb and can vary depending on the exact encoding strategy.</p>"},{"location":"usage/#parameter_initialization","title":"Parameter Initialization","text":"<p>The initialization strategy can be set when instantiating the model with the <code>initialization</code> argument.</p> <p>The default strategy is \"random\" which will result in random initialization of the parameters using the domain specified in the <code>initialization_domain</code> argument. Other options are: - \"zeros\": All parameters are initialized to \\(0\\) - \"zero-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(0\\) - \"pi-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(\\\\pi\\) - \"pi\": All parameters are initialized to \\(\\\\pi\\)</p> <p>The <code>initialize_params</code> method provides the option to re-initialise the parameters after model instantiation using either the previous configuration or a different strategy. Given a PRNG key, it returns the <code>key</code> from <code>key, subkey = random.split(key)</code>  as documented here and uses the subkey for the actual parameter initialization. It's also possible to omit the <code>key</code> argument entirely, as the model has an internal <code>random_key</code> state which is updated every time randomness is utilized. This allows to repeatingly call <code>model.initialize_params()</code> to generate a continous sequence of random initializations.</p>"},{"location":"usage/#encoding","title":"Encoding","text":"<p>The encoding can be set when instantiating the model with the <code>encoding</code> argument.</p> <p>The default encoding is \"RX\" which will result in a single RX rotation per qubit. Other options are:</p> <ul> <li>A string such as <code>\"RX\"</code> that will result in a single RX rotation per qubit</li> <li>A list of strings such as <code>[\"RX\", \"RY\"]</code> that will result in a sequential RX and RY rotation per qubit</li> <li>Any callable such as <code>Gates.RX</code></li> <li>A list of callables such as <code>[Gates.RX, Gates.RY]</code></li> <li>An instance of the <code>Encoding</code> class</li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class. If a list of encodings is provided, the input is assumed to be multi-dimensional. Otherwise multiple inputs are treated as batches of inputs. If you want to visualize zero-valued encoding gates in the model, set <code>remove_zero_encoding</code> to <code>False</code> on instantiation.</p> <p>In case of a multi-dimensional input, you can obtain the highest frequency in each encoding dimension from the <code>model.degree</code> property. Note that, <code>model.degree</code> includes the negative and zero frequency (i.e. the full spectrum). Individual frequencies can be obtained via <code>model.frequencies</code>.</p> <p>By default, all encodings are <code>Hamming</code> encodings, meaning, all encodings are applied equally in each data-reuploading step. Note it is also possible to provide a custom encoding as the <code>encoding</code> argument essentially accepts any callable or list of callables see here for more details. To make things a little bit easier, we implement following encoding strategies as introduced in Generalization despite overfitting in quantum machine learning models with their respective spectral properties:</p> Encoding strategy Spectrum \\(\\Omega\\) \\(\\vert\\Omega\\vert\\) Hamming \\(\\{-n_{q},-(n_{q}-1),\\ldots,n_{q}\\}\\) \\(2 n_{q}+1\\) Binary \\(\\{-2^{n_{q}}+1,\\ldots,2^{n_{q}}-1\\}\\) \\(2^{n_{q}+1}- 1\\) Ternary \\(\\left\\{-\\left\\lfloor\\frac{3^{n_{q}}}{2}\\right\\rfloor,\\ldots,\\left\\lfloor\\frac{3^{n_{q}}}{2}\\right\\rfloor\\right\\}\\) \\(3^{n_{q}}\\) <p>You can use these templates by instantiating an <code>Encoding</code> class with the encoding strategy you like and passing it to the model upon initialization:</p> <pre><code>from qml_essentials.ansaetze import Encoding\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    encoding=Encoding(\"ternary\", [\"RX\", \"RY\"]),\n)\n\nmodel.frequencies\n</code></pre> <p>Returns <code>[9,9]</code>, which corresponds to the ternary spectrum \\(3^{2}\\) for two indpendent inputs.</p>"},{"location":"usage/#state_preparation","title":"State Preparation","text":"<p>While the encoding is applied in each data-reuploading step, the state preparation is only applied at the beginning of the circuit, but after the <code>StatePreparation</code> noise (see below for details). The default is no state preparation. Similar to the encoding, you can provide the <code>state_preparation</code> argument as</p> <ul> <li>A string such as <code>\"H\"</code> that will result in a single Hadamard per qubit</li> <li>A list of strings such as <code>[\"H\", \"H\"]</code> that will result in two consecutive Hadamards per qubit</li> <li>Any callable such as <code>Gates.H</code></li> <li>A list of callables such as <code>[Gates.H, Gates.H]</code></li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class.</p>"},{"location":"usage/#output_shape","title":"Output Shape","text":"<p>The output shape is determined by the <code>output_qubit</code> argument, provided in the instantiation of the model. When set to -1 all qubits are measured which will result in the shape being of size \\(n\\) by default (depending on the execution type, see below). Setting <code>output_qubit</code> to an integer will measue the qubit with the index specified. Furthermore, \"parity measurements\" are supported, where <code>output_qubit</code> becomes a list of qubit pairs, e.g. <code>[[0, 1], [2, 3]]</code> to measure the parity between qubits 0 and 1 and qubits 2 and 3.</p> <p>If <code>force_mean</code> flag is set when calling the model, the output is averaged to a single value (while keeping the batch/ input dimension). This is usually helpful, if you want to perform a n-local measurement over all qubits where only the average over \\(n\\) expecation values is of interest.</p>"},{"location":"usage/#execution_type","title":"Execution Type","text":"<p>Our model be simulated in different ways by setting the <code>execution_type</code> property, when calling the model, to:</p> <ul> <li><code>expval</code>: Returns the expectation value between \\(0\\) and \\(1\\)</li> <li><code>density</code>: Calculates the density matrix</li> <li><code>probs</code>: Simulates the model with the number of shots, set by <code>model.shots</code></li> </ul> <p>For all three different execution types, the output shape is determined by the <code>output_qubit</code> argument, provided in the instantiation of the model. In case of <code>density</code> the partial density matrix is returned.</p>"},{"location":"usage/#noise","title":"Noise","text":"<p>Noise can be added to the model by providing a <code>noise_params</code> argument, when calling the model, which is a dictionary with following keys</p> <ul> <li><code>BitFlip</code></li> <li><code>PhaseFlip</code></li> <li><code>AmplitudeDamping</code></li> <li><code>PhaseDamping</code></li> <li><code>Depolarizing</code></li> <li><code>MultiQubitDepolarizing</code></li> <li><code>StatePreparation</code></li> <li><code>Measurement</code></li> </ul> <p>with values between \\(0\\) and \\(1\\). Additionally, a <code>GateError</code> can be applied, which controls the variance of a Gaussian distribution with zero mean applied on the input vector.</p> <p>While <code>BitFlip</code>, <code>PhaseFlip</code>, <code>Depolarizing</code> and <code>GateError</code>s are applied on each gate, <code>AmplitudeDamping</code>, <code>PhaseDamping</code>, <code>StatePreparation</code> and <code>Measurement</code> are applied on the whole circuit.</p> <p>Furthermore, <code>ThermalRelaxation</code> can be applied.  Instead of the probability, the entry for this type of error consists of another dict with the keys:</p> <ul> <li><code>t1</code>: The relative T1 relaxation time (a typical value might be \\(180\\mathrm{us}\\))</li> <li><code>t2</code>: The relative T2 relaxation time (a typical value might be \\(100\\mathrm{us}\\))</li> <li><code>t_factor</code>: The relative gate time factor (a typical value might be \\(0.018\\mathrm{us}\\))</li> </ul> <p>The units can be ignored as we are only interested in relative times, above values might belong to some superconducting system. Note that <code>t2</code> is required to be max. \\(2\\times\\)<code>t1</code>. Based on <code>t_factor</code> and the circuit depth the execution time is estimated, and therefore the influence of thermal relaxation over time.</p>"},{"location":"usage/#pulse_level_simulation","title":"Pulse Level Simulation","text":"<p>Our framework extends beyond unitary-level simulation by integrating pulse-level simulation through PennyLane\u2019s pulse module. This allows you to move from the abstract unitary layer, where gates are treated as instantaneous idealized operations, down to the physical pulse layer, where gates are represented by time-dependent microwave control fields.  </p> <p>In the pulse representation, each gate is decomposed into Gaussian-shaped pulses parameterized by:</p> <ul> <li>\\(A\\): amplitude of the pulse</li> <li>\\(\\sigma\\): width (standard deviation) of the Gaussian envelope</li> <li>\\(t\\): pulse duration</li> </ul> <p>By default, the framework provides optimized pulse parameters based on typical superconducting qubit frequencies (\\(\\omega_q = 10\\pi\\), \\(\\omega_c = 10\\pi\\)).  </p> <p>Switching between unitary-level and pulse-level execution is seamless and controlled via the <code>gate_mode</code> argument:</p> <pre><code># Default unitary-level simulation\nmodel(params, inputs)\n\n# Pulse-level simulation\nmodel(params, inputs, gate_mode=\"pulse\")\n</code></pre> <p>Pulse-level gates can also be instantiated directly:</p> <p><pre><code>from qml_essentials.ansaetze import Gates\n\n# RX gate represented by its microwave pulse\nGates.RX(w, wires=0, gate_mode=\"pulse\")\n\n# With custom pulse parameters [A, sigma, t]\npulse_params = [0.5, 0.2, 1.0]\nGates.RX(w, wires=0, pulse_params=pulse_params, gate_mode=\"pulse\")\n</code></pre> and then used in custom Ansaetze or directly as encoding gates. See our documentation on Quantum Optimal Control (QOC) for more details on how to choose pulse parameters.</p> <p>For more details:</p> <ul> <li>See Ansaetze for a deeper explanation of our pulse-level gates and ansaetze, as well as details on Quantum Optimal Control (QOC), which enables optimizing pulses directly for target unitaries.  </li> <li>See Training for how to train pulse parameters jointly with rotation angles.  </li> </ul>"},{"location":"usage/#multithreading_using_jax","title":"Multithreading (using JAX)","text":"<p>Our framework can parallelise the execution of the model setting the <code>use_multithreading</code> flag (defaults to False). In our framework, JAX then automatically handles the number and distribution of the workers depending on the batch sizes and available CPUs. <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    use_multithreading=True,\n)\n</code></pre></p> <p>Depending your machine, this can result in a significant speedup. Note however, that this is currently only available for <code>n_qubits&lt;model.lightning_threshold</code> which is 12 by default. Above this threshold, Pennylane's <code>lightning.qubit</code> device is used which would interfere with an additional parallelism.</p> <p>Mutlithreading works for both parameters and inputs, meaning that if a batched input is provided, processing will be parallelized in the same way as explained above. Note, that if both, parameters and inputs are batched with size <code>B_I</code> and <code>B_P</code> respectively, the effective batch dimension will multiply, i.e. resulting in <code>B_I * B_P</code> combinations.  Internally, these combinations will be flattened during processing and then reshaped to the original shape afterwards, such that the output shape is <code>[O, B_I, B_P]</code>. Here, <code>O</code> is the general output shape depending on the execution type, <code>B_I</code> is the batch dimension of the inputs and <code>B_P</code> is the batch dimension of the parameters. This shape is also available as a property of the model: <code>model.batch_shape</code>. Note, that the output shape is always squeezed, i.e. batch axes will be suppressed if their dimension is 1. Also, there is a third batch axis in <code>model.batch_shape</code> for pulse parameters. See more on that topic in Ansaetze.</p> <p>In addition to letting the model handle repeating the batch axes, it is also possible to disable this functionality by setting <code>repeat_batch_axis</code> upon model initialization. This parameter is an array of boolean values determining of the corresponding axis in the <code>batch_shape</code> (#Inputs, #Params, #PulseParams)should be repeated. Of course, when providing the batch manually, the dimensions have to match.</p> <p><pre><code>model = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    repeat_batch_axis=[False, True, True],\n    use_multithreading=True,\n)\n\nkey = jax.random.key(1000)\nkey = model.initialize_params(key, repeat=10)\nmodel(inputs=random.uniform(key, (10, 1)))\n</code></pre> In this example, instead of a batch size of <code>100</code>, the output will have a batch size of <code>10</code> instead (shape <code>(10,2)</code>).</p> <p>For density matrix calculations, we computed the speedup of a multi-threaded computation over a single-threaded computation with a 4 qubit circuit, averaged over 8 runs, as shown in the following figure.</p> <p> </p> <p>The computation was performed on a 16 core CPU with 32GB of RAM.</p> <p>As shown in the following figure, computing the expectation value is significantly easier, with no, or only a small speedup over the single-threaded computation.</p> <p> </p> <p>The commands used to generate the plots above are: <pre><code>cd docs &amp;&amp; uv run python mp_experiment.py --execution_type=\"expval\" --min_n_samples=\"3000\" --max_n_samples=\"60000\" --n_samples=\"3000\" --n_qubits=\"6\" --n_layers=\"1\"\n</code></pre> and <pre><code>cd docs &amp;&amp; uv run python mp_experiment.py --execution_type=\"density\" --min_n_samples=\"500\" --max_n_samples=\"10000\" --n_samples=\"500\" --n_qubits=\"6\" --n_layers=\"1\"\n</code></pre> respectively.</p>"},{"location":"usage/#quantikz_export","title":"Quantikz Export","text":"<p>In addition to the printing the model to console and into a figure using matplotlib (thanks to Pennylane); our framework extends this functionality by allowing you to create nice Quantikz figures that you can embedd in a Latex document . This can be achieved by </p> <pre><code>fig = model.draw(figure=\"tikz\", inputs_symbols=\"x\", gate_values=False)\nfig.export(\"tikz_circuit.tex\", full_document=True)\n</code></pre> <p> </p> <p>Inputs are represented with \"x\" by default, which can be changed by adjusting the optional parameter <code>inputs_symbols</code>. If you want to see the actual gate values instead of variables, simply set <code>gate_values=True</code> which is also the default option. The returned <code>fig</code> variable is a <code>TikzFigure</code> object that stores the Latex string and allows exporting to a specified file. To create a document that can be compiled, simply pass <code>full_document=True</code> when calling <code>export</code>.</p>"}]}