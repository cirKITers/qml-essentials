{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A toolbox to make working with QML models easier. <p>This repo contains some of the commonly used Ansaetze and coding stuff required for working with QML and Data-Reuploading models. There are also dedicated classes to calculate entanglement and expressiblity of a provided model as well as its Fourier coefficients.</p> <p>Curious?  Installing this package is as simple as with any other package </p> <p><code>pip install qml-essentials</code></p> <p>Or, if you prefer poetry:</p> <p><code>poetry add qml-essentials</code></p> <p>Once you have set things up, go ahead and checkout how to use qml-essentials.</p> <p>If you want to contribute, please refer to our CONTRIBUTING guide on Github. Also checkout our coverage report.</p> <p>Do you want to use our software in a research project?  Please checkout the github repository and follow the instructions (\"Cite this repository\") there.</p>"},{"location":"ansaetze/","title":"Ansaetze","text":"<p>.. or Ansatzes as preferred by the english community. Anyway, we got various of the most-used Ansaetze implemented in this package. </p> <p>You can load them manually by <pre><code>from qml_essentials.ansaetze import Ansaetze\nall_ansaetze = Ansaetze.get_available()\n\nfor ansatz in all_ansaetze:\n    print(ansatz.__name__)\n</code></pre></p> <p>See the Overview at the end of this document for more details. However, usually you just want reference to them (by name) when instantiating a model. To get an overview of all the available Ansaetze, checkout the references.</p>"},{"location":"ansaetze/#custom_ansatz","title":"Custom Ansatz","text":"<p>If you want to implement your own ansatz, you can do so by inheriting from the <code>Circuit</code> class: <pre><code>import pennylane as qml\nfrom qml_essentials.ansaetze import Circuit\n\nclass MyHardwareEfficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        w_idx = 0\n        for q in range(n_qubits):\n            qml.RY(w[w_idx], wires=q)\n            w_idx += 1\n            qml.RZ(w[w_idx], wires=q)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                qml.CZ(wires=[q, q + 1])\n</code></pre></p> <p>and then pass it to the model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n)\n</code></pre></p> <p>Checkout page Usage on how to proceed from here.</p>"},{"location":"ansaetze/#custom_encoding","title":"Custom Encoding","text":"<p>On model instantiation, you can choose how your inputs are encoded. The default encoding is \"RX\" which will result in a single RX rotation per qubit. You can change this behavior, by setting the optional <code>encoding</code> argument to - a string or a list of strings where each is checked agains the <code>Gates</code> class - a callable or a list of callables</p> <p>A callable must take an input, the wire where it's acting on and an optional noise_params dictionary. Let's look at an example, where we wan't to encode a two-dimensional input: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.ansaetze import Gates\n\ndef MyCustomEncoding(w, wires, noise_params=None):\n    Gates.RX(w[0], wires, noise_params=noise_params)\n    Gates.RY(w[1], wires, noise_params=noise_params)\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n    encoding=MyCustomEncoding,\n)\n\nmodel(inputs=[1, 2])\n</code></pre></p>"},{"location":"ansaetze/#noise","title":"Noise","text":"<p>You might have noticed, that the <code>build</code> method takes an additional input <code>noise_params</code>, which we did not used so far. In general, all of the Ansatzes, that are implemented in this package allow this additional input which is a dictionary containing all the noise parameters of the circuit (here all with probability \\(0.0\\)): <pre><code>noise_params = {\n    \"BitFlip\": 0.0,\n    \"PhaseFlip\": 0.0,\n    \"AmplitudeDamping\": 0.0,\n    \"PhaseDamping\": 0.0,\n    \"Depolarizing\": 0.0,\n    \"MultiQubitDepolarizing\": 0.0,\n}\n</code></pre></p> <p>Providing this optional input will apply the corresponding noise to the model where the Bit Flip, Phase Flip, Depolarizing and Two-Qubit Depolarizing Channels are applied after each gate and the Amplitude and Phase Damping are applied at the end of the circuit. To achieve this, we implement our own set of noisy gates, that build upon the Pennylane gates. To demonstrate this, let's extend our example above: <pre><code>from qml_essentials.ansaetze import Gates, Circuit\n\nclass MyNoisyHardwareEfficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(wires=[q, q + 1], noise_params=noise_params)\n</code></pre></p> <p>As you can see, we slightly modified the example, by importing the <code>Gates</code> class from <code>ansaetze</code> and by adding the <code>noise_params</code> input to each of the gates. When using a noisy circuit, make sure to run the model with the <code>density</code> execution type: <pre><code>model(\n    model.params,\n    inputs=None,\n    execution_type=\"density\",\n    noise_params={\n        \"BitFlip\": 0.01,\n        \"PhaseFlip\": 0.02,\n        \"AmplitudeDamping\": 0.03,\n        \"PhaseDamping\": 0.04,\n        \"Depolarizing\": 0.05,\n        \"MultiQubitDepolarizing\": 0.06\n})\n</code></pre></p>"},{"location":"ansaetze/#overview","title":"Overview","text":"<p>This section shows an overview of all the available Ansaetze in our package. Most of the circuits are implemented according to to the original paper by Sim et al.. Note that Circuit 10 deviates from the original implementation!</p> <p>Oh and in case you need a refresh on the rotational axes and their corresponding states, here is a Bloch sphere  :</p> <p></p>"},{"location":"ansaetze/#no_ansatz","title":"No Ansatz","text":""},{"location":"ansaetze/#circuit_1","title":"Circuit 1","text":""},{"location":"ansaetze/#circuit_2","title":"Circuit 2","text":""},{"location":"ansaetze/#circuit_3","title":"Circuit 3","text":""},{"location":"ansaetze/#circuit_4","title":"Circuit 4","text":""},{"location":"ansaetze/#circuit_6","title":"Circuit 6","text":""},{"location":"ansaetze/#circuit_9","title":"Circuit 9","text":""},{"location":"ansaetze/#circuit_10","title":"Circuit 10","text":""},{"location":"ansaetze/#circuit_15","title":"Circuit 15","text":""},{"location":"ansaetze/#circuit_16","title":"Circuit 16","text":""},{"location":"ansaetze/#circuit_17","title":"Circuit 17","text":""},{"location":"ansaetze/#circuit_18","title":"Circuit 18","text":""},{"location":"ansaetze/#circuit_19","title":"Circuit 19","text":""},{"location":"ansaetze/#no_entangling","title":"No Entangling","text":""},{"location":"ansaetze/#strongly_entangling","title":"Strongly Entangling","text":""},{"location":"ansaetze/#hardware_efficient","title":"Hardware Efficient","text":""},{"location":"ansaetze/#ghz","title":"GHZ","text":""},{"location":"coefficients/","title":"Coefficients","text":"<p>A characteristic property of any Fourier model are its coefficients. Our package can, given a model, calculate the corresponding coefficients.</p> <p>In the simplest case, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.coefficients import Coefficients\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\ncoeffs = Coefficients.get_spectrum(model)\n</code></pre></p> <p>But wait! There is much more to this. Let's keep on reading if you're curious .</p>"},{"location":"coefficients/#detailled_explanation","title":"Detailled Explanation","text":"<p>To visualize what happens, let's create a very simplified Fourier model <pre><code>class Model_Fct:\n    def __init__(self, c, f):\n        self.c = c\n        self.f = f\n        self.degree = max(f)\n\n    def __call__(self, inputs, **kwargs):\n        return np.sum([c * np.cos(inputs * f) for f, c in zip(self.f, self.c)], axis=0)\n</code></pre></p> <p>This model takes a vector of coefficients and frequencies on instantiation. When called, these coefficients and frequencies are used to compute the output of the model, which is the sum of sine functions determined by the length of the vectors. Let's try that for just two frequencies:</p> <pre><code>freqs = [1,3]\ncoeffs = [1,1]\n\nfs = max(freqs) * 2 + 1\nmodel_fct = Model_Fct(coeffs,freqs)\n\nx = np.arange(0,2 * np.pi, 2 * np.pi/fs)\nout = model_fct(x)\n</code></pre> <p>We can now calculate the Fast Fourier Transform of our model: <pre><code>X = np.fft.fft(out) / len(out)\nX_shift = np.fft.fftshift(X)\nX_freq = np.fft.fftfreq(X.size, 1/fs)\nX_freq_shift = np.fft.fftshift(X_freq)\n</code></pre> Note that calling <code>np.fft.fftshift</code> is not required from a technical point of view, but makes our spectrum nicely zero-centered and projected correctly.</p> <p> </p> <p>The same can be done with our framework, with a neat one-liner: <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, shift=True)\n</code></pre></p> <p> </p> <p>Note, that applying the shift can be controlled with the optional <code>shift</code> argument.</p> <p>Another important point is, that the <code>force_mean</code> flag is set, and the <code>execution_type</code> is is implicitly set to <code>expval</code>. This is mainly because, we require a single expectation value to calculate the coefficients.</p>"},{"location":"coefficients/#increasing_the_resolution","title":"Increasing the Resolution","text":"<p>You might have noticed that we choose our sampling frequency <code>fs</code> in such a way, that it just fulfills the Nyquist criterium. Also the number of samples <code>x</code> are just enough to sufficiently represent our function. In such a simplified scenario, this is fine, but there are cases, where we want to have more information both in the time and frequency domain. Therefore, two additional arguments exist in the <code>get_spectrum</code> method: - <code>mfs</code>: The multiplier for the highest frequency. Increasing this will increase the width of the spectrum - <code>mts</code>: The multiplier for the number of time samples. Increasing this will increase the resolution of the time domain and therefore \"add\" frequencies in between our original frequencies. - <code>trim</code>: Whether to remove the Nyquist frequency if spectrum is even. This will result in a symmetric spectrum</p> <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, mfs=2, mts=3, shift=True)\n</code></pre> <p> </p> <p>Note that, as the frequencies change with the <code>mts</code> argument, we have to take that into account when calculating the frequencies with the last call.</p> <p>Feel free to checkout our jupyter notebook if you would like to play around with this.</p> <p>A sidenote on the performance; Increasing the <code>mts</code> value effectively increases the input lenght that goes into the model. This means that <code>mts=2</code> will require twice the time to compute, which will be very noticable when running noisy simulations.</p>"},{"location":"coefficients/#power_spectral_density","title":"Power spectral density","text":"<p>In some cases it can be useful to get the power spectral density (PSD). As calculation of this metric might differ between the different research domains, we included a function to get the PSD of a given spectrum using the following formula:</p> \\[PSD = \\frac{2 (\\mathrm{Re}(F)^2+\\mathrm{Im}(F)^2)}{n_\\text{samples}^2}\\] <p>where \\(F\\) is the spectrum and \\(n_\\text{samples}\\) the length of the input vector.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p> </p>"},{"location":"coefficients/#analytic_coefficients","title":"Analytic Coefficients","text":"<p>All of the calculations above were performed by applying a Fast Fourier Transform to the output of our Model. However, we can also calculate the coefficients analytically.</p> <p>This can be achieved by the so called <code>FourierTree</code> class: <pre><code>from qml_essentials.coefficients import FourierTree\n\nfourier_tree = FourierTree(model)\nan_coeffs, an_freqs = fourier_tree.get_spectrum(force_mean=True)\n</code></pre></p> <p>Note that while this takes significantly longer to compute, it gives us the precise coefficients, solely depending on the parameters. We can verify this by comparing it to the previous results:</p> <p> </p>"},{"location":"coefficients/#technical_details","title":"Technical Details","text":"<p>We use an approach developed by Nemkov et al., which was later extended by Wiedmann et al.. The implementation is also inspired by the corresponding code for Nemkov et al.'s paper.</p> <p>In Nemkov et al.'s algorithm the first step is to separate Clifford and non-Clifford gates, such that all Clifford gates can be regarded as part of the observable, and the actual circuit only consists of Pauli rotations (cf. qml_essentials.utils.PauliCircuit). The main idea is then to split each Pauli rotation into sine and cosine product terms to obtain the coefficients, which are only dependent on the parameters of the circuit.</p> <p>Currently, our implementation supports only one input feature, albeit more are theoretical possible.</p>"},{"location":"coefficients/#multi-dimensional_coefficients","title":"Multi-Dimensional Coefficients","text":"<p>The <code>get_spectrum</code> method can also be used to calculate the coefficients of a model with multiple input dimensions. This feature can be enabled, by explicitly providing an encoding that supports multi-dimensional input, e.g. a list of single encodings (see Usage for details on how encodings are applied).  Currently, only the FFT-based method supports this.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000,\n    encoding=[\"RX\", \"RY\"]\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1\n, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p>Using a logarithmic color bar, one obtains the following 2D-spectrum:</p> <p> </p> <p>Note that \"X1\" refers to the \"RX\" encoding and \"X2\" to the \"RY\" encoding.</p>"},{"location":"entanglement/","title":"Entanglement","text":"<p>As one of the fundamental aspects of quantum computing, entanglement plays also an important role in quantum machine learning. Our package offers various methods for calculating the entangling capability of a particular model.</p>"},{"location":"entanglement/#meyer-wallach","title":"Meyer-Wallach","text":"<p>In the simplest case, using the Meyer-Wallach measure, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.entanglement import Entanglement\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\nent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000\n)\n</code></pre></p> <p>Here, <code>n_samples</code> is the number of samples for the parameters, sampled according to the default initialization strategy of the model, and <code>seed</code> is the random number generator seed.</p> <p>Note, that every function in this class accepts keyword-arguments which are being passed to the model call, so you could e.g. enable caching by</p> <pre><code>ent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000, cache=True\n)\n</code></pre> <p>If you set <code>n_samples=None</code>, we will use the currently stored parameters of the model to estimate the degree of entanglement.</p>"},{"location":"entanglement/#bell-measurement","title":"Bell-Measurement","text":"<p>An alternate method for calculating the entangling capability is the Bell-Measurement method. We can utilize this by</p> <pre><code>ent_cap = Entanglement.bell_measurements(\n    model, n_samples=1000, seed=1000\n)\n</code></pre>"},{"location":"entanglement/#relative_entropy","title":"Relative Entropy","text":"<p>While calculating entanglement using the Meyer-Wallach or Bell-Measurements method works great for noiseless circuits, it won't result in the correct values when being used together with incoherent noise. To account for this, you can use the Relative Entropy method as follows: </p> <pre><code>ent_cap = Entanglement.relative_entropy(\n    model, n_samples=1000, n_sigmas=10, seed=1000, noise_params={\"BitFlip\": 0.1}\n)\n</code></pre> <p>Note that this method takes an additional parameter <code>n_sigmas</code>, which is the number of density matrices of the next separable state that we use for comparison. The runtime scales with <code>n_sigmas</code>\\(\\times\\)<code>n_samples</code> and both increase exponentially if <code>scale=True</code> is set.</p> <p>Internally, we compare the states, obtained from the PQC, against those from a GHZ state of the same size (which we consider the next separable state). This approach is explained in detail in this paper and illustrated in the following figure:</p> <p></p>"},{"location":"entanglement/#entanglement_of_formation","title":"Entanglement of Formation","text":"<p>Another possibility to compute the entanglement of a noisy circuit is the Entanglement of Formation. Similar to the relative entropy of entanglement, this measure presents an approximation, and can be used via:</p> <pre><code>ent_cap = Entanglement.entanglement_of_formation(\n    model, n_samples=1000, seed=1000, noise_params={\"BitFlip\": 0.1}\n)\n</code></pre> <p>For a technical description we refer to the review by Plenio and Virmani. The general idea is that a mixed state gets decomposed into pure states with respective probabilities using the eigendecomposition of the density matrix. Then, entanglement is computed for each pure state, weighted by the eigenvalue. In our implementation, we use the Meyer-Wallach measure for this purpose.</p> <p>Note however, that the decomposition is not unique! Therefore, this measure presents the entanglement for some decomposition into pure states, not necessarily the one that is anticipated when applying the Kraus channels. This becomes particularly evident, when computing the entanglement of a noisy GHZ-circuit. To prevent unintended decompositions for pure states, the methods of EF and Meyer-Wallach are equivalent for these.</p>"},{"location":"expressibility/","title":"Expressibility","text":"<p>Our package allows you estimate the expressiblity of a given model. <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"HardwareEfficient\",\n)\n\ninput_domain, bins, dist_circuit = Expressibility.state_fidelities(\n    seed=1000,\n    n_samples=200,\n    n_bins=10,\n    n_input_samples=5,\n    input_domain=[0, 2*np.pi],\n    model=model,\n)\n</code></pre></p> <p>Here, <code>n_bins</code> is the number of bins that you want to use in the histogram, <code>n_samples</code> is the number of parameter sets to generate (using the default initialization strategy of the model), <code>n_input_samples</code> is the number of samples for the input domain in \\([0, 2\\pi]\\), and <code>seed</code> is the random number generator seed.</p> <p>Note that <code>state_fidelities</code> accepts keyword arguments that are being passed to the model call. This allows you to utilize e.g. caching.</p> <p>Next, you can calculate the Haar integral (as reference), by <pre><code>input_domain, dist_haar = Expressibility.haar_integral(\n    n_qubits=2,\n    n_bins=10,\n    cache=True,\n)\n</code></pre></p> <p>Finally, the Kullback-Leibler divergence allows you to see how well the particular circuit performs compared to the Haar integral: <pre><code>kl_dist = Expressibility.kullback_leibler_divergence(dist_circuit, dist_haar).mean()\n</code></pre></p>"},{"location":"references/","title":"References","text":""},{"location":"references/#ansaetze","title":"Ansaetze","text":"<pre><code>from qml_essentials.ansaetze import Ansaetze\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Ansaetze:\n\n    def get_available():\n        return [\n            Ansaetze.No_Ansatz,\n            Ansaetze.Circuit_1,\n            Ansaetze.Circuit_2,\n            Ansaetze.Circuit_3,\n            Ansaetze.Circuit_4,\n            Ansaetze.Circuit_6,\n            Ansaetze.Circuit_9,\n            Ansaetze.Circuit_10,\n            Ansaetze.Circuit_15,\n            Ansaetze.Circuit_16,\n            Ansaetze.Circuit_17,\n            Ansaetze.Circuit_18,\n            Ansaetze.Circuit_19,\n            Ansaetze.No_Entangling,\n            Ansaetze.Strongly_Entangling,\n            Ansaetze.Hardware_Efficient,\n            Ansaetze.GHZ,\n        ]\n\n    class No_Ansatz(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            pass\n\n    class GHZ(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            Gates.H(0, noise_params=noise_params)\n\n            for q in range(n_qubits - 1):\n                Gates.CX([q, q + 1], noise_params=noise_params)\n\n    class Hardware_Efficient(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Hardware Efficient Ansatz.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &lt; 2:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 3\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Hardware-Efficient ansatz, as proposed in\n            https://arxiv.org/pdf/2309.03279\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CX(\n                        wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n                    )\n                if n_qubits &gt; 2:\n                    Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n\n    class Circuit_19(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_19.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit19 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_18(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_18.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit18 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_15(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_15.\n\n            The number of parameters is 2 times the number of qubits.\n            A warning is logged if the number of qubits is less than 2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 2\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit15 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n    class Circuit_9(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_9.\n\n            The number of parameters is equal to the number of qubits.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            return n_qubits\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit9 ansatz.\n\n            Length of flattened vector must be n_qubits\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.H(wires=q, noise_params=noise_params)\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CZ(\n                        wires=[n_qubits - q - 2, n_qubits - q - 1],\n                        noise_params=noise_params,\n                    )\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_6(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_6.\n\n            The total number of parameters is n_qubits*3+n_qubits**2, which is\n            the number of rotations n_qubits*3 plus the number of entangling gates\n            n_qubits**2.\n\n            If n_qubits is 1, the number of parameters is 4, and a warning is logged\n            since no entanglement is possible.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3 + n_qubits**2\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 4\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit6 ansatz.\n\n            Length of flattened vector must be\n                n_qubits*4+n_qubits*(n_qubits-1) =\n                n_qubits*3+n_qubits**2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size\n                    n_layers*(n_qubits*3+n_qubits**2)\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for ql in range(n_qubits):\n                    for q in range(n_qubits):\n                        if q == ql:\n                            continue\n                        Gates.CRX(\n                            w[w_idx],\n                            wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                            noise_params=noise_params,\n                        )\n                        w_idx += 1\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_1(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_1.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit1 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_2(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_2.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit2 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CX(\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n\n    class Circuit_3(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Calculates the number of parameters per layer for Circuit3.\n\n            The number of parameters per layer is given by the number of qubits, with\n            each qubit contributing 3 parameters. The last qubit only contributes 2\n            parameters because it is the target qubit for the controlled gates.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit3 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_4(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit4 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_10(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n            The number of parameters is calculated as n_qubits*2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit10 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            # constant gates, independent of layers. has to be fixed\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CZ(\n                        wires=[\n                            (n_qubits - q - 2) % n_qubits,\n                            (n_qubits - q - 1) % n_qubits,\n                        ],\n                        noise_params=noise_params,\n                    )\n                if n_qubits &gt; 2:\n                    Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_16(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit16 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_17(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit17 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Strongly_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Strongly Entangling ansatz.\n\n            The number of parameters is calculated as n_qubits*6.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &lt; 2:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 6\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n            \"\"\"\n            Creates a Strongly Entangling ansatz.\n\n            Length of flattened vector must be n_qubits*6\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*6\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[q, (q + n_qubits // 2) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n    class No_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the NoEntangling ansatz.\n\n            The number of parameters is calculated as n_qubits*3.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a circuit without entangling, but with U3 gates on all qubits\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1","title":"<code>Circuit_1</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_1(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_1.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit1 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit1 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit1 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_1.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_1.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10","title":"<code>Circuit_10</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_10(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n        The number of parameters is calculated as n_qubits*2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit10 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        # constant gates, independent of layers. has to be fixed\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[\n                        (n_qubits - q - 2) % n_qubits,\n                        (n_qubits - q - 1) % n_qubits,\n                    ],\n                    noise_params=noise_params,\n                )\n            if n_qubits &gt; 2:\n                Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit10 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit10 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    # constant gates, independent of layers. has to be fixed\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[\n                    (n_qubits - q - 2) % n_qubits,\n                    (n_qubits - q - 1) % n_qubits,\n                ],\n                noise_params=noise_params,\n            )\n        if n_qubits &gt; 2:\n            Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_10 ansatz.</p> <p>The number of parameters is calculated as n_qubits*2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n    The number of parameters is calculated as n_qubits*2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2  # constant gates not considered yet. has to be fixed\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15","title":"<code>Circuit_15</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_15(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_15.\n\n        The number of parameters is 2 times the number of qubits.\n        A warning is logged if the number of qubits is less than 2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 2\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit15 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit15 ansatz.</p> <p>Length of flattened vector must be n_qubits*2 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit15 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_15.</p> <p>The number of parameters is 2 times the number of qubits. A warning is logged if the number of qubits is less than 2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_15.\n\n    The number of parameters is 2 times the number of qubits.\n    A warning is logged if the number of qubits is less than 2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 2\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16","title":"<code>Circuit_16</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_16(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit16 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit16 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit16 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_16 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17","title":"<code>Circuit_17</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_17(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit17 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit17 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit17 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_17 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18","title":"<code>Circuit_18</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_18(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_18.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit18 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit18 ansatz.</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit18 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_18.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_18.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19","title":"<code>Circuit_19</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_19(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_19.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit19 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit19 ansatz.</p> <p>Length of flattened vector must be n_qubits*3 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit19 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_19.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_19.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2","title":"<code>Circuit_2</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_2(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_2.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit2 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit2 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit2 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CX(\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_2.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_2.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3","title":"<code>Circuit_3</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_3(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Calculates the number of parameters per layer for Circuit3.\n\n        The number of parameters per layer is given by the number of qubits, with\n        each qubit contributing 3 parameters. The last qubit only contributes 2\n        parameters because it is the target qubit for the controlled gates.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit3 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit3 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit3 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Calculates the number of parameters per layer for Circuit3.</p> <p>The number of parameters per layer is given by the number of qubits, with each qubit contributing 3 parameters. The last qubit only contributes 2 parameters because it is the target qubit for the controlled gates.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Calculates the number of parameters per layer for Circuit3.\n\n    The number of parameters per layer is given by the number of qubits, with\n    each qubit contributing 3 parameters. The last qubit only contributes 2\n    parameters because it is the target qubit for the controlled gates.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4","title":"<code>Circuit_4</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_4(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit4 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit4 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit4 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_4 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6","title":"<code>Circuit_6</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_6(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_6.\n\n        The total number of parameters is n_qubits*3+n_qubits**2, which is\n        the number of rotations n_qubits*3 plus the number of entangling gates\n        n_qubits**2.\n\n        If n_qubits is 1, the number of parameters is 4, and a warning is logged\n        since no entanglement is possible.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3 + n_qubits**2\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 4\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit6 ansatz.\n\n        Length of flattened vector must be\n            n_qubits*4+n_qubits*(n_qubits-1) =\n            n_qubits*3+n_qubits**2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size\n                n_layers*(n_qubits*3+n_qubits**2)\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for ql in range(n_qubits):\n                for q in range(n_qubits):\n                    if q == ql:\n                        continue\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit6 ansatz.</p> <p>Length of flattened vector must be     n_qubits4+n_qubits(n_qubits-1) =     n_qubits3+n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size         n_layers(n_qubits3+n_qubits**2) n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit6 ansatz.\n\n    Length of flattened vector must be\n        n_qubits*4+n_qubits*(n_qubits-1) =\n        n_qubits*3+n_qubits**2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size\n            n_layers*(n_qubits*3+n_qubits**2)\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for ql in range(n_qubits):\n            for q in range(n_qubits):\n                if q == ql:\n                    continue\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_6.</p> <p>The total number of parameters is n_qubits3+n_qubits2, which is the number of rotations n_qubits3 plus the number of entangling gates n_qubits**2.</p> <p>If n_qubits is 1, the number of parameters is 4, and a warning is logged since no entanglement is possible.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_6.\n\n    The total number of parameters is n_qubits*3+n_qubits**2, which is\n    the number of rotations n_qubits*3 plus the number of entangling gates\n    n_qubits**2.\n\n    If n_qubits is 1, the number of parameters is 4, and a warning is logged\n    since no entanglement is possible.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3 + n_qubits**2\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 4\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9","title":"<code>Circuit_9</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_9(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_9.\n\n        The number of parameters is equal to the number of qubits.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        return n_qubits\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit9 ansatz.\n\n        Length of flattened vector must be n_qubits\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.H(wires=q, noise_params=noise_params)\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[n_qubits - q - 2, n_qubits - q - 1],\n                    noise_params=noise_params,\n                )\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit9 ansatz.</p> <p>Length of flattened vector must be n_qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit9 ansatz.\n\n    Length of flattened vector must be n_qubits\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.H(wires=q, noise_params=noise_params)\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[n_qubits - q - 2, n_qubits - q - 1],\n                noise_params=noise_params,\n            )\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_9.</p> <p>The number of parameters is equal to the number of qubits.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_9.\n\n    The number of parameters is equal to the number of qubits.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    return n_qubits\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient","title":"<code>Hardware_Efficient</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Hardware_Efficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Hardware Efficient Ansatz.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &lt; 2:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Hardware-Efficient ansatz, as proposed in\n        https://arxiv.org/pdf/2309.03279\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n            for q in range((n_qubits - 1) // 2):\n                Gates.CX(\n                    wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n                )\n            if n_qubits &gt; 2:\n                Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Hardware-Efficient ansatz, as proposed in https://arxiv.org/pdf/2309.03279</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Hardware-Efficient ansatz, as proposed in\n    https://arxiv.org/pdf/2309.03279\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n        for q in range((n_qubits - 1) // 2):\n            Gates.CX(\n                wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n            )\n        if n_qubits &gt; 2:\n            Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Hardware Efficient Ansatz.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Hardware Efficient Ansatz.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &lt; 2:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling","title":"<code>No_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class No_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the NoEntangling ansatz.\n\n        The number of parameters is calculated as n_qubits*3.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a circuit without entangling, but with U3 gates on all qubits\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a circuit without entangling, but with U3 gates on all qubits</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a circuit without entangling, but with U3 gates on all qubits\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the NoEntangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*3.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the NoEntangling ansatz.\n\n    The number of parameters is calculated as n_qubits*3.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling","title":"<code>Strongly_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Strongly_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Strongly Entangling ansatz.\n\n        The number of parameters is calculated as n_qubits*6.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &lt; 2:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 6\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n        \"\"\"\n        Creates a Strongly Entangling ansatz.\n\n        Length of flattened vector must be n_qubits*6\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*6\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[q, (q + n_qubits // 2) % n_qubits],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Strongly Entangling ansatz.</p> <p>Length of flattened vector must be n_qubits*6</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*6 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n    \"\"\"\n    Creates a Strongly Entangling ansatz.\n\n    Length of flattened vector must be n_qubits*6\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*6\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[q, (q + n_qubits // 2) % n_qubits],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Strongly Entangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*6.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Strongly Entangling ansatz.\n\n    The number of parameters is calculated as n_qubits*6.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &lt; 2:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 6\n</code></pre>"},{"location":"references/#gates","title":"Gates","text":"<pre><code>from qml_essentials.ansaetze import Gates\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Gates:\n    rng = np.random.default_rng()\n\n    @staticmethod\n    def init_rng(seed: int):\n        \"\"\"\n        Initializes the random number generator with the given seed.\n\n        Parameters\n        ----------\n        seed : int\n            The seed for the random number generator.\n        \"\"\"\n        Gates.rng = np.random.default_rng(seed)\n\n    @staticmethod\n    def NQubitDepolarizingChannel(p, wires):\n        \"\"\"\n        Generates the Kraus operators for an n-qubit depolarizing channel.\n\n        The n-qubit depolarizing channel is defined as:\n            E(rho) = sqrt(1 - p * (4^n - 1) / 4^n) * rho\n                + sqrt(p / 4^n) * \u2211_{P \u2260 I^{\u2297n}} P rho P\u2020\n        where the sum is over all non-identity n-qubit Pauli operators\n        (i.e., tensor products of {I, X, Y, Z} excluding the identity operator I^{\u2297n}).\n        Each Pauli error operator is weighted equally by p / 4^n.\n\n        This operator-sum (Kraus) representation models uniform depolarizing noise\n        acting on n qubits simultaneously. It is useful for simulating realistic\n        multi-qubit noise affecting entangling gates in noisy quantum circuits.\n\n        Parameters\n        ----------\n        p : float\n            The total probability of an n-qubit depolarizing error occurring.\n            Must satisfy 0 \u2264 p \u2264 1.\n\n        wires : Sequence[int]\n            The list of qubit indices (wires) on which the channel acts.\n            Must contain at least 2 qubits.\n\n        Returns\n        -------\n        qml.QubitChannel\n            A PennyLane QubitChannel constructed from the Kraus operators representing\n            the n-qubit depolarizing noise channel acting on the specified wires.\n        \"\"\"\n        def n_qubit_depolarizing_kraus(p: float, n: int) -&gt; List[np.ndarray]:\n            if not (0.0 &lt;= p &lt;= 1.0):\n                raise ValueError(f\"Probability p must be between 0 and 1, got {p}\")\n            if n &lt; 2:\n                raise ValueError(f\"Number of qubits must be &gt;= 2, got {n}\")\n\n            Id = np.eye(2)\n            X = qml.matrix(qml.PauliX(0))\n            Y = qml.matrix(qml.PauliY(0))\n            Z = qml.matrix(qml.PauliZ(0))\n            paulis = [Id, X, Y, Z]\n\n            dim = 2 ** n\n            all_ops = []\n\n            # Generate all n-qubit Pauli tensor products:\n            for indices in itertools.product(range(4), repeat=n):\n                P = np.eye(1)\n                for idx in indices:\n                    P = np.kron(P, paulis[idx])\n                all_ops.append(P)\n\n            # Identity operator corresponds to all zeros indices (Id^n)\n            K0 = np.sqrt(1 - p * (4 ** n - 1) / (4 ** n)) * np.eye(dim)\n\n            kraus_ops = []\n            for i, P in enumerate(all_ops):\n                if i == 0:\n                    # Skip the identity, already handled as K0\n                    continue\n                kraus_ops.append(np.sqrt(p / (4 ** n)) * P)\n\n            return [K0] + kraus_ops\n\n        return qml.QubitChannel(n_qubit_depolarizing_kraus(p, len(wires)), wires=wires)\n\n    @staticmethod\n    def Noise(\n        wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n    ) -&gt; None:\n        \"\"\"\n        Applies noise to the given wires.\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the noise to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n            -BitFlip: Applies a bit flip error to the given wires.\n            -PhaseFlip: Applies a phase flip error to the given wires.\n            -Depolarizing: Applies a depolarizing channel error to the\n                given wires.\n            -MultiQubitDepolarizing: Applies a two-qubit depolarizing channel\n                error to the given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        if noise_params is not None:\n            if isinstance(wires, int):\n                wires = [wires]  # single qubit gate\n\n            # noise on single qubits\n            for wire in wires:\n                qml.BitFlip(noise_params.get(\"BitFlip\", 0.0), wires=wire)\n                qml.PhaseFlip(noise_params.get(\"PhaseFlip\", 0.0), wires=wire)\n                qml.DepolarizingChannel(\n                    noise_params.get(\"Depolarizing\", 0.0), wires=wire\n                )\n\n            # noise on two-qubits\n            if len(wires) &gt; 1:\n                p = noise_params.get(\"MultiQubitDepolarizing\", 0.0)\n                if p &gt; 0:\n                    Gates.NQubitDepolarizingChannel(p, wires)\n\n    @staticmethod\n    def GateError(\n        w: float, noise_params: Optional[Dict[str, float]] = None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Applies a gate error to the given rotation angle(s).\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -GateError: Applies a normal distribution error to the rotation\n            angle. The standard deviation of the noise is specified by\n            the \"GateError\" key in the dictionary.\n\n            All parameters are optional and default to 0.0 if not provided.\n\n        Returns\n        -------\n        float\n            The modified rotation angle after applying the gate error.\n        \"\"\"\n        if (\n            noise_params is not None\n            and noise_params.get(\"GateError\", None) is not None\n        ):\n            w += Gates.rng.normal(0, noise_params[\"GateError\"])\n        return w\n\n    @staticmethod\n    def Rot(phi, theta, omega, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        phi : float\n            The first rotation angle in radians.\n        theta : float\n            The second rotation angle in radians.\n        omega : float\n            The third rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        if noise_params is not None and \"GateError\" in noise_params:\n            phi = Gates.GateError(phi, noise_params)\n            theta = Gates.GateError(theta, noise_params)\n            omega = Gates.GateError(omega, noise_params)\n            # phi += Gates.rng.normal(0, noise_params[\"GateError\"])\n            # theta += Gates.rng.normal(0, noise_params[\"GateError\"])\n            # omega += Gates.rng.normal(0, noise_params[\"GateError\"])\n        qml.Rot(phi, theta, omega, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RX(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the X axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.RX(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RY(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the Y axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n            given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.RY(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RZ(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the Z axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.RZ(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRX(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the X axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRX(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRY(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the Y axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRY(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRZ(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the Z axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n            given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRZ(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CX(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled NOT gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled NOT gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CNOT(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CY(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled Y gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled Y gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CY(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CZ(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled Z gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled Z gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CZ(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def H(wires, noise_params=None):\n        \"\"\"\n        Applies a Hadamard gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the Hadamard gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.Hadamard(wires=wires)\n        Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRX","title":"<code>CRX(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the X axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRX--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRX(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the X axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRX(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRY","title":"<code>CRY(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the Y axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRY--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRY(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the Y axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRY(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRZ","title":"<code>CRZ(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the Z axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRZ--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the     given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRZ(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the Z axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n        given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRZ(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CX","title":"<code>CX(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled NOT gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CX--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled NOT gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CX(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled NOT gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled NOT gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CNOT(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CY","title":"<code>CY(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled Y gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CY--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled Y gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CY(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled Y gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled Y gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CY(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CZ","title":"<code>CZ(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled Z gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CZ--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled Z gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CZ(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled Z gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled Z gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CZ(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError","title":"<code>GateError(w, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a gate error to the given rotation angle(s).</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -GateError: Applies a normal distribution error to the rotation     angle. The standard deviation of the noise is specified by     the \"GateError\" key in the dictionary.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError--returns","title":"Returns","text":"<p>float     The modified rotation angle after applying the gate error.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef GateError(\n    w: float, noise_params: Optional[Dict[str, float]] = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Applies a gate error to the given rotation angle(s).\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -GateError: Applies a normal distribution error to the rotation\n        angle. The standard deviation of the noise is specified by\n        the \"GateError\" key in the dictionary.\n\n        All parameters are optional and default to 0.0 if not provided.\n\n    Returns\n    -------\n    float\n        The modified rotation angle after applying the gate error.\n    \"\"\"\n    if (\n        noise_params is not None\n        and noise_params.get(\"GateError\", None) is not None\n    ):\n        w += Gates.rng.normal(0, noise_params[\"GateError\"])\n    return w\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.H","title":"<code>H(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a Hadamard gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.H--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the Hadamard gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef H(wires, noise_params=None):\n    \"\"\"\n    Applies a Hadamard gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the Hadamard gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.Hadamard(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.NQubitDepolarizingChannel","title":"<code>NQubitDepolarizingChannel(p, wires)</code>  <code>staticmethod</code>","text":"<p>Generates the Kraus operators for an n-qubit depolarizing channel.</p> The n-qubit depolarizing channel is defined as <p>E(rho) = sqrt(1 - p * (4^n - 1) / 4^n) * rho     + sqrt(p / 4^n) * \u2211_{P \u2260 I^{\u2297n}} P rho P\u2020</p> <p>where the sum is over all non-identity n-qubit Pauli operators (i.e., tensor products of {I, X, Y, Z} excluding the identity operator I^{\u2297n}). Each Pauli error operator is weighted equally by p / 4^n.</p> <p>This operator-sum (Kraus) representation models uniform depolarizing noise acting on n qubits simultaneously. It is useful for simulating realistic multi-qubit noise affecting entangling gates in noisy quantum circuits.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.NQubitDepolarizingChannel--parameters","title":"Parameters","text":"<p>p : float     The total probability of an n-qubit depolarizing error occurring.     Must satisfy 0 \u2264 p \u2264 1.</p> Sequence[int] <p>The list of qubit indices (wires) on which the channel acts. Must contain at least 2 qubits.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.NQubitDepolarizingChannel--returns","title":"Returns","text":"<p>qml.QubitChannel     A PennyLane QubitChannel constructed from the Kraus operators representing     the n-qubit depolarizing noise channel acting on the specified wires.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef NQubitDepolarizingChannel(p, wires):\n    \"\"\"\n    Generates the Kraus operators for an n-qubit depolarizing channel.\n\n    The n-qubit depolarizing channel is defined as:\n        E(rho) = sqrt(1 - p * (4^n - 1) / 4^n) * rho\n            + sqrt(p / 4^n) * \u2211_{P \u2260 I^{\u2297n}} P rho P\u2020\n    where the sum is over all non-identity n-qubit Pauli operators\n    (i.e., tensor products of {I, X, Y, Z} excluding the identity operator I^{\u2297n}).\n    Each Pauli error operator is weighted equally by p / 4^n.\n\n    This operator-sum (Kraus) representation models uniform depolarizing noise\n    acting on n qubits simultaneously. It is useful for simulating realistic\n    multi-qubit noise affecting entangling gates in noisy quantum circuits.\n\n    Parameters\n    ----------\n    p : float\n        The total probability of an n-qubit depolarizing error occurring.\n        Must satisfy 0 \u2264 p \u2264 1.\n\n    wires : Sequence[int]\n        The list of qubit indices (wires) on which the channel acts.\n        Must contain at least 2 qubits.\n\n    Returns\n    -------\n    qml.QubitChannel\n        A PennyLane QubitChannel constructed from the Kraus operators representing\n        the n-qubit depolarizing noise channel acting on the specified wires.\n    \"\"\"\n    def n_qubit_depolarizing_kraus(p: float, n: int) -&gt; List[np.ndarray]:\n        if not (0.0 &lt;= p &lt;= 1.0):\n            raise ValueError(f\"Probability p must be between 0 and 1, got {p}\")\n        if n &lt; 2:\n            raise ValueError(f\"Number of qubits must be &gt;= 2, got {n}\")\n\n        Id = np.eye(2)\n        X = qml.matrix(qml.PauliX(0))\n        Y = qml.matrix(qml.PauliY(0))\n        Z = qml.matrix(qml.PauliZ(0))\n        paulis = [Id, X, Y, Z]\n\n        dim = 2 ** n\n        all_ops = []\n\n        # Generate all n-qubit Pauli tensor products:\n        for indices in itertools.product(range(4), repeat=n):\n            P = np.eye(1)\n            for idx in indices:\n                P = np.kron(P, paulis[idx])\n            all_ops.append(P)\n\n        # Identity operator corresponds to all zeros indices (Id^n)\n        K0 = np.sqrt(1 - p * (4 ** n - 1) / (4 ** n)) * np.eye(dim)\n\n        kraus_ops = []\n        for i, P in enumerate(all_ops):\n            if i == 0:\n                # Skip the identity, already handled as K0\n                continue\n            kraus_ops.append(np.sqrt(p / (4 ** n)) * P)\n\n        return [K0] + kraus_ops\n\n    return qml.QubitChannel(n_qubit_depolarizing_kraus(p, len(wires)), wires=wires)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.Noise","title":"<code>Noise(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies noise to the given wires.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.Noise--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the noise to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:     -BitFlip: Applies a bit flip error to the given wires.     -PhaseFlip: Applies a phase flip error to the given wires.     -Depolarizing: Applies a depolarizing channel error to the         given wires.     -MultiQubitDepolarizing: Applies a two-qubit depolarizing channel         error to the given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Noise(\n    wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n) -&gt; None:\n    \"\"\"\n    Applies noise to the given wires.\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the noise to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n        -BitFlip: Applies a bit flip error to the given wires.\n        -PhaseFlip: Applies a phase flip error to the given wires.\n        -Depolarizing: Applies a depolarizing channel error to the\n            given wires.\n        -MultiQubitDepolarizing: Applies a two-qubit depolarizing channel\n            error to the given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    if noise_params is not None:\n        if isinstance(wires, int):\n            wires = [wires]  # single qubit gate\n\n        # noise on single qubits\n        for wire in wires:\n            qml.BitFlip(noise_params.get(\"BitFlip\", 0.0), wires=wire)\n            qml.PhaseFlip(noise_params.get(\"PhaseFlip\", 0.0), wires=wire)\n            qml.DepolarizingChannel(\n                noise_params.get(\"Depolarizing\", 0.0), wires=wire\n            )\n\n        # noise on two-qubits\n        if len(wires) &gt; 1:\n            p = noise_params.get(\"MultiQubitDepolarizing\", 0.0)\n            if p &gt; 0:\n                Gates.NQubitDepolarizingChannel(p, wires)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RX","title":"<code>RX(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the X axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RX--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RX(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the X axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.RX(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RY","title":"<code>RY(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the Y axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RY--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the     given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RY(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the Y axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n        given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.RY(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RZ","title":"<code>RZ(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the Z axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RZ--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RZ(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the Z axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.RZ(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.Rot","title":"<code>Rot(phi, theta, omega, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.Rot--parameters","title":"Parameters","text":"<p>phi : float     The first rotation angle in radians. theta : float     The second rotation angle in radians. omega : float     The third rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Rot(phi, theta, omega, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    phi : float\n        The first rotation angle in radians.\n    theta : float\n        The second rotation angle in radians.\n    omega : float\n        The third rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    if noise_params is not None and \"GateError\" in noise_params:\n        phi = Gates.GateError(phi, noise_params)\n        theta = Gates.GateError(theta, noise_params)\n        omega = Gates.GateError(omega, noise_params)\n        # phi += Gates.rng.normal(0, noise_params[\"GateError\"])\n        # theta += Gates.rng.normal(0, noise_params[\"GateError\"])\n        # omega += Gates.rng.normal(0, noise_params[\"GateError\"])\n    qml.Rot(phi, theta, omega, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.init_rng","title":"<code>init_rng(seed)</code>  <code>staticmethod</code>","text":"<p>Initializes the random number generator with the given seed.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.init_rng--parameters","title":"Parameters","text":"<p>seed : int     The seed for the random number generator.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef init_rng(seed: int):\n    \"\"\"\n    Initializes the random number generator with the given seed.\n\n    Parameters\n    ----------\n    seed : int\n        The seed for the random number generator.\n    \"\"\"\n    Gates.rng = np.random.default_rng(seed)\n</code></pre>"},{"location":"references/#model","title":"Model","text":"<pre><code>from qml_essentials.model import Model\n</code></pre> <p>A quantum circuit model.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>class Model:\n    \"\"\"\n    A quantum circuit model.\n    \"\"\"\n\n    lightning_threshold = 12\n\n    def __init__(\n        self,\n        n_qubits: int,\n        n_layers: int,\n        circuit_type: Union[str, Circuit] = \"No_Ansatz\",\n        data_reupload: Union[bool, List[bool], List[List[bool]]] = True,\n        state_preparation: Union[str, Callable, List[str], List[Callable]] = None,\n        encoding: Union[str, Callable, List[str], List[Callable]] = Gates.RX,\n        trainable_frequencies: bool = False,\n        initialization: str = \"random\",\n        initialization_domain: List[float] = [0, 2 * np.pi],\n        output_qubit: Union[List[int], int] = -1,\n        shots: Optional[int] = None,\n        random_seed: int = 1000,\n        as_pauli_circuit: bool = False,\n        remove_zero_encoding: bool = True,\n        mp_threshold: int = -1,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the quantum circuit model.\n        Parameters will have the shape [impl_n_layers, parameters_per_layer]\n        where impl_n_layers is the number of layers provided and added by one\n        depending if data_reupload is True and parameters_per_layer is given by\n        the chosen ansatz.\n\n        The model is initialized with the following parameters as defaults:\n        - noise_params: None\n        - execution_type: \"expval\"\n        - shots: None\n\n        Args:\n            n_qubits (int): The number of qubits in the circuit.\n            n_layers (int): The number of layers in the circuit.\n            circuit_type (str, Circuit): The type of quantum circuit to use.\n                If None, defaults to \"no_ansatz\".\n            data_reupload (Union[bool, List[bool], List[List[bool]]], optional):\n                Whether to reupload data to the quantum device on each\n                layer and qubit. Detailed re-uploading instructions can be given\n                as a list/array of 0/False and 1/True with shape (n_qubits,\n                n_layers) to specify where to upload the data. Defaults to True\n                for applying data re-uploading to the full circuit.\n            encoding (Union[str, Callable, List[str], List[Callable]], optional):\n                The unitary to use for encoding the input data. Can be a string\n                (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n                If input is multidimensional it is assumed to be a list of\n                unitaries or a list of strings.\n            trainable_frequencies (bool, optional):\n                Sets trainable encoding parameters for trainable frequencies.\n                Defaults to False.\n            initialization (str, optional): The strategy to initialize the parameters.\n                Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n                Defaults to \"random\".\n            output_qubit (List[int], int, optional): The index of the output\n                qubit (or qubits). When set to -1 all qubits are measured, or a\n                global measurement is conducted, depending on the execution\n                type.\n            shots (Optional[int], optional): The number of shots to use for\n                the quantum device. Defaults to None.\n            random_seed (int, optional): seed for the random number generator\n                in initialization is \"random\" and for random noise parameters.\n                Defaults to 1000.\n            as_pauli_circuit (bool, optional): whether the circuit is\n                transformed to a Pauli-Clifford circuit as described by Nemkov\n                et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is\n                required for analytical Fourier coefficient computation.\n                Defaults to False.\n            remove_zero_encoding (bool, optional): whether to\n                remove the zero encoding from the circuit. Defaults to True.\n            mp_threshold (int, optional): threshold above which the parameter\n                batch dimension is split across multiple processes.\n                Defaults to -1.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialize default parameters needed for circuit evaluation\n        self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n        self.execution_type: Optional[str] = \"expval\"\n        self.shots = shots\n        self.remove_zero_encoding = remove_zero_encoding\n        self.mp_threshold = mp_threshold\n        self.n_qubits: int = n_qubits\n        self.n_layers: int = n_layers\n        self.trainable_frequencies: bool = trainable_frequencies\n\n        if isinstance(output_qubit, list):\n            assert (\n                len(output_qubit) &lt;= n_qubits\n            ), f\"Size of output_qubit {len(output_qubit)} cannot be\\\n            larger than number of qubits {n_qubits}.\"\n        self.output_qubit: Union[List[int], int] = output_qubit\n\n        # Initialize rng in Gates\n        Gates.init_rng(random_seed)\n\n        # --- State Preparation ---\n        # first check if we have a str, list or callable\n        if isinstance(state_preparation, str):\n            # if str, use the pennylane fct\n            self._sp = [getattr(Gates, f\"{state_preparation}\")]\n        elif isinstance(state_preparation, list):\n            # if list, check if str or callable\n            if isinstance(state_preparation[0], str):\n                self._sp = [getattr(Gates, f\"{sp}\") for sp in state_preparation]\n            else:\n                self._sp = state_preparation\n        elif state_preparation is None:\n            self._sp = [lambda *args, **kwargs: None]\n        else:\n            # default to callable\n            self._sp = [state_preparation]\n\n        # --- Encoding ---\n        # first check if we have a str, list or callable\n        if isinstance(encoding, str):\n            # if str, use the pennylane fct\n            self._enc = [getattr(Gates, f\"{encoding}\")]\n        elif isinstance(encoding, list):\n            # if list, check if str or callable\n            if isinstance(encoding[0], str):\n                self._enc = [getattr(Gates, f\"{enc}\") for enc in encoding]\n            else:\n                self._enc = encoding\n        else:\n            # default to callable\n            self._enc = [encoding]\n\n        # Number of possible inputs\n        self.n_input_feat = len(self._enc)\n        log.info(f\"Number of input features: {self.n_input_feat}\")\n\n        # Trainable frequencies, default initialization as in arXiv:2309.03279v2\n        self.enc_params = np.ones(\n            (self.n_qubits, self.n_input_feat), requires_grad=trainable_frequencies\n        )\n\n        # --- Data-Reuploading ---\n        # Process data reuploading strategy and set degree\n        if not isinstance(data_reupload, bool):\n            if not isinstance(data_reupload, np.ndarray):\n                data_reupload = np.array(data_reupload)\n            if data_reupload.shape == (\n                n_layers,\n                n_qubits,\n            ):\n                data_reupload = data_reupload.reshape(*data_reupload.shape, 1)\n                data_reupload = np.repeat(data_reupload, self.n_input_feat, axis=2)\n\n            assert data_reupload.shape == (\n                n_layers,\n                n_qubits,\n                self.n_input_feat,\n            ), f\"Data reuploading array has wrong shape. \\\n                Expected {(n_layers, n_qubits)} or\\\n                {(n_layers, n_qubits, self.n_input_feat)},\\\n                got {data_reupload.shape}.\"\n\n            log.debug(f\"Data reuploading array:\\n{data_reupload}\")\n        else:\n            if data_reupload:\n                impl_n_layers: int = (\n                    n_layers + 1\n                )  # we need L+1 according to Schuld et al.\n                data_reupload = np.ones((n_layers, n_qubits, self.n_input_feat))\n                log.debug(\"Full data reuploading.\")\n            else:\n                impl_n_layers: int = n_layers\n                data_reupload = np.zeros((n_layers, n_qubits, self.n_input_feat))\n                data_reupload[0][0] = 1\n                log.debug(\"No data reuploading.\")\n\n        # convert to boolean values\n        self.data_reupload = data_reupload.astype(bool)\n        self.frequencies = [\n            np.count_nonzero(self.data_reupload[..., i])\n            for i in range(self.n_input_feat)\n        ]\n\n        if self.degree &gt; 1:\n            impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n        else:\n            impl_n_layers = n_layers\n        log.info(f\"Number of implicit layers: {impl_n_layers}.\")\n\n        # --- Ansatz ---\n        # only weak check for str. We trust the user to provide sth useful\n        if isinstance(circuit_type, str):\n            self.pqc: Callable[[Optional[np.ndarray], int], int] = getattr(\n                Ansaetze, circuit_type or \"No_Ansatz\"\n            )()\n        else:\n            self.pqc = circuit_type()\n        log.info(f\"Using Ansatz {circuit_type}.\")\n\n        # calculate the shape of the parameter vector here, we will re-use this in init.\n        params_per_layer = self.pqc.n_params_per_layer(self.n_qubits)\n        self._params_shape: Tuple[int, int] = (impl_n_layers, params_per_layer)\n        log.info(f\"Parameters per layer: {params_per_layer}\")\n\n        self.batch_shape = (1, 1)\n        # this will also be re-used in the init method,\n        # however, only if nothing is provided\n        self._inialization_strategy = initialization\n        self._initialization_domain = initialization_domain\n\n        # ..here! where we only require a rng\n        self.initialize_params(np.random.default_rng(random_seed))\n\n        # Initialize two circuits, one with the default device and\n        # one with the mixed device\n        # which allows us to later route depending on the state_vector flag\n        self.as_pauli_circuit = as_pauli_circuit\n\n        self.circuit_mixed: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n        )\n\n    @property\n    def degree(self):\n        return max(self.frequencies)\n\n    @property\n    def as_pauli_circuit(self) -&gt; bool:\n        return self._as_pauli_circuit\n\n    @as_pauli_circuit.setter\n    def as_pauli_circuit(self, value: bool) -&gt; None:\n        self._as_pauli_circuit = value\n\n        if self.n_qubits &lt; self.lightning_threshold:\n            device = \"default.qubit\"\n        else:\n            device = \"lightning.qubit\"\n            self.mp_threshold = -1\n\n        self.circuit: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\n                device,\n                shots=self.shots,\n                wires=self.n_qubits,\n            ),\n            interface=\"autograd\" if self.shots is not None else \"auto\",\n            diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n        )\n\n        if value:\n            pauli_circuit_transform = qml.transform(\n                PauliCircuit.from_parameterised_circuit\n            )\n            self.circuit = pauli_circuit_transform(self.circuit)\n\n    @property\n    def noise_params(self) -&gt; Optional[Dict[str, Union[float, Dict[str, float]]]]:\n        \"\"\"\n        Gets the noise parameters of the model.\n\n        Returns:\n            Optional[Dict[str, float]]: A dictionary of\n            noise parameters or None if not set.\n        \"\"\"\n        return self._noise_params\n\n    @noise_params.setter\n    def noise_params(\n        self, kvs: Optional[Dict[str, Union[float, Dict[str, float]]]]\n    ) -&gt; None:\n        \"\"\"\n        Sets the noise parameters of the model.\n\n        Typically a \"noise parameter\" refers to the error probability.\n        ThermalRelaxation is a special case, and supports a dict as value with\n        structure:\n            \"ThermalRelaxation\":\n            {\n                \"t1\": 2000, # relative t1 time.\n                \"t2\": 1000, # relative t2 time\n                \"t_factor\" 1: # relative gate time factor\n            },\n\n        Args:\n            kvs (Optional[Dict[str, Union[float, Dict[str, float]]]]): A\n            dictionary of noise parameters. If all values are 0.0, the noise\n            parameters are set to None.\n\n        Returns:\n            None\n        \"\"\"\n        # set to None if only zero values provided\n        if kvs is not None and all(np == 0.0 for np in kvs.values()):\n            kvs = None\n\n        # set default values\n        if kvs is not None:\n            kvs.setdefault(\"BitFlip\", 0.0)\n            kvs.setdefault(\"PhaseFlip\", 0.0)\n            kvs.setdefault(\"Depolarizing\", 0.0)\n            kvs.setdefault(\"MultiQubitDepolarizing\", 0.0)\n            kvs.setdefault(\"AmplitudeDamping\", 0.0)\n            kvs.setdefault(\"PhaseDamping\", 0.0)\n            kvs.setdefault(\"GateError\", 0.0)\n            kvs.setdefault(\"ThermalRelaxation\", None)\n            kvs.setdefault(\"StatePreparation\", 0.0)\n            kvs.setdefault(\"Measurement\", 0.0)\n\n            # check if there are any keys not supported\n            for key in kvs.keys():\n                if key not in [\n                    \"BitFlip\",\n                    \"PhaseFlip\",\n                    \"Depolarizing\",\n                    \"MultiQubitDepolarizing\",\n                    \"AmplitudeDamping\",\n                    \"PhaseDamping\",\n                    \"GateError\",\n                    \"ThermalRelaxation\",\n                    \"StatePreparation\",\n                    \"Measurement\",\n                ]:\n                    warnings.warn(\n                        f\"Noise type {key} is not supported by this package\",\n                        UserWarning,\n                    )\n\n            # check valid params for thermal relaxation noise channel\n            tr_params = kvs[\"ThermalRelaxation\"]\n            if isinstance(tr_params, dict):\n                tr_params.setdefault(\"t1\", 0.0)\n                tr_params.setdefault(\"t2\", 0.0)\n                tr_params.setdefault(\"t_factor\", 0.0)\n                for k in tr_params.keys():\n                    if k not in [\n                        \"t1\",\n                        \"t2\",\n                        \"t_factor\",\n                    ]:\n                        warnings.warn(\n                            f\"Thermal Relaxation parameter {k} is not supported \"\n                            f\"by this package\",\n                            UserWarning,\n                        )\n                if not all(tr_params.values()) or tr_params[\"t2\"] &gt; 2 * tr_params[\"t1\"]:\n                    warnings.warn(\n                        \"Received invalid values for Thermal Relaxation noise \"\n                        \"parameter. Thermal relaxation is not applied!\",\n                        UserWarning,\n                    )\n                    kvs[\"ThermalRelaxation\"] = 0.0\n\n        self._noise_params = kvs\n\n    @property\n    def execution_type(self) -&gt; str:\n        \"\"\"\n        Gets the execution type of the model.\n\n        Returns:\n            str: The execution type, one of 'density', 'expval', or 'probs'.\n        \"\"\"\n        return self._execution_type\n\n    @execution_type.setter\n    def execution_type(self, value: str) -&gt; None:\n        if value not in [\"density\", \"state\", \"expval\", \"probs\"]:\n            raise ValueError(f\"Invalid execution type: {value}.\")\n\n        if (value == \"density\" or value == \"state\") and self.output_qubit != -1:\n            warnings.warn(\n                f\"{value} measurement does ignore output_qubit, which is \"\n                f\"{self.output_qubit}.\",\n                UserWarning,\n            )\n\n        if value == \"probs\" and self.shots is None:\n            warnings.warn(\n                \"Setting execution_type to probs without specifying shots.\",\n                UserWarning,\n            )\n\n        if value == \"density\" and self.shots is not None:\n            warnings.warn(\n                \"Setting execution_type to density with specified shots.\",\n                UserWarning,\n            )\n\n        self._execution_type = value\n\n    @property\n    def shots(self) -&gt; Optional[int]:\n        \"\"\"\n        Gets the number of shots to use for the quantum device.\n\n        Returns:\n            Optional[int]: The number of shots.\n        \"\"\"\n        return self._shots\n\n    @shots.setter\n    def shots(self, value: Optional[int]) -&gt; None:\n        \"\"\"\n        Sets the number of shots to use for the quantum device.\n\n        Args:\n            value (Optional[int]): The number of shots.\n            If an integer less than or equal to 0 is provided, it is set to None.\n\n        Returns:\n            None\n        \"\"\"\n        if type(value) is int and value &lt;= 0:\n            value = None\n        self._shots = value\n\n    def initialize_params(\n        self,\n        rng: np.random.Generator,\n        repeat: int = None,\n        initialization: str = None,\n        initialization_domain: List[float] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the parameters of the model.\n\n        Args:\n            rng: A random number generator to use for initialization.\n            repeat: The number of times to repeat the parameters.\n                If None, the number of layers is used.\n            initialization: The strategy to use for parameter initialization.\n                If None, the strategy specified in the constructor is used.\n            initialization_domain: The domain to use for parameter initialization.\n                If None, the domain specified in the constructor is used.\n\n        Returns:\n            None\n        \"\"\"\n        params_shape = (\n            self._params_shape if repeat is None else [*self._params_shape, repeat]\n        )\n        # use existing strategy if not specified\n        initialization = initialization or self._inialization_strategy\n        initialization_domain = initialization_domain or self._initialization_domain\n\n        def set_control_params(params: np.ndarray, value: float) -&gt; np.ndarray:\n            indices = self.pqc.get_control_indices(self.n_qubits)\n            if indices is None:\n                warnings.warn(\n                    f\"Specified {initialization} but circuit\\\n                    does not contain controlled rotation gates.\\\n                    Parameters are intialized randomly.\",\n                    UserWarning,\n                )\n            else:\n                params[:, indices[0] : indices[1] : indices[2]] = (\n                    np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                    * value\n                )\n            return params\n\n        if initialization == \"random\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n        elif initialization == \"zeros\":\n            self.params: np.ndarray = np.zeros(params_shape, requires_grad=True)\n        elif initialization == \"pi\":\n            self.params: np.ndarray = np.ones(params_shape, requires_grad=True) * np.pi\n        elif initialization == \"zero-controlled\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n            self.params = set_control_params(self.params, 0)\n        elif initialization == \"pi-controlled\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n            self.params = set_control_params(self.params, np.pi)\n        else:\n            raise Exception(\"Invalid initialization method\")\n\n        log.info(\n            f\"Initialized parameters with shape {self.params.shape}\\\n            using strategy {initialization}.\"\n        )\n\n    def transform_input(self, inputs: np.ndarray, enc_params: Optional[np.ndarray]):\n        \"\"\"\n        Transforms the input as in arXiv:2309.03279v2\n\n        Args:\n            inputs (np.ndarray): single input point of shape (1, n_input_feat)\n            idx (int): feature index\n            qubit (int): qubit on which to the encoding is being performed\n            enc_params (np.ndarray): encoding weight vector of\n                shape (n_qubits)\n\n        Returns:\n            np.ndarray: transformed input of shape (1,), linearly scaled by\n            enc_params, ready for encoding\n        \"\"\"\n        return inputs * enc_params\n\n    def _iec(\n        self,\n        inputs: np.ndarray,\n        data_reupload: np.ndarray,\n        enc: Union[Callable, List[Callable]],\n        enc_params: np.ndarray,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Creates an AngleEncoding using RX gates\n\n        Args:\n            inputs (np.ndarray): single input point of shape (1, n_input_feat)\n            data_reupload (np.ndarray): Boolean array to indicate positions in\n                the circuit for data re-uploading for the IEC, shape is\n                (n_qubits, n_layers).\n            enc: Callable or List[Callable]: encoding function or list of encoding\n                functions\n            enc_params (np.ndarray): encoding weight vector\n                of shape [n_qubits, n_inputs]\n            noise_params (Optional[Dict[str, Union[float, Dict[str, float]]]]):\n                The noise parameters.\n        Returns:\n            None\n        \"\"\"\n        # check for zero, because due to input validation, input cannot be none\n        if self.remove_zero_encoding and not inputs.any():\n            return\n\n        for q in range(self.n_qubits):\n            for idx in range(inputs.shape[1]):\n                if data_reupload[q, idx]:\n                    enc[idx](\n                        self.transform_input(inputs[:, idx], enc_params[q, idx]),\n                        wires=q,\n                        noise_params=noise_params,\n                    )\n\n    def _circuit(\n        self,\n        params: np.ndarray,\n        inputs: np.ndarray,\n        enc_params: Optional[np.ndarray] = None,\n    ) -&gt; Union[float, np.ndarray]:\n        \"\"\"\n        Creates a circuit with noise.\n\n        Args:\n            params (np.ndarray): weight vector of shape\n                [n_layers, n_qubits*(n_params_per_layer+trainable_frequencies)]\n            inputs (np.ndarray): input vector of size 1\n            enc_params Optional[np.ndarray]: encoding weight vector\n                of shape [n_qubits, n_inputs]\n        Returns:\n            Union[float, np.ndarray]: Expectation value of PauliZ(0)\n                of the circuit if state_vector is False and expval is True,\n                otherwise the density matrix of all qubits.\n        \"\"\"\n\n        self._variational(params=params, inputs=inputs, enc_params=enc_params)\n        return self._observable()\n\n    def _variational(self, params, inputs, enc_params=None):\n        if enc_params is None:\n            warnings.warn(\n                \"Explicit call to `_circuit` or `_variational` detected: \"\n                \"`enc_params` is None, using `self.enc_params` instead.\",\n                RuntimeWarning,\n            )\n            enc_params = self.enc_params\n\n        if self.noise_params is not None:\n            self._apply_state_prep_noise()\n\n        # state preparation\n        for q in range(self.n_qubits):\n            for _sp in self._sp:\n                _sp(wires=q, noise_params=self.noise_params)\n\n        # circuit building\n        for layer in range(0, self.n_layers):\n            # ansatz layers\n            self.pqc(params[layer], self.n_qubits, noise_params=self.noise_params)\n\n            # encoding layers\n            self._iec(\n                inputs,\n                data_reupload=self.data_reupload[layer],\n                enc=self._enc,\n                enc_params=enc_params,\n                noise_params=self.noise_params,\n            )\n\n            # visual barrier\n            if self.degree &gt; 1:\n                qml.Barrier(wires=list(range(self.n_qubits)), only_visual=True)\n\n        # final ansatz layer\n        if self.degree &gt; 1:  # same check as in init\n            self.pqc(params[-1], self.n_qubits, noise_params=self.noise_params)\n\n        # channel noise\n        if self.noise_params is not None:\n            self._apply_general_noise()\n\n    def _observable(self):\n        # run mixed simualtion and get density matrix\n        if self.execution_type == \"density\":\n            return qml.density_matrix(wires=list(range(self.n_qubits)))\n        elif self.execution_type == \"state\":\n            return qml.state()\n        # run default simulation and get expectation value\n        elif self.execution_type == \"expval\":\n            # n-local measurement\n            if self.output_qubit == -1:\n                return [qml.expval(qml.PauliZ(q)) for q in range(self.n_qubits)]\n            # local measurement(s)\n            elif isinstance(self.output_qubit, int):\n                return qml.expval(qml.PauliZ(self.output_qubit))\n            # parity measurenment\n            elif isinstance(self.output_qubit, list):\n                obs = qml.PauliZ(self.output_qubit[0])\n                for out_qubit in self.output_qubit[1:]:\n                    obs = obs @ qml.PauliZ(out_qubit)\n                return qml.expval(obs)\n            else:\n                raise ValueError(\n                    f\"Invalid parameter `output_qubit`: {self.output_qubit}.\\\n                        Must be int, list or -1.\"\n                )\n        # run default simulation and get probs\n        elif self.execution_type == \"probs\":\n            if self.output_qubit == -1:\n                return qml.probs(wires=list(range(self.n_qubits)))\n            else:\n                return qml.probs(wires=self.output_qubit)\n        else:\n            raise ValueError(f\"Invalid execution_type: {self.execution_type}.\")\n\n    def _apply_state_prep_noise(self) -&gt; None:\n        \"\"\"\n        Applies a state preparation error on each qubit according to the\n        probability for StatePreparation provided in the noise_params.\n        \"\"\"\n        sp = self.noise_params.get(\"StatePreparation\", 0.0)\n        for q in range(self.n_qubits):\n            if sp &gt; 0:\n                qml.BitFlip(sp, wires=q)\n\n    def _apply_general_noise(self) -&gt; None:\n        \"\"\"\n        Applies general types of noise the full circuit (in contrast to gate\n        errors, applied directly at gate level, see Gates.Noise).\n\n        Possible types of noise are:\n            - AmplitudeDamping (specified through probability)\n            - PhaseDamping (specified through probability)\n            - ThermalRelaxation (specified through a dict, containing keys\n                                 \"t1\", \"t2\", \"t_factor\")\n            - Measurement (specified through probability)\n        \"\"\"\n        amp_damp = self.noise_params.get(\"AmplitudeDamping\", 0.0)\n        phase_damp = self.noise_params.get(\"PhaseDamping\", 0.0)\n        thermal_relax = self.noise_params.get(\"ThermalRelaxation\", 0.0)\n        meas = self.noise_params.get(\"Measurement\", 0.0)\n        for q in range(self.n_qubits):\n            if amp_damp &gt; 0:\n                qml.AmplitudeDamping(amp_damp, wires=q)\n            if phase_damp &gt; 0:\n                qml.PhaseDamping(phase_damp, wires=q)\n            if meas &gt; 0:\n                qml.BitFlip(meas, wires=q)\n            if isinstance(thermal_relax, dict):\n                t1 = thermal_relax[\"t1\"]\n                t2 = thermal_relax[\"t2\"]\n                t_factor = thermal_relax[\"t_factor\"]\n                circuit_depth = self.get_circuit_depth()\n                tg = circuit_depth * t_factor\n                qml.ThermalRelaxationError(1.0, t1, t2, tg, q)\n\n    def draw(self, inputs=None, figure=\"text\", *args, **kwargs):\n        \"\"\"\n        Draws the quantum circuit using the specified visualization method.\n\n        Args:\n            inputs (Optional[np.ndarray]): Input vector for the circuit. If None,\n                the default inputs are used.\n            figure (str, optional): The type of figure to generate. Must be one of\n                'text', 'mpl', or 'tikz'. Defaults to 'text'.\n        Returns:\n            Either a string, matplotlib figure or TikzFigure object (similar to string)\n            depending on the chosen visualization.\n        *args:\n            Additional arguments to be passed to the visualization method.\n        **kwargs:\n            Additional keyword arguments to be passed to the visualization method.\n\n        Raises:\n            AssertionError: If the 'figure' argument is not one of the accepted values.\n        \"\"\"\n\n        if not isinstance(self.circuit, qml.QNode):\n            # TODO: throws strange argument error if not catched\n            return \"\"\n\n        assert figure in [\n            \"text\",\n            \"mpl\",\n            \"tikz\",\n        ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n        inputs = self._inputs_validation(inputs)\n\n        if figure == \"mpl\":\n            result = qml.draw_mpl(self.circuit)(\n                params=self.params,\n                inputs=inputs,\n                enc_params=self.enc_params,\n                *args,\n                **kwargs,\n            )\n        elif figure == \"tikz\":\n            result = QuanTikz.build(\n                self.circuit,\n                params=self.params,\n                inputs=inputs,\n                enc_params=self.enc_params,\n                *args,\n                **kwargs,\n            )\n        else:\n            result = qml.draw(self.circuit)(\n                params=self.params, inputs=inputs, enc_params=self.enc_params\n            )\n        return result\n\n    def __repr__(self) -&gt; str:\n        return self.draw(figure=\"text\")\n\n    def __str__(self) -&gt; str:\n        return self.draw(figure=\"text\")\n\n    def _params_validation(self, params) -&gt; np.ndarray:\n        \"\"\"\n        Sets the parameters when calling the quantum circuit\n\n        Args:\n            params (np.ndarray): The parameters used for the call\n        \"\"\"\n        if params is None:\n            params = self.params\n        else:\n            if numpy_boxes.ArrayBox == type(params):\n                self.params = params._value\n            else:\n                self.params = params\n        return params\n\n    def _enc_params_validation(self, enc_params) -&gt; np.ndarray:\n        \"\"\"\n        Sets the encoding parameters when calling the quantum circuit\n\n        Args:\n            enc_params (np.ndarray): The encoding parameters used for the call\n        \"\"\"\n        if enc_params is None:\n            enc_params = self.enc_params\n        else:\n            if isinstance(enc_params, numpy_boxes.ArrayBox):\n                if self.trainable_frequencies:\n                    self.enc_params = enc_params._value\n                else:\n                    self.enc_params = np.array(\n                        enc_params._value, requires_grad=self.trainable_frequencies\n                    )\n            else:\n                if self.trainable_frequencies:\n                    self.enc_params = enc_params\n                else:\n                    self.enc_params = np.array(\n                        enc_params, requires_grad=self.trainable_frequencies\n                    )\n\n        if len(enc_params.shape) == 1 and self.n_input_feat == 1:\n            enc_params = enc_params.reshape(-1, 1)\n        elif len(enc_params.shape) == 1 and self.n_input_feat &gt; 1:\n            raise ValueError(\n                f\"Input dimension {self.n_input_feat} &gt;1 but \\\n                `enc_params` has shape {enc_params.shape}\"\n            )\n\n        return enc_params\n\n    def _inputs_validation(\n        self, inputs: Union[None, List, float, int, np.ndarray]\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Validate the inputs to be a 2D numpy array of shape (batch_size, n_inputs).\n\n        Args:\n            inputs (Union[None, List, float, int, np.ndarray]): The input to validate.\n\n        Returns:\n            np.ndarray: The validated input.\n        \"\"\"\n        if inputs is None:\n            # initialize to zero\n            inputs = np.array([[0] * self.n_input_feat])\n        elif isinstance(inputs, List):\n            inputs = np.stack(inputs)\n        elif isinstance(inputs, float) or isinstance(inputs, int):\n            inputs = np.array([inputs])\n\n        if len(inputs.shape) &lt;= 1:\n            if self.n_input_feat == 1:\n                # add a batch dimension\n                inputs = inputs.reshape(-1, 1)\n            else:\n                if inputs.shape[0] == self.n_input_feat:\n                    inputs = inputs.reshape(1, -1)\n                else:\n                    inputs = inputs.reshape(-1, 1)\n                    inputs = inputs.repeat(self.n_input_feat, axis=1)\n                    warnings.warn(\n                        f\"Expected {self.n_input_feat} inputs, but {inputs.shape[0]} \"\n                        \"was provided, replicating input for all input features.\",\n                        UserWarning,\n                    )\n        else:\n            if inputs.shape[1] != self.n_input_feat:\n                raise ValueError(\n                    f\"Wrong number of inputs provided. Expected {self.n_input_feat} \"\n                    f\"inputs, but input has shape {inputs.shape}.\"\n                )\n\n        return inputs\n\n    @staticmethod\n    def _parallel_f(\n        procnum,\n        result,\n        f,\n        batch_size,\n        params,\n        inputs,\n        batch_shape,\n        enc_params,\n    ):\n        \"\"\"\n        Helper function for parallelizing a function f over parameters.\n        Sices the batch dimension based on the procnum and batch size.\n\n        Args:\n            procnum: The process number.\n            result: The result array.\n            f: The function to be parallelized.\n            batch_size: The batch size.\n            params: The parameters array.\n            inputs: The inputs array.\n            enc_params: The encoding parameters array.\n        \"\"\"\n        min_idx = max(procnum * batch_size, 0)\n\n        if batch_shape[0] &gt; 1:\n            max_idx = min((procnum + 1) * batch_size, inputs.shape[0])\n            inputs = inputs[min_idx:max_idx]\n        if batch_shape[1] &gt; 1:\n            max_idx = min((procnum + 1) * batch_size, params.shape[2])\n            params = params[:, :, min_idx:max_idx]\n\n        result[procnum] = f(params=params, inputs=inputs, enc_params=enc_params)\n\n    def _mp_executor(self, f, params, inputs, enc_params):\n        \"\"\"\n        Execute a function f in parallel over parameters.\n\n        Args:\n            f: A function that takes two arguments, params and inputs,\n                and returns a numpy array.\n            params: A 3D numpy array of parameters where the first dimension is\n                the layer index, the second dimension is the parameter index in\n                the layer, and the third dimension is the sample index.\n            inputs: A 2D numpy array of inputs where the first dimension is\n                the sample index and the second dimension is the input feature index.\n            enc_params: A 1D numpy array of encoding parameters where the dimension is\n                the qubit index.\n\n        Returns:\n            A numpy array of the output of f applied to each batch of\n            samples in params, enc_params, and inputs.\n        \"\"\"\n        n_processes = 1\n        # batches available?\n        combined_batch_size = math.prod(self.batch_shape)\n        if (\n            combined_batch_size &gt; 1\n            and self.mp_threshold &gt; 0\n            and combined_batch_size &gt; self.mp_threshold\n        ):\n            n_processes = math.ceil(combined_batch_size / self.mp_threshold)\n        # check if single process\n        if n_processes == 1:\n            result = f(params=params, inputs=inputs, enc_params=enc_params)\n        else:\n            log.info(f\"Using {n_processes} processes\")\n            mpp = MultiprocessingPool(\n                n_processes=n_processes,\n                target=Model._parallel_f,\n                batch_size=self.mp_threshold,\n                f=f,\n                params=params,\n                enc_params=enc_params,\n                inputs=inputs,\n                batch_shape=self.batch_shape,\n            )\n            return_dict = mpp.spawn()\n            result = [None] * len(return_dict)\n            for k, v in return_dict.items():\n                result[k] = v\n\n            result = np.concat(result, axis=1 if self.execution_type == \"expval\" else 0)\n        return result\n\n    def _assimilate_batch(self, inputs, params):\n        batch_shape = (\n            inputs.shape[0],\n            params.shape[2] if len(params.shape) == 3 else 1,\n        )\n\n        if (\n            batch_shape[1] != 1\n            and batch_shape[0] != batch_shape[1]\n            and batch_shape[0] &gt; 1\n        ):\n            # the following code does some dirty reshaping\n            # TODO: optimize but be aware of the rabbit hole\n            # key is to get the right \"order\" in which we repeat\n\n            # [BI,D] -&gt; [BPxBI,D]\n            inputs = np.repeat(inputs, batch_shape[1], axis=0)\n\n            # this is a tricky one, essentially we want to get\n            # [L,Q,BP] -&gt; [L,Q,BI,BP] -&gt; [L,Q,BPxBI]\n            params = np.repeat(\n                params[:, :, np.newaxis, :], batch_shape[0], axis=2\n            ).reshape([*params.shape[:-1], np.prod(batch_shape)])\n\n        return inputs, params, batch_shape\n\n    def __call__(\n        self,\n        params: Optional[np.ndarray] = None,\n        inputs: Optional[np.ndarray] = None,\n        enc_params: Optional[np.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        cache: Optional[bool] = False,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform a forward pass of the quantum circuit.\n\n        Args:\n            params (Optional[np.ndarray]): Weight vector of shape\n                [n_layers, n_qubits*n_params_per_layer].\n                If None, model internal parameters are used.\n            inputs (Optional[np.ndarray]): Input vector of shape [1].\n                If None, zeros are used.\n            enc_params (Optional[np.ndarray]): Weight vector of shape\n                [n_qubits, n_input_features]. If None, model internal encoding\n                parameters are used.\n            noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n                Defaults to None which results in the last\n                set noise parameters being used.\n            cache (Optional[bool], optional): Whether to cache the results.\n                Defaults to False.\n            execution_type (str, optional): The type of execution.\n                Must be one of 'expval', 'density', or 'probs'.\n                Defaults to None which results in the last set execution type\n                being used.\n            force_mean (bool, optional): Whether to average\n                when performing n-local measurements.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: The output of the quantum circuit.\n                The shape depends on the execution_type.\n                - If execution_type is 'expval', returns an ndarray of shape\n                    (1,) if output_qubit is -1, else (len(output_qubit),).\n                - If execution_type is 'density', returns an ndarray\n                    of shape (2**n_qubits, 2**n_qubits).\n                - If execution_type is 'probs', returns an ndarray\n                    of shape (2**n_qubits,) if output_qubit is -1, else\n                    (2**len(output_qubit),).\n        \"\"\"\n        # Call forward method which handles the actual caching etc.\n        return self._forward(\n            params=params,\n            inputs=inputs,\n            enc_params=enc_params,\n            noise_params=noise_params,\n            cache=cache,\n            execution_type=execution_type,\n            force_mean=force_mean,\n        )\n\n    def _forward(\n        self,\n        params: Optional[np.ndarray] = None,\n        inputs: Optional[np.ndarray] = None,\n        enc_params: Optional[np.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        cache: Optional[bool] = False,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform a forward pass of the quantum circuit.\n\n        Args:\n            params (Optional[np.ndarray]): Weight vector of shape\n                [n_layers, n_qubits*n_params_per_layer].\n                If None, model internal parameters are used.\n            inputs (Optional[np.ndarray]): Input vector of shape [1].\n                If None, zeros are used.\n            enc_params (Optional[np.ndarray]): Weight vector of shape\n                [n_qubits, n_input_features]. If None, model internal encoding\n                parameters are used.\n            noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n                Defaults to None which results in the last\n                set noise parameters being used.\n            cache (Optional[bool], optional): Whether to cache the results.\n                Defaults to False.\n            execution_type (str, optional): The type of execution.\n                Must be one of 'expval', 'density', or 'probs'.\n                Defaults to None which results in the last set execution type\n                being used.\n            force_mean (bool, optional): Whether to average\n                when performing n-local measurements.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: The output of the quantum circuit.\n                The shape depends on the execution_type.\n                - If execution_type is 'expval', returns an ndarray of shape\n                    (1,) if output_qubit is -1, else (len(output_qubit),).\n                - If execution_type is 'density', returns an ndarray\n                    of shape (2**n_qubits, 2**n_qubits).\n                - If execution_type is 'probs', returns an ndarray\n                    of shape (2**n_qubits,) if output_qubit is -1, else\n                    (2**len(output_qubit),).\n\n        Raises:\n            NotImplementedError: If the number of shots is not None or if the\n                expectation value is True.\n        \"\"\"\n        # set the parameters as object attributes\n        if noise_params is not None:\n            self.noise_params = noise_params\n        if execution_type is not None:\n            self.execution_type = execution_type\n\n        params = self._params_validation(params)\n        inputs = self._inputs_validation(inputs)\n        enc_params = self._enc_params_validation(enc_params)\n        inputs, params, self.batch_shape = self._assimilate_batch(inputs, params)\n        # the qasm representation contains the bound parameters,\n        # thus it is ok to hash that\n        hs = hashlib.md5(\n            repr(\n                {\n                    \"n_qubits\": self.n_qubits,\n                    \"n_layers\": self.n_layers,\n                    \"pqc\": self.pqc.__class__.__name__,\n                    \"dru\": self.data_reupload,\n                    \"params\": self.params,  # use safe-params\n                    \"enc_params\": self.enc_params,\n                    \"noise_params\": self.noise_params,\n                    \"execution_type\": self.execution_type,\n                    \"inputs\": inputs,\n                    \"output_qubit\": self.output_qubit,\n                }\n            ).encode(\"utf-8\")\n        ).hexdigest()\n\n        result: Optional[np.ndarray] = None\n        if cache:\n            name: str = f\"pqc_{hs}.npy\"\n\n            cache_folder: str = \".cache\"\n            if not os.path.exists(cache_folder):\n                os.mkdir(cache_folder)\n\n            file_path: str = os.path.join(cache_folder, name)\n\n            if os.path.isfile(file_path):\n                result = np.load(file_path)\n\n        if result is None:\n            # if density matrix requested or noise params used\n            if self.execution_type == \"density\" or self.noise_params is not None:\n                result = self._mp_executor(\n                    f=self.circuit_mixed,\n                    params=params,  # use arraybox params\n                    inputs=inputs,\n                    enc_params=enc_params,\n                )\n            else:\n                if not isinstance(self.circuit, qml.QNode):\n                    result = self.circuit(\n                        inputs=inputs,\n                    )\n                else:\n                    result = self._mp_executor(\n                        f=self.circuit,\n                        params=params,  # use arraybox params\n                        inputs=inputs,\n                        enc_params=enc_params,\n                    )\n\n        if isinstance(result, list):\n            result = np.stack(result)\n\n        if self.execution_type == \"expval\" and force_mean and self.output_qubit == -1:\n            # exception for torch layer because it swaps batch and output dimension\n            if not isinstance(self.circuit, qml.QNode):\n                result = result.mean(axis=-1)\n            else:\n                result = result.mean(axis=0)\n        elif self.execution_type == \"probs\" and force_mean and self.output_qubit == -1:\n            # exception for torch layer because it swaps batch and output dimension\n            if not isinstance(self.circuit, qml.QNode):\n                result = result[..., -1].sum(axis=-1)\n            else:\n                result = result[1:, ...].sum(axis=0)\n\n        if self.batch_shape[0] &gt; 1 and self.batch_shape[1] &gt; 1:\n            result = result.reshape(-1, *self.batch_shape)\n\n        result = result.squeeze()\n\n        if cache:\n            np.save(file_path, result)\n\n        return result\n\n    def get_specs(self, inputs: Optional[np.ndarray] = None) -&gt; dict:\n        \"\"\"\n        Get pennylane specs for the model.\n\n        Args:\n            inputs (Optional[np.ndarray]): The inputs, with which to call the\n                circuit. Defaults to None.\n\n        Returns:\n            dict: Dictionary of specs. The key \"resources\" contains information\n                about the circuit size and gate statistics.\n        \"\"\"\n        inputs = self._inputs_validation(inputs)\n        spec_model = deepcopy(self)\n        spec_model.noise_params = None  # remove noise\n        return qml.specs(spec_model.circuit)(self.params, inputs)\n\n    def get_circuit_depth(self, inputs: Optional[np.ndarray] = None) -&gt; int:\n        \"\"\"\n        Obtain circuit depth for the model\n\n        Args:\n            inputs (Optional[np.ndarray]): The inputs, with which to call the\n                circuit. Defaults to None.\n\n        Returns:\n            int: Circuit depth (longest path of gates in circuit.)\n        \"\"\"\n        return self.get_specs(inputs)[\"resources\"].depth\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.execution_type","title":"<code>execution_type</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the execution type of the model.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The execution type, one of 'density', 'expval', or 'probs'.</p>"},{"location":"references/#qml_essentials.model.Model.noise_params","title":"<code>noise_params</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the noise parameters of the model.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>Optional[Dict[str, float]]: A dictionary of</p> <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>noise parameters or None if not set.</p>"},{"location":"references/#qml_essentials.model.Model.shots","title":"<code>shots</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the number of shots to use for the quantum device.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The number of shots.</p>"},{"location":"references/#qml_essentials.model.Model.__call__","title":"<code>__call__(params=None, inputs=None, enc_params=None, noise_params=None, cache=False, execution_type=None, force_mean=False)</code>","text":"<p>Perform a forward pass of the quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Optional[ndarray]</code> <p>Weight vector of shape [n_layers, n_qubits*n_params_per_layer]. If None, model internal parameters are used.</p> <code>None</code> <code>inputs</code> <code>Optional[ndarray]</code> <p>Input vector of shape [1]. If None, zeros are used.</p> <code>None</code> <code>enc_params</code> <code>Optional[ndarray]</code> <p>Weight vector of shape [n_qubits, n_input_features]. If None, model internal encoding parameters are used.</p> <code>None</code> <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>The noise parameters. Defaults to None which results in the last set noise parameters being used.</p> <code>None</code> <code>cache</code> <code>Optional[bool]</code> <p>Whether to cache the results. Defaults to False.</p> <code>False</code> <code>execution_type</code> <code>str</code> <p>The type of execution. Must be one of 'expval', 'density', or 'probs'. Defaults to None which results in the last set execution type being used.</p> <code>None</code> <code>force_mean</code> <code>bool</code> <p>Whether to average when performing n-local measurements. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The output of the quantum circuit. The shape depends on the execution_type. - If execution_type is 'expval', returns an ndarray of shape     (1,) if output_qubit is -1, else (len(output_qubit),). - If execution_type is 'density', returns an ndarray     of shape (2n_qubits, 2n_qubits). - If execution_type is 'probs', returns an ndarray     of shape (2n_qubits,) if output_qubit is -1, else     (2len(output_qubit),).</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __call__(\n    self,\n    params: Optional[np.ndarray] = None,\n    inputs: Optional[np.ndarray] = None,\n    enc_params: Optional[np.ndarray] = None,\n    noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n    cache: Optional[bool] = False,\n    execution_type: Optional[str] = None,\n    force_mean: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform a forward pass of the quantum circuit.\n\n    Args:\n        params (Optional[np.ndarray]): Weight vector of shape\n            [n_layers, n_qubits*n_params_per_layer].\n            If None, model internal parameters are used.\n        inputs (Optional[np.ndarray]): Input vector of shape [1].\n            If None, zeros are used.\n        enc_params (Optional[np.ndarray]): Weight vector of shape\n            [n_qubits, n_input_features]. If None, model internal encoding\n            parameters are used.\n        noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n            Defaults to None which results in the last\n            set noise parameters being used.\n        cache (Optional[bool], optional): Whether to cache the results.\n            Defaults to False.\n        execution_type (str, optional): The type of execution.\n            Must be one of 'expval', 'density', or 'probs'.\n            Defaults to None which results in the last set execution type\n            being used.\n        force_mean (bool, optional): Whether to average\n            when performing n-local measurements.\n            Defaults to False.\n\n    Returns:\n        np.ndarray: The output of the quantum circuit.\n            The shape depends on the execution_type.\n            - If execution_type is 'expval', returns an ndarray of shape\n                (1,) if output_qubit is -1, else (len(output_qubit),).\n            - If execution_type is 'density', returns an ndarray\n                of shape (2**n_qubits, 2**n_qubits).\n            - If execution_type is 'probs', returns an ndarray\n                of shape (2**n_qubits,) if output_qubit is -1, else\n                (2**len(output_qubit),).\n    \"\"\"\n    # Call forward method which handles the actual caching etc.\n    return self._forward(\n        params=params,\n        inputs=inputs,\n        enc_params=enc_params,\n        noise_params=noise_params,\n        cache=cache,\n        execution_type=execution_type,\n        force_mean=force_mean,\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.__init__","title":"<code>__init__(n_qubits, n_layers, circuit_type='No_Ansatz', data_reupload=True, state_preparation=None, encoding=Gates.RX, trainable_frequencies=False, initialization='random', initialization_domain=[0, 2 * np.pi], output_qubit=-1, shots=None, random_seed=1000, as_pauli_circuit=False, remove_zero_encoding=True, mp_threshold=-1)</code>","text":"<p>Initialize the quantum circuit model. Parameters will have the shape [impl_n_layers, parameters_per_layer] where impl_n_layers is the number of layers provided and added by one depending if data_reupload is True and parameters_per_layer is given by the chosen ansatz.</p> <p>The model is initialized with the following parameters as defaults: - noise_params: None - execution_type: \"expval\" - shots: None</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits in the circuit.</p> required <code>n_layers</code> <code>int</code> <p>The number of layers in the circuit.</p> required <code>circuit_type</code> <code>(str, Circuit)</code> <p>The type of quantum circuit to use. If None, defaults to \"no_ansatz\".</p> <code>'No_Ansatz'</code> <code>data_reupload</code> <code>Union[bool, List[bool], List[List[bool]]]</code> <p>Whether to reupload data to the quantum device on each layer and qubit. Detailed re-uploading instructions can be given as a list/array of 0/False and 1/True with shape (n_qubits, n_layers) to specify where to upload the data. Defaults to True for applying data re-uploading to the full circuit.</p> <code>True</code> <code>encoding</code> <code>Union[str, Callable, List[str], List[Callable]]</code> <p>The unitary to use for encoding the input data. Can be a string (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX. If input is multidimensional it is assumed to be a list of unitaries or a list of strings.</p> <code>RX</code> <code>trainable_frequencies</code> <code>bool</code> <p>Sets trainable encoding parameters for trainable frequencies. Defaults to False.</p> <code>False</code> <code>initialization</code> <code>str</code> <p>The strategy to initialize the parameters. Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\". Defaults to \"random\".</p> <code>'random'</code> <code>output_qubit</code> <code>(List[int], int)</code> <p>The index of the output qubit (or qubits). When set to -1 all qubits are measured, or a global measurement is conducted, depending on the execution type.</p> <code>-1</code> <code>shots</code> <code>Optional[int]</code> <p>The number of shots to use for the quantum device. Defaults to None.</p> <code>None</code> <code>random_seed</code> <code>int</code> <p>seed for the random number generator in initialization is \"random\" and for random noise parameters. Defaults to 1000.</p> <code>1000</code> <code>as_pauli_circuit</code> <code>bool</code> <p>whether the circuit is transformed to a Pauli-Clifford circuit as described by Nemkov et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is required for analytical Fourier coefficient computation. Defaults to False.</p> <code>False</code> <code>remove_zero_encoding</code> <code>bool</code> <p>whether to remove the zero encoding from the circuit. Defaults to True.</p> <code>True</code> <code>mp_threshold</code> <code>int</code> <p>threshold above which the parameter batch dimension is split across multiple processes. Defaults to -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __init__(\n    self,\n    n_qubits: int,\n    n_layers: int,\n    circuit_type: Union[str, Circuit] = \"No_Ansatz\",\n    data_reupload: Union[bool, List[bool], List[List[bool]]] = True,\n    state_preparation: Union[str, Callable, List[str], List[Callable]] = None,\n    encoding: Union[str, Callable, List[str], List[Callable]] = Gates.RX,\n    trainable_frequencies: bool = False,\n    initialization: str = \"random\",\n    initialization_domain: List[float] = [0, 2 * np.pi],\n    output_qubit: Union[List[int], int] = -1,\n    shots: Optional[int] = None,\n    random_seed: int = 1000,\n    as_pauli_circuit: bool = False,\n    remove_zero_encoding: bool = True,\n    mp_threshold: int = -1,\n) -&gt; None:\n    \"\"\"\n    Initialize the quantum circuit model.\n    Parameters will have the shape [impl_n_layers, parameters_per_layer]\n    where impl_n_layers is the number of layers provided and added by one\n    depending if data_reupload is True and parameters_per_layer is given by\n    the chosen ansatz.\n\n    The model is initialized with the following parameters as defaults:\n    - noise_params: None\n    - execution_type: \"expval\"\n    - shots: None\n\n    Args:\n        n_qubits (int): The number of qubits in the circuit.\n        n_layers (int): The number of layers in the circuit.\n        circuit_type (str, Circuit): The type of quantum circuit to use.\n            If None, defaults to \"no_ansatz\".\n        data_reupload (Union[bool, List[bool], List[List[bool]]], optional):\n            Whether to reupload data to the quantum device on each\n            layer and qubit. Detailed re-uploading instructions can be given\n            as a list/array of 0/False and 1/True with shape (n_qubits,\n            n_layers) to specify where to upload the data. Defaults to True\n            for applying data re-uploading to the full circuit.\n        encoding (Union[str, Callable, List[str], List[Callable]], optional):\n            The unitary to use for encoding the input data. Can be a string\n            (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n            If input is multidimensional it is assumed to be a list of\n            unitaries or a list of strings.\n        trainable_frequencies (bool, optional):\n            Sets trainable encoding parameters for trainable frequencies.\n            Defaults to False.\n        initialization (str, optional): The strategy to initialize the parameters.\n            Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n            Defaults to \"random\".\n        output_qubit (List[int], int, optional): The index of the output\n            qubit (or qubits). When set to -1 all qubits are measured, or a\n            global measurement is conducted, depending on the execution\n            type.\n        shots (Optional[int], optional): The number of shots to use for\n            the quantum device. Defaults to None.\n        random_seed (int, optional): seed for the random number generator\n            in initialization is \"random\" and for random noise parameters.\n            Defaults to 1000.\n        as_pauli_circuit (bool, optional): whether the circuit is\n            transformed to a Pauli-Clifford circuit as described by Nemkov\n            et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is\n            required for analytical Fourier coefficient computation.\n            Defaults to False.\n        remove_zero_encoding (bool, optional): whether to\n            remove the zero encoding from the circuit. Defaults to True.\n        mp_threshold (int, optional): threshold above which the parameter\n            batch dimension is split across multiple processes.\n            Defaults to -1.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize default parameters needed for circuit evaluation\n    self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n    self.execution_type: Optional[str] = \"expval\"\n    self.shots = shots\n    self.remove_zero_encoding = remove_zero_encoding\n    self.mp_threshold = mp_threshold\n    self.n_qubits: int = n_qubits\n    self.n_layers: int = n_layers\n    self.trainable_frequencies: bool = trainable_frequencies\n\n    if isinstance(output_qubit, list):\n        assert (\n            len(output_qubit) &lt;= n_qubits\n        ), f\"Size of output_qubit {len(output_qubit)} cannot be\\\n        larger than number of qubits {n_qubits}.\"\n    self.output_qubit: Union[List[int], int] = output_qubit\n\n    # Initialize rng in Gates\n    Gates.init_rng(random_seed)\n\n    # --- State Preparation ---\n    # first check if we have a str, list or callable\n    if isinstance(state_preparation, str):\n        # if str, use the pennylane fct\n        self._sp = [getattr(Gates, f\"{state_preparation}\")]\n    elif isinstance(state_preparation, list):\n        # if list, check if str or callable\n        if isinstance(state_preparation[0], str):\n            self._sp = [getattr(Gates, f\"{sp}\") for sp in state_preparation]\n        else:\n            self._sp = state_preparation\n    elif state_preparation is None:\n        self._sp = [lambda *args, **kwargs: None]\n    else:\n        # default to callable\n        self._sp = [state_preparation]\n\n    # --- Encoding ---\n    # first check if we have a str, list or callable\n    if isinstance(encoding, str):\n        # if str, use the pennylane fct\n        self._enc = [getattr(Gates, f\"{encoding}\")]\n    elif isinstance(encoding, list):\n        # if list, check if str or callable\n        if isinstance(encoding[0], str):\n            self._enc = [getattr(Gates, f\"{enc}\") for enc in encoding]\n        else:\n            self._enc = encoding\n    else:\n        # default to callable\n        self._enc = [encoding]\n\n    # Number of possible inputs\n    self.n_input_feat = len(self._enc)\n    log.info(f\"Number of input features: {self.n_input_feat}\")\n\n    # Trainable frequencies, default initialization as in arXiv:2309.03279v2\n    self.enc_params = np.ones(\n        (self.n_qubits, self.n_input_feat), requires_grad=trainable_frequencies\n    )\n\n    # --- Data-Reuploading ---\n    # Process data reuploading strategy and set degree\n    if not isinstance(data_reupload, bool):\n        if not isinstance(data_reupload, np.ndarray):\n            data_reupload = np.array(data_reupload)\n        if data_reupload.shape == (\n            n_layers,\n            n_qubits,\n        ):\n            data_reupload = data_reupload.reshape(*data_reupload.shape, 1)\n            data_reupload = np.repeat(data_reupload, self.n_input_feat, axis=2)\n\n        assert data_reupload.shape == (\n            n_layers,\n            n_qubits,\n            self.n_input_feat,\n        ), f\"Data reuploading array has wrong shape. \\\n            Expected {(n_layers, n_qubits)} or\\\n            {(n_layers, n_qubits, self.n_input_feat)},\\\n            got {data_reupload.shape}.\"\n\n        log.debug(f\"Data reuploading array:\\n{data_reupload}\")\n    else:\n        if data_reupload:\n            impl_n_layers: int = (\n                n_layers + 1\n            )  # we need L+1 according to Schuld et al.\n            data_reupload = np.ones((n_layers, n_qubits, self.n_input_feat))\n            log.debug(\"Full data reuploading.\")\n        else:\n            impl_n_layers: int = n_layers\n            data_reupload = np.zeros((n_layers, n_qubits, self.n_input_feat))\n            data_reupload[0][0] = 1\n            log.debug(\"No data reuploading.\")\n\n    # convert to boolean values\n    self.data_reupload = data_reupload.astype(bool)\n    self.frequencies = [\n        np.count_nonzero(self.data_reupload[..., i])\n        for i in range(self.n_input_feat)\n    ]\n\n    if self.degree &gt; 1:\n        impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n    else:\n        impl_n_layers = n_layers\n    log.info(f\"Number of implicit layers: {impl_n_layers}.\")\n\n    # --- Ansatz ---\n    # only weak check for str. We trust the user to provide sth useful\n    if isinstance(circuit_type, str):\n        self.pqc: Callable[[Optional[np.ndarray], int], int] = getattr(\n            Ansaetze, circuit_type or \"No_Ansatz\"\n        )()\n    else:\n        self.pqc = circuit_type()\n    log.info(f\"Using Ansatz {circuit_type}.\")\n\n    # calculate the shape of the parameter vector here, we will re-use this in init.\n    params_per_layer = self.pqc.n_params_per_layer(self.n_qubits)\n    self._params_shape: Tuple[int, int] = (impl_n_layers, params_per_layer)\n    log.info(f\"Parameters per layer: {params_per_layer}\")\n\n    self.batch_shape = (1, 1)\n    # this will also be re-used in the init method,\n    # however, only if nothing is provided\n    self._inialization_strategy = initialization\n    self._initialization_domain = initialization_domain\n\n    # ..here! where we only require a rng\n    self.initialize_params(np.random.default_rng(random_seed))\n\n    # Initialize two circuits, one with the default device and\n    # one with the mixed device\n    # which allows us to later route depending on the state_vector flag\n    self.as_pauli_circuit = as_pauli_circuit\n\n    self.circuit_mixed: qml.QNode = qml.QNode(\n        self._circuit,\n        qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.draw","title":"<code>draw(inputs=None, figure='text', *args, **kwargs)</code>","text":"<p>Draws the quantum circuit using the specified visualization method.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>Input vector for the circuit. If None, the default inputs are used.</p> <code>None</code> <code>figure</code> <code>str</code> <p>The type of figure to generate. Must be one of 'text', 'mpl', or 'tikz'. Defaults to 'text'.</p> <code>'text'</code> <p>Returns:     Either a string, matplotlib figure or TikzFigure object (similar to string)     depending on the chosen visualization. args:     Additional arguments to be passed to the visualization method. *kwargs:     Additional keyword arguments to be passed to the visualization method.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the 'figure' argument is not one of the accepted values.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def draw(self, inputs=None, figure=\"text\", *args, **kwargs):\n    \"\"\"\n    Draws the quantum circuit using the specified visualization method.\n\n    Args:\n        inputs (Optional[np.ndarray]): Input vector for the circuit. If None,\n            the default inputs are used.\n        figure (str, optional): The type of figure to generate. Must be one of\n            'text', 'mpl', or 'tikz'. Defaults to 'text'.\n    Returns:\n        Either a string, matplotlib figure or TikzFigure object (similar to string)\n        depending on the chosen visualization.\n    *args:\n        Additional arguments to be passed to the visualization method.\n    **kwargs:\n        Additional keyword arguments to be passed to the visualization method.\n\n    Raises:\n        AssertionError: If the 'figure' argument is not one of the accepted values.\n    \"\"\"\n\n    if not isinstance(self.circuit, qml.QNode):\n        # TODO: throws strange argument error if not catched\n        return \"\"\n\n    assert figure in [\n        \"text\",\n        \"mpl\",\n        \"tikz\",\n    ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n    inputs = self._inputs_validation(inputs)\n\n    if figure == \"mpl\":\n        result = qml.draw_mpl(self.circuit)(\n            params=self.params,\n            inputs=inputs,\n            enc_params=self.enc_params,\n            *args,\n            **kwargs,\n        )\n    elif figure == \"tikz\":\n        result = QuanTikz.build(\n            self.circuit,\n            params=self.params,\n            inputs=inputs,\n            enc_params=self.enc_params,\n            *args,\n            **kwargs,\n        )\n    else:\n        result = qml.draw(self.circuit)(\n            params=self.params, inputs=inputs, enc_params=self.enc_params\n        )\n    return result\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.get_circuit_depth","title":"<code>get_circuit_depth(inputs=None)</code>","text":"<p>Obtain circuit depth for the model</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>The inputs, with which to call the circuit. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Circuit depth (longest path of gates in circuit.)</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def get_circuit_depth(self, inputs: Optional[np.ndarray] = None) -&gt; int:\n    \"\"\"\n    Obtain circuit depth for the model\n\n    Args:\n        inputs (Optional[np.ndarray]): The inputs, with which to call the\n            circuit. Defaults to None.\n\n    Returns:\n        int: Circuit depth (longest path of gates in circuit.)\n    \"\"\"\n    return self.get_specs(inputs)[\"resources\"].depth\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.get_specs","title":"<code>get_specs(inputs=None)</code>","text":"<p>Get pennylane specs for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>The inputs, with which to call the circuit. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of specs. The key \"resources\" contains information about the circuit size and gate statistics.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def get_specs(self, inputs: Optional[np.ndarray] = None) -&gt; dict:\n    \"\"\"\n    Get pennylane specs for the model.\n\n    Args:\n        inputs (Optional[np.ndarray]): The inputs, with which to call the\n            circuit. Defaults to None.\n\n    Returns:\n        dict: Dictionary of specs. The key \"resources\" contains information\n            about the circuit size and gate statistics.\n    \"\"\"\n    inputs = self._inputs_validation(inputs)\n    spec_model = deepcopy(self)\n    spec_model.noise_params = None  # remove noise\n    return qml.specs(spec_model.circuit)(self.params, inputs)\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.initialize_params","title":"<code>initialize_params(rng, repeat=None, initialization=None, initialization_domain=None)</code>","text":"<p>Initializes the parameters of the model.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator to use for initialization.</p> required <code>repeat</code> <code>int</code> <p>The number of times to repeat the parameters. If None, the number of layers is used.</p> <code>None</code> <code>initialization</code> <code>str</code> <p>The strategy to use for parameter initialization. If None, the strategy specified in the constructor is used.</p> <code>None</code> <code>initialization_domain</code> <code>List[float]</code> <p>The domain to use for parameter initialization. If None, the domain specified in the constructor is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def initialize_params(\n    self,\n    rng: np.random.Generator,\n    repeat: int = None,\n    initialization: str = None,\n    initialization_domain: List[float] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes the parameters of the model.\n\n    Args:\n        rng: A random number generator to use for initialization.\n        repeat: The number of times to repeat the parameters.\n            If None, the number of layers is used.\n        initialization: The strategy to use for parameter initialization.\n            If None, the strategy specified in the constructor is used.\n        initialization_domain: The domain to use for parameter initialization.\n            If None, the domain specified in the constructor is used.\n\n    Returns:\n        None\n    \"\"\"\n    params_shape = (\n        self._params_shape if repeat is None else [*self._params_shape, repeat]\n    )\n    # use existing strategy if not specified\n    initialization = initialization or self._inialization_strategy\n    initialization_domain = initialization_domain or self._initialization_domain\n\n    def set_control_params(params: np.ndarray, value: float) -&gt; np.ndarray:\n        indices = self.pqc.get_control_indices(self.n_qubits)\n        if indices is None:\n            warnings.warn(\n                f\"Specified {initialization} but circuit\\\n                does not contain controlled rotation gates.\\\n                Parameters are intialized randomly.\",\n                UserWarning,\n            )\n        else:\n            params[:, indices[0] : indices[1] : indices[2]] = (\n                np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                * value\n            )\n        return params\n\n    if initialization == \"random\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n    elif initialization == \"zeros\":\n        self.params: np.ndarray = np.zeros(params_shape, requires_grad=True)\n    elif initialization == \"pi\":\n        self.params: np.ndarray = np.ones(params_shape, requires_grad=True) * np.pi\n    elif initialization == \"zero-controlled\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n        self.params = set_control_params(self.params, 0)\n    elif initialization == \"pi-controlled\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n        self.params = set_control_params(self.params, np.pi)\n    else:\n        raise Exception(\"Invalid initialization method\")\n\n    log.info(\n        f\"Initialized parameters with shape {self.params.shape}\\\n        using strategy {initialization}.\"\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.transform_input","title":"<code>transform_input(inputs, enc_params)</code>","text":"<p>Transforms the input as in arXiv:2309.03279v2</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ndarray</code> <p>single input point of shape (1, n_input_feat)</p> required <code>idx</code> <code>int</code> <p>feature index</p> required <code>qubit</code> <code>int</code> <p>qubit on which to the encoding is being performed</p> required <code>enc_params</code> <code>ndarray</code> <p>encoding weight vector of shape (n_qubits)</p> required <p>Returns:</p> Type Description <p>np.ndarray: transformed input of shape (1,), linearly scaled by</p> <p>enc_params, ready for encoding</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def transform_input(self, inputs: np.ndarray, enc_params: Optional[np.ndarray]):\n    \"\"\"\n    Transforms the input as in arXiv:2309.03279v2\n\n    Args:\n        inputs (np.ndarray): single input point of shape (1, n_input_feat)\n        idx (int): feature index\n        qubit (int): qubit on which to the encoding is being performed\n        enc_params (np.ndarray): encoding weight vector of\n            shape (n_qubits)\n\n    Returns:\n        np.ndarray: transformed input of shape (1,), linearly scaled by\n        enc_params, ready for encoding\n    \"\"\"\n    return inputs * enc_params\n</code></pre>"},{"location":"references/#entanglement","title":"Entanglement","text":"<pre><code>from qml_essentials.entanglement import Entanglement\n</code></pre> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>class Entanglement:\n\n    @staticmethod\n    def meyer_wallach(\n        model: Model,\n        n_samples: Optional[int | None],\n        seed: Optional[int],\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the entangling capacity of a given quantum circuit\n        using Meyer-Wallach measure.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (Optional[int]): Number of samples per qubit.\n                If None or &lt; 0, the current parameters of the model are used.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        if \"noise_params\" in kwargs:\n            log.warning(\n                \"Meyer-Wallach measure not suitable for noisy circuits.\\\n                    Consider 'relative_entropy' instead.\"\n            )\n\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n\n        rng = np.random.default_rng(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            # TODO: maybe switch to JAX rng\n            model.initialize_params(rng=rng, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        # explicitly set execution type because everything else won't work\n        rhos = model(execution_type=\"density\", **kwargs).reshape(\n            -1, 2**model.n_qubits, 2**model.n_qubits\n        )\n\n        mw_measure = np.zeros(len(rhos))\n\n        for i, rho in enumerate(rhos):\n            mw_measure[i] = Entanglement._compute_meyer_wallach_meas(\n                rho, model.n_qubits\n            )\n\n        # Average all iterated states\n        entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n        log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n        # catch floating point errors\n        return float(entangling_capability)\n\n    @staticmethod\n    def _compute_meyer_wallach_meas(rho: np.ndarray, n_qubits: int):\n        qb = list(range(n_qubits))\n        entropy = 0\n        for j in range(n_qubits):\n            # Formula 6 in https://doi.org/10.48550/arXiv.quant-ph/0305094\n            density = qml.math.partial_trace(rho, qb[:j] + qb[j + 1 :])\n            # only real values, because imaginary part will be separate\n            # in all following calculations anyway\n            # entropy should be 1/2 &lt;= entropy &lt;= 1\n            entropy += np.trace((density @ density).real)\n\n        # inverse averaged entropy and scale to [0, 1]\n        return 2 * (1 - entropy / n_qubits)\n\n    @staticmethod\n    def bell_measurements(\n        model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n    ) -&gt; float:\n        \"\"\"\n        Compute the Bell measurement for a given model.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): The number of samples to compute the measure for.\n            seed (int): The seed for the random number generator.\n            scale (bool): Whether to scale the number of samples\n                according to the number of qubits.\n            **kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: The Bell measurement value.\n        \"\"\"\n        if \"noise_params\" in kwargs:\n            log.warning(\n                \"Bell Measurements not suitable for noisy circuits.\\\n                    Consider 'relative_entropy' instead.\"\n            )\n\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n\n        def _circuit(\n                params: np.ndarray, inputs: np.ndarray,\n                enc_params: Optional[np.ndarray] = None\n        ) -&gt; List[np.ndarray]:\n            \"\"\"\n            Compute the Bell measurement circuit.\n\n            Args:\n                params (np.ndarray): The model parameters.\n                inputs (np.ndarray): The input to the model.\n                enc_params (Optional[np.ndarray]): The frequency encoding parameters.\n\n            Returns:\n                List[np.ndarray]: The probabilities of the Bell measurement.\n            \"\"\"\n            model._variational(params, inputs, enc_params)\n\n            qml.map_wires(\n                model._variational,\n                {i: i + model.n_qubits for i in range(model.n_qubits)},\n            )(params, inputs)\n\n            for q in range(model.n_qubits):\n                qml.CNOT(wires=[q, q + model.n_qubits])\n                qml.H(q)\n\n            obs_wires = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n            return [qml.probs(wires=w) for w in obs_wires]\n\n        model.circuit = qml.QNode(\n            _circuit,\n            qml.device(\n                \"default.qubit\",\n                shots=model.shots,\n                wires=model.n_qubits * 2,\n            ),\n        )\n\n        rng = np.random.default_rng(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            # TODO: maybe switch to JAX rng\n            model.initialize_params(rng=rng, repeat=n_samples)\n            params = model.params\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n                params = model.params\n\n        n_samples = params.shape[-1]\n        mw_measure = np.zeros(n_samples)\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        exp = model(params=params, **kwargs)\n        exp = 1 - 2 * exp[:, :, -1]\n        mw_measure = 2 * (1 - exp.mean(axis=0))\n        entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n        log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n        return float(entangling_capability)\n\n    @staticmethod\n    def relative_entropy(\n        model: Model,\n        n_samples: int,\n        n_sigmas: int,\n        seed: Optional[int],\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the relative entropy of entanglement of a given quantum\n        circuit. This measure is also applicable to mixed state, albeit it\n        might me not fully accurate in this simplified case.\n\n        As the relative entropy is generally defined as the smallest relative\n        entropy from the state in question to the set of separable states.\n        However, as computing the nearest separable state is NP-hard, we select\n        n_sigmas of random separable states to compute the distance to, which\n        is not necessarily the nearest. Thus, this measure of entanglement\n        presents an upper limit of entanglement.\n\n        As the relative entropy is not necessarily between zero and one, this\n        function also normalises by the relative entroy to the GHZ state.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): Number of samples per qubit.\n                If &lt;= 0, the current parameters of the model are used.\n            n_sigmas (int): Number of random separable pure states to compare against.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        dim = np.power(2, model.n_qubits)\n        if scale:\n            n_samples = dim * n_samples\n            n_sigmas = dim * n_sigmas\n\n        rng = np.random.default_rng(seed)\n\n        # Random separable states\n        log_sigmas = sample_random_separable_states(\n            model.n_qubits, n_samples=n_sigmas, rng=rng, take_log=True\n        )\n\n        if n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            model.initialize_params(rng=rng, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                model.params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n        ghz_model = Model(model.n_qubits, 1, \"GHZ\", data_reupload=False)\n\n        normalised_entropies = np.zeros((n_sigmas, n_samples))\n        for j, log_sigma in enumerate(log_sigmas):\n\n            # Entropy of GHZ states should be maximal\n            ghz_entropy = Entanglement._compute_rel_entropies(\n                ghz_model,\n                log_sigma,\n            )\n\n            rel_entropy = Entanglement._compute_rel_entropies(\n                model, log_sigma, **kwargs\n            )\n\n            normalised_entropies[j] = rel_entropy / ghz_entropy\n\n        # Average all iterated states\n        entangling_capability = normalised_entropies.min(axis=0).mean()\n        log.debug(f\"Variance of measure: {normalised_entropies.var()}\")\n\n        return entangling_capability\n\n    @staticmethod\n    def _compute_rel_entropies(\n        model: Model,\n        log_sigma: np.ndarray,\n        **kwargs,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Compute the relative entropy for a given model.\n\n        Args:\n            model (Model): The model for which to compute entanglement\n            log_sigma (np.ndarray): Density matrix of next separable state\n\n        Returns:\n            np.ndarray: Relative Entropy for each sample\n        \"\"\"\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        # explicitly set execution type because everything else won't work\n        rho = model(execution_type=\"density\", **kwargs)\n        rho = rho.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n        log_rho = logm_v(rho) / np.log(2)\n\n        rel_entropies = np.abs(np.trace(rho @ (log_rho - log_sigma), axis1=1, axis2=2))\n\n        return rel_entropies\n\n    @staticmethod\n    def entanglement_of_formation(\n        model: Model,\n        n_samples: int,\n        seed: Optional[int],\n        scale: bool = False,\n        always_decompose: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        This function implements the entanglement of formation for mixed\n        quantum systems.\n        In that a mixed state gets decomposed into pure states with respective\n        probabilities using the eigendecomposition of the density matrix.\n        Then, the Meyer-Wallach measure is computed for each pure state,\n        weighted by the eigenvalue.\n        See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163\n\n        Note that the decomposition is *not unique*! Therefore, this measure\n        presents the entanglement for *some* decomposition into pure states,\n        not necessarily the one that is anticipated when applying the Kraus\n        channels.\n        If a pure state is provided, this results in the same value as the\n        Entanglement.meyer_wallach function if `always_decompose` flag is not set.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): Number of samples per qubit.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            always_decompose (bool): Whether to explicitly compute the\n                entantlement of formation for the eigendecomposition of a pure\n                state.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n\n        rng = np.random.default_rng(seed)\n        if n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            model.initialize_params(rng=rng, repeat=n_samples)\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                model.params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        rhos = model(execution_type=\"density\", **kwargs)\n        rhos = rhos.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n        entanglement = np.zeros(len(rhos))\n        for i, rho in enumerate(rhos):\n            entanglement[i] = Entanglement._compute_entanglement_of_formation(\n                rho, model.n_qubits, always_decompose\n            )\n        entangling_capability = min(max(entanglement.mean(), 0.0), 1.0)\n        return float(entangling_capability)\n\n    @staticmethod\n    def _compute_entanglement_of_formation(\n        rho: np.ndarray, n_qubits: int, always_decompose: bool\n    ) -&gt; float:\n        \"\"\"\n        Computes the entanglement of formation for a given density matrix rho.\n\n        Args:\n            rho (np.ndarray): The density matrix\n            n_qubits (int): Number of qubits\n            always_decompose (bool): Whether to explicitly compute the\n                entantlement of formation for the eigendecomposition of a pure\n                state.\n\n        Returns:\n            float: Entanglement for the provided state.\n        \"\"\"\n        eigenvalues, eigenvectors = np.linalg.eigh(rho)\n        if any(np.isclose(eigenvalues, 1.0)) and not always_decompose:  # Pure state\n            return Entanglement._compute_meyer_wallach_meas(rho, n_qubits)\n        ent = 0\n        for prob, ev in zip(eigenvalues, eigenvectors):\n            ev = ev.reshape(-1, 1)\n            rho = ev @ np.conjugate(ev).T\n            mw_measure = Entanglement._compute_meyer_wallach_meas(rho, n_qubits)\n            ent += prob * mw_measure\n        return ent\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.bell_measurements","title":"<code>bell_measurements(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Compute the Bell measurement for a given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>The number of samples to compute the measure for.</p> required <code>seed</code> <code>int</code> <p>The seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples according to the number of qubits.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Bell measurement value.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef bell_measurements(\n    model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n) -&gt; float:\n    \"\"\"\n    Compute the Bell measurement for a given model.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): The number of samples to compute the measure for.\n        seed (int): The seed for the random number generator.\n        scale (bool): Whether to scale the number of samples\n            according to the number of qubits.\n        **kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: The Bell measurement value.\n    \"\"\"\n    if \"noise_params\" in kwargs:\n        log.warning(\n            \"Bell Measurements not suitable for noisy circuits.\\\n                Consider 'relative_entropy' instead.\"\n        )\n\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n\n    def _circuit(\n            params: np.ndarray, inputs: np.ndarray,\n            enc_params: Optional[np.ndarray] = None\n    ) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the Bell measurement circuit.\n\n        Args:\n            params (np.ndarray): The model parameters.\n            inputs (np.ndarray): The input to the model.\n            enc_params (Optional[np.ndarray]): The frequency encoding parameters.\n\n        Returns:\n            List[np.ndarray]: The probabilities of the Bell measurement.\n        \"\"\"\n        model._variational(params, inputs, enc_params)\n\n        qml.map_wires(\n            model._variational,\n            {i: i + model.n_qubits for i in range(model.n_qubits)},\n        )(params, inputs)\n\n        for q in range(model.n_qubits):\n            qml.CNOT(wires=[q, q + model.n_qubits])\n            qml.H(q)\n\n        obs_wires = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n        return [qml.probs(wires=w) for w in obs_wires]\n\n    model.circuit = qml.QNode(\n        _circuit,\n        qml.device(\n            \"default.qubit\",\n            shots=model.shots,\n            wires=model.n_qubits * 2,\n        ),\n    )\n\n    rng = np.random.default_rng(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        # TODO: maybe switch to JAX rng\n        model.initialize_params(rng=rng, repeat=n_samples)\n        params = model.params\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n            params = model.params\n\n    n_samples = params.shape[-1]\n    mw_measure = np.zeros(n_samples)\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    exp = model(params=params, **kwargs)\n    exp = 1 - 2 * exp[:, :, -1]\n    mw_measure = 2 * (1 - exp.mean(axis=0))\n    entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n    log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.entanglement_of_formation","title":"<code>entanglement_of_formation(model, n_samples, seed, scale=False, always_decompose=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>This function implements the entanglement of formation for mixed quantum systems. In that a mixed state gets decomposed into pure states with respective probabilities using the eigendecomposition of the density matrix. Then, the Meyer-Wallach measure is computed for each pure state, weighted by the eigenvalue. See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163</p> <p>Note that the decomposition is not unique! Therefore, this measure presents the entanglement for some decomposition into pure states, not necessarily the one that is anticipated when applying the Kraus channels. If a pure state is provided, this results in the same value as the Entanglement.meyer_wallach function if <code>always_decompose</code> flag is not set.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>Number of samples per qubit.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>always_decompose</code> <code>bool</code> <p>Whether to explicitly compute the entantlement of formation for the eigendecomposition of a pure state.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef entanglement_of_formation(\n    model: Model,\n    n_samples: int,\n    seed: Optional[int],\n    scale: bool = False,\n    always_decompose: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    This function implements the entanglement of formation for mixed\n    quantum systems.\n    In that a mixed state gets decomposed into pure states with respective\n    probabilities using the eigendecomposition of the density matrix.\n    Then, the Meyer-Wallach measure is computed for each pure state,\n    weighted by the eigenvalue.\n    See e.g. https://doi.org/10.48550/arXiv.quant-ph/0504163\n\n    Note that the decomposition is *not unique*! Therefore, this measure\n    presents the entanglement for *some* decomposition into pure states,\n    not necessarily the one that is anticipated when applying the Kraus\n    channels.\n    If a pure state is provided, this results in the same value as the\n    Entanglement.meyer_wallach function if `always_decompose` flag is not set.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): Number of samples per qubit.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        always_decompose (bool): Whether to explicitly compute the\n            entantlement of formation for the eigendecomposition of a pure\n            state.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n\n    rng = np.random.default_rng(seed)\n    if n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        model.initialize_params(rng=rng, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            model.params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    rhos = model(execution_type=\"density\", **kwargs)\n    rhos = rhos.reshape(-1, 2**model.n_qubits, 2**model.n_qubits)\n    entanglement = np.zeros(len(rhos))\n    for i, rho in enumerate(rhos):\n        entanglement[i] = Entanglement._compute_entanglement_of_formation(\n            rho, model.n_qubits, always_decompose\n        )\n    entangling_capability = min(max(entanglement.mean(), 0.0), 1.0)\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.meyer_wallach","title":"<code>meyer_wallach(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Calculates the entangling capacity of a given quantum circuit using Meyer-Wallach measure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>Optional[int]</code> <p>Number of samples per qubit. If None or &lt; 0, the current parameters of the model are used.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef meyer_wallach(\n    model: Model,\n    n_samples: Optional[int | None],\n    seed: Optional[int],\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Calculates the entangling capacity of a given quantum circuit\n    using Meyer-Wallach measure.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (Optional[int]): Number of samples per qubit.\n            If None or &lt; 0, the current parameters of the model are used.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    if \"noise_params\" in kwargs:\n        log.warning(\n            \"Meyer-Wallach measure not suitable for noisy circuits.\\\n                Consider 'relative_entropy' instead.\"\n        )\n\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n\n    rng = np.random.default_rng(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        # TODO: maybe switch to JAX rng\n        model.initialize_params(rng=rng, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n    # implicitly set input to none in case it's not needed\n    kwargs.setdefault(\"inputs\", None)\n    # explicitly set execution type because everything else won't work\n    rhos = model(execution_type=\"density\", **kwargs).reshape(\n        -1, 2**model.n_qubits, 2**model.n_qubits\n    )\n\n    mw_measure = np.zeros(len(rhos))\n\n    for i, rho in enumerate(rhos):\n        mw_measure[i] = Entanglement._compute_meyer_wallach_meas(\n            rho, model.n_qubits\n        )\n\n    # Average all iterated states\n    entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n    log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n    # catch floating point errors\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.relative_entropy","title":"<code>relative_entropy(model, n_samples, n_sigmas, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Calculates the relative entropy of entanglement of a given quantum circuit. This measure is also applicable to mixed state, albeit it might me not fully accurate in this simplified case.</p> <p>As the relative entropy is generally defined as the smallest relative entropy from the state in question to the set of separable states. However, as computing the nearest separable state is NP-hard, we select n_sigmas of random separable states to compute the distance to, which is not necessarily the nearest. Thus, this measure of entanglement presents an upper limit of entanglement.</p> <p>As the relative entropy is not necessarily between zero and one, this function also normalises by the relative entroy to the GHZ state.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>Number of samples per qubit. If &lt;= 0, the current parameters of the model are used.</p> required <code>n_sigmas</code> <code>int</code> <p>Number of random separable pure states to compare against.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef relative_entropy(\n    model: Model,\n    n_samples: int,\n    n_sigmas: int,\n    seed: Optional[int],\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Calculates the relative entropy of entanglement of a given quantum\n    circuit. This measure is also applicable to mixed state, albeit it\n    might me not fully accurate in this simplified case.\n\n    As the relative entropy is generally defined as the smallest relative\n    entropy from the state in question to the set of separable states.\n    However, as computing the nearest separable state is NP-hard, we select\n    n_sigmas of random separable states to compute the distance to, which\n    is not necessarily the nearest. Thus, this measure of entanglement\n    presents an upper limit of entanglement.\n\n    As the relative entropy is not necessarily between zero and one, this\n    function also normalises by the relative entroy to the GHZ state.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): Number of samples per qubit.\n            If &lt;= 0, the current parameters of the model are used.\n        n_sigmas (int): Number of random separable pure states to compare against.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    dim = np.power(2, model.n_qubits)\n    if scale:\n        n_samples = dim * n_samples\n        n_sigmas = dim * n_sigmas\n\n    rng = np.random.default_rng(seed)\n\n    # Random separable states\n    log_sigmas = sample_random_separable_states(\n        model.n_qubits, n_samples=n_sigmas, rng=rng, take_log=True\n    )\n\n    if n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        model.initialize_params(rng=rng, repeat=n_samples)\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            model.params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n\n    ghz_model = Model(model.n_qubits, 1, \"GHZ\", data_reupload=False)\n\n    normalised_entropies = np.zeros((n_sigmas, n_samples))\n    for j, log_sigma in enumerate(log_sigmas):\n\n        # Entropy of GHZ states should be maximal\n        ghz_entropy = Entanglement._compute_rel_entropies(\n            ghz_model,\n            log_sigma,\n        )\n\n        rel_entropy = Entanglement._compute_rel_entropies(\n            model, log_sigma, **kwargs\n        )\n\n        normalised_entropies[j] = rel_entropy / ghz_entropy\n\n    # Average all iterated states\n    entangling_capability = normalised_entropies.min(axis=0).mean()\n    log.debug(f\"Variance of measure: {normalised_entropies.var()}\")\n\n    return entangling_capability\n</code></pre>"},{"location":"references/#expressibility","title":"Expressibility","text":"<pre><code>from qml_essentials.expressibility import Expressibility\n</code></pre> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>class Expressibility:\n    @staticmethod\n    def _sample_state_fidelities(\n        model: Model,\n        x_samples: np.ndarray,\n        n_samples: int,\n        seed: int,\n        kwargs: Any,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Compute the fidelities for each pair of input samples and parameter sets.\n\n        Args:\n            model (Callable): Function that models the quantum circuit.\n            x_samples (np.ndarray): Array of shape (n_input_samples, n_features)\n                containing the input samples.\n            n_samples (int): Number of parameter sets to generate.\n            seed (int): Random number generator seed.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            np.ndarray: Array of shape (n_input_samples, n_samples)\n            containing the fidelities.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # Generate random parameter sets\n        # We need two sets of parameters, as we are computing fidelities for a\n        # pair of random state vectors\n        model.initialize_params(rng=rng, repeat=n_samples * 2)\n\n        # Initialize array to store fidelities\n        fidelities: np.ndarray = np.zeros((len(x_samples), n_samples))\n\n        # Compute the fidelity for each pair of input samples and parameters\n        for idx, x_sample in enumerate(x_samples):\n\n            # Evaluate the model for the current pair of input samples and parameters\n            # Execution type is explicitly set to density\n            sv: np.ndarray = model(\n                inputs=x_sample,\n                params=model.params,\n                execution_type=\"density\",\n                **kwargs,\n            )\n\n            # $\\sqrt{\\rho}$\n            sqrt_sv1: np.ndarray = np.array([sqrtm(m) for m in sv[:n_samples]])\n\n            # $\\sqrt{\\rho} \\sigma \\sqrt{\\rho}$\n            inner_fidelity = sqrt_sv1 @ sv[n_samples:] @ sqrt_sv1\n\n            # Compute the fidelity using the partial trace of the statevector\n            fidelity: np.ndarray = (\n                np.trace(\n                    np.array([sqrtm(m) for m in inner_fidelity]),\n                    axis1=1,\n                    axis2=2,\n                )\n                ** 2\n            )\n\n            fidelities[idx] = np.abs(fidelity)\n\n        return fidelities\n\n    @staticmethod\n    def state_fidelities(\n        seed: int,\n        n_samples: int,\n        n_bins: int,\n        model: Model,\n        n_input_samples: int = 0,\n        input_domain: List[float] = None,\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Sample the state fidelities and histogram them into a 2D array.\n\n        Args:\n            seed (int): Random number generator seed.\n            n_samples (int): Number of parameter sets to generate.\n            n_bins (int): Number of histogram bins.\n            n_input_samples (int): Number of input samples.\n            input_domain (List[float]): Input domain.\n            model (Callable): Function that models the quantum circuit.\n            scale (bool): Whether to scale the number of samples and bins.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the\n                input samples, bin edges, and histogram values.\n        \"\"\"\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n            n_bins = model.n_qubits * n_bins\n\n        if input_domain is None or n_input_samples is None or n_input_samples == 0:\n            x = np.zeros((1))\n            n_input_samples = 1\n        else:\n            x = np.linspace(*input_domain, n_input_samples, requires_grad=False)\n\n        fidelities = Expressibility._sample_state_fidelities(\n            x_samples=x,\n            n_samples=n_samples,\n            seed=seed,\n            model=model,\n            kwargs=kwargs,\n        )\n        z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n        y: np.ndarray = np.linspace(0, 1, n_bins + 1)\n\n        for i, f in enumerate(fidelities):\n            z[i], _ = np.histogram(f, bins=y)\n\n        z = z / n_samples\n\n        if z.shape[0] == 1:\n            z = z.flatten()\n\n        return x, y, z\n\n    @staticmethod\n    def _haar_probability(fidelity: float, n_qubits: int) -&gt; float:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876).\n\n        Args:\n            fidelity (float): fidelity of two parameter assignments in [0, 1]\n            n_qubits (int): number of qubits in the quantum system\n\n        Returns:\n            float: probability for a given fidelity\n        \"\"\"\n        N = 2**n_qubits\n\n        prob = (N - 1) * (1 - fidelity) ** (N - 2)\n        return prob\n\n    @staticmethod\n    def _sample_haar_integral(n_qubits: int, n_bins: int) -&gt; np.ndarray:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 2D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n\n        Returns:\n            np.ndarray: probability distribution for all fidelities\n        \"\"\"\n        dist = np.zeros(n_bins)\n        for idx in range(n_bins):\n            v = idx / n_bins\n            u = (idx + 1) / n_bins\n            dist[idx], _ = integrate.quad(\n                Expressibility._haar_probability, v, u, args=(n_qubits,)\n            )\n\n        return dist\n\n    @staticmethod\n    def haar_integral(\n        n_qubits: int,\n        n_bins: int,\n        cache: bool = True,\n        scale: bool = False,\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 3D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n            cache (bool): whether to cache the haar integral\n            scale (bool): whether to scale the number of bins\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]:\n                - x component (bins): the input domain\n                - y component (probabilities): the haar probability density\n                  funtion for random Haar states\n        \"\"\"\n        if scale:\n            n_bins = n_qubits * n_bins\n\n        x = np.linspace(0, 1, n_bins)\n\n        if cache:\n            name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n            cache_folder = \".cache\"\n            if not os.path.exists(cache_folder):\n                os.mkdir(cache_folder)\n\n            file_path = os.path.join(cache_folder, name)\n\n            if os.path.isfile(file_path):\n                y = np.load(file_path)\n                return x, y\n\n        y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n        if cache:\n            np.save(file_path, y)\n\n        return x, y\n\n    @staticmethod\n    def kullback_leibler_divergence(\n        vqc_prob_dist: np.ndarray,\n        haar_dist: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the KL divergence between two probability distributions (Haar\n        probability distribution and the fidelity distribution sampled from a VQC).\n\n        Args:\n            vqc_prob_dist (np.ndarray): VQC fidelity probability distribution.\n                Should have shape (n_inputs_samples, n_bins)\n            haar_dist (np.ndarray): Haar probability distribution with shape.\n                Should have shape (n_bins, )\n\n        Returns:\n            np.ndarray: Array of KL-Divergence values for all values in axis 1\n        \"\"\"\n        if len(vqc_prob_dist.shape) &gt; 1:\n            assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n                \"All probabilities for inputs should have the same shape as Haar. \"\n                f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n            )\n        else:\n            vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n        kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n        for idx, p in enumerate(vqc_prob_dist):\n            kl_divergence[idx] = np.sum(rel_entr(p, haar_dist))\n\n        return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.haar_integral","title":"<code>haar_integral(n_qubits, n_bins, cache=True, scale=False)</code>  <code>staticmethod</code>","text":"<p>Calculates theoretical probability density function for random Haar states as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it into a 3D-histogram.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>number of qubits in the quantum system</p> required <code>n_bins</code> <code>int</code> <p>number of histogram bins</p> required <code>cache</code> <code>bool</code> <p>whether to cache the haar integral</p> <code>True</code> <code>scale</code> <code>bool</code> <p>whether to scale the number of bins</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: - x component (bins): the input domain - y component (probabilities): the haar probability density   funtion for random Haar states</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef haar_integral(\n    n_qubits: int,\n    n_bins: int,\n    cache: bool = True,\n    scale: bool = False,\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates theoretical probability density function for random Haar states\n    as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n    into a 3D-histogram.\n\n    Args:\n        n_qubits (int): number of qubits in the quantum system\n        n_bins (int): number of histogram bins\n        cache (bool): whether to cache the haar integral\n        scale (bool): whether to scale the number of bins\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]:\n            - x component (bins): the input domain\n            - y component (probabilities): the haar probability density\n              funtion for random Haar states\n    \"\"\"\n    if scale:\n        n_bins = n_qubits * n_bins\n\n    x = np.linspace(0, 1, n_bins)\n\n    if cache:\n        name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n        cache_folder = \".cache\"\n        if not os.path.exists(cache_folder):\n            os.mkdir(cache_folder)\n\n        file_path = os.path.join(cache_folder, name)\n\n        if os.path.isfile(file_path):\n            y = np.load(file_path)\n            return x, y\n\n    y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n    if cache:\n        np.save(file_path, y)\n\n    return x, y\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.kullback_leibler_divergence","title":"<code>kullback_leibler_divergence(vqc_prob_dist, haar_dist)</code>  <code>staticmethod</code>","text":"<p>Calculates the KL divergence between two probability distributions (Haar probability distribution and the fidelity distribution sampled from a VQC).</p> <p>Parameters:</p> Name Type Description Default <code>vqc_prob_dist</code> <code>ndarray</code> <p>VQC fidelity probability distribution. Should have shape (n_inputs_samples, n_bins)</p> required <code>haar_dist</code> <code>ndarray</code> <p>Haar probability distribution with shape. Should have shape (n_bins, )</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of KL-Divergence values for all values in axis 1</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef kullback_leibler_divergence(\n    vqc_prob_dist: np.ndarray,\n    haar_dist: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the KL divergence between two probability distributions (Haar\n    probability distribution and the fidelity distribution sampled from a VQC).\n\n    Args:\n        vqc_prob_dist (np.ndarray): VQC fidelity probability distribution.\n            Should have shape (n_inputs_samples, n_bins)\n        haar_dist (np.ndarray): Haar probability distribution with shape.\n            Should have shape (n_bins, )\n\n    Returns:\n        np.ndarray: Array of KL-Divergence values for all values in axis 1\n    \"\"\"\n    if len(vqc_prob_dist.shape) &gt; 1:\n        assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n            \"All probabilities for inputs should have the same shape as Haar. \"\n            f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n        )\n    else:\n        vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n    kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n    for idx, p in enumerate(vqc_prob_dist):\n        kl_divergence[idx] = np.sum(rel_entr(p, haar_dist))\n\n    return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.state_fidelities","title":"<code>state_fidelities(seed, n_samples, n_bins, model, n_input_samples=0, input_domain=None, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Sample the state fidelities and histogram them into a 2D array.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>Random number generator seed.</p> required <code>n_samples</code> <code>int</code> <p>Number of parameter sets to generate.</p> required <code>n_bins</code> <code>int</code> <p>Number of histogram bins.</p> required <code>n_input_samples</code> <code>int</code> <p>Number of input samples.</p> <code>0</code> <code>input_domain</code> <code>List[float]</code> <p>Input domain.</p> <code>None</code> <code>model</code> <code>Callable</code> <p>Function that models the quantum circuit.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples and bins.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the input samples, bin edges, and histogram values.</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef state_fidelities(\n    seed: int,\n    n_samples: int,\n    n_bins: int,\n    model: Model,\n    n_input_samples: int = 0,\n    input_domain: List[float] = None,\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Sample the state fidelities and histogram them into a 2D array.\n\n    Args:\n        seed (int): Random number generator seed.\n        n_samples (int): Number of parameter sets to generate.\n        n_bins (int): Number of histogram bins.\n        n_input_samples (int): Number of input samples.\n        input_domain (List[float]): Input domain.\n        model (Callable): Function that models the quantum circuit.\n        scale (bool): Whether to scale the number of samples and bins.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the\n            input samples, bin edges, and histogram values.\n    \"\"\"\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n        n_bins = model.n_qubits * n_bins\n\n    if input_domain is None or n_input_samples is None or n_input_samples == 0:\n        x = np.zeros((1))\n        n_input_samples = 1\n    else:\n        x = np.linspace(*input_domain, n_input_samples, requires_grad=False)\n\n    fidelities = Expressibility._sample_state_fidelities(\n        x_samples=x,\n        n_samples=n_samples,\n        seed=seed,\n        model=model,\n        kwargs=kwargs,\n    )\n    z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n    y: np.ndarray = np.linspace(0, 1, n_bins + 1)\n\n    for i, f in enumerate(fidelities):\n        z[i], _ = np.histogram(f, bins=y)\n\n    z = z / n_samples\n\n    if z.shape[0] == 1:\n        z = z.flatten()\n\n    return x, y, z\n</code></pre>"},{"location":"references/#coefficients","title":"Coefficients","text":"<pre><code>from qml_essentials.coefficients import Coefficients\n</code></pre> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>class Coefficients:\n\n    @staticmethod\n    def get_spectrum(\n        model: Model,\n        mfs: int = 1,\n        mts: int = 1,\n        shift=False,\n        trim=False,\n        **kwargs,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Extracts the coefficients of a given model using a FFT (np-fft).\n\n        Note that the coefficients are complex numbers, but the imaginary part\n        of the coefficients should be very close to zero, since the expectation\n        values of the Pauli operators are real numbers.\n\n        It can perform oversampling in both the frequency and time domain\n        using the `mfs` and `mts` arguments.\n\n        Args:\n            model (Model): The model to sample.\n            mfs (int): Multiplicator for the highest frequency. Default is 2.\n            mts (int): Multiplicator for the number of time samples. Default is 1.\n            shift (bool): Whether to apply np-fftshift. Default is False.\n            trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n                Default is False.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            np.ndarray: The sampled Fourier coefficients.\n        \"\"\"\n        kwargs.setdefault(\"force_mean\", True)\n        kwargs.setdefault(\"execution_type\", \"expval\")\n\n        coeffs, freqs = Coefficients._fourier_transform(\n            model, mfs=mfs, mts=mts, **kwargs\n        )\n\n        if not np.isclose(np.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n            raise ValueError(\n                f\"Spectrum is not real. Imaginary part of coefficients is:\\\n                {np.sum(coeffs).imag}\"\n            )\n\n        if trim:\n            for ax in range(len(coeffs.shape) - 1):\n                if coeffs.shape[ax] % 2 == 0:\n                    coeffs = np.delete(coeffs, len(coeffs) // 2, axis=ax)\n                    freqs = np.delete(freqs, len(freqs) // 2, axis=ax)\n\n        if shift:\n            return np.fft.fftshift(\n                coeffs, axes=list(range(model.n_input_feat))\n            ), np.fft.fftshift(freqs)\n        else:\n            return coeffs, freqs\n\n    @staticmethod\n    def _fourier_transform(\n        model: Model, mfs: int, mts: int, **kwargs: Any\n    ) -&gt; np.ndarray:\n        # Create a frequency vector with as many frequencies as model degrees,\n        # oversampled by nfs\n        n_freqs: int = 2 * mfs * model.degree + 1\n\n        start, stop, step = 0, 2 * mts * np.pi, 2 * np.pi / n_freqs\n        # Stretch according to the number of frequencies\n        inputs: np.ndarray = np.arange(start, stop, step) % (2 * np.pi)\n\n        # permute with input dimensionality\n        nd_inputs = np.array(np.meshgrid(*[inputs] * model.n_input_feat)).T.reshape(\n            -1, model.n_input_feat\n        )\n\n        # Output vector is not necessarily the same length as input\n        outputs = model(inputs=nd_inputs, **kwargs)\n        outputs = outputs.reshape(*(inputs.shape * model.n_input_feat), -1).squeeze()\n\n        coeffs = np.fft.fftn(outputs, axes=list(range(model.n_input_feat)))\n\n        # assert (\n        #     mts * n_freqs,\n        # ) * model.n_input_feat == coeffs.shape, f\"Expected shape\\\n        # {(mts * n_freqs,) * model.n_input_feat} but got {coeffs.shape}\"\n\n        freqs = np.fft.fftfreq(mts * n_freqs, 1 / n_freqs)\n\n        # TODO: this could cause issues with multidim input\n        # FIXME: account for different frequencies in multidim input scenarios\n        # Run the fft and rearrange +\n        # normalize the output (using product if multidim)\n        return (\n            coeffs / np.prod(outputs.shape[0 : model.n_input_feat]),\n            freqs,\n            # np.repeat(freqs[:, np.newaxis], model.n_input_feat, axis=1).squeeze(),\n        )\n\n    @staticmethod\n    def get_psd(coeffs: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n        Args:\n            coeffs (np.ndarray): The Fourier coefficients.\n\n        Returns:\n            np.ndarray: The power spectral density.\n        \"\"\"\n        # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n        def abs2(x):\n            return x.real**2 + x.imag**2\n\n        scale = 2.0 / (len(coeffs) ** 2)\n        return scale * abs2(coeffs)\n\n    @staticmethod\n    def evaluate_Fourier_series(\n        coefficients: np.ndarray,\n        frequencies: np.ndarray,\n        inputs: Union[np.ndarray, list, float],\n    ) -&gt; float:\n        \"\"\"\n        Evaluate the function value of a Fourier series at one point.\n\n        Args:\n            coefficients (np.ndarray): Coefficients of the Fourier series.\n            frequencies (np.ndarray): Corresponding frequencies.\n            inputs (np.ndarray): Point at which to evaluate the function.\n        Returns:\n            float: The function value at the input point.\n        \"\"\"\n        dims = len(coefficients.shape)\n\n        if not isinstance(inputs, (np.ndarray, list)):\n            inputs = [inputs]\n\n        frequencies = np.stack(np.meshgrid(*[frequencies] * dims)).T.reshape(-1, dims)\n        freq_inputs = np.einsum(\"...j,j-&gt;...\", frequencies, inputs)\n        coeffs = coefficients.flatten()\n        freq_inputs = freq_inputs.flatten()\n\n        exp = 0.0\n        for omega_x, c in zip(freq_inputs, coeffs):\n            exp += c * np.exp(1j * omega_x)\n\n        return np.real_if_close(exp)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.evaluate_Fourier_series","title":"<code>evaluate_Fourier_series(coefficients, frequencies, inputs)</code>  <code>staticmethod</code>","text":"<p>Evaluate the function value of a Fourier series at one point.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>Coefficients of the Fourier series.</p> required <code>frequencies</code> <code>ndarray</code> <p>Corresponding frequencies.</p> required <code>inputs</code> <code>ndarray</code> <p>Point at which to evaluate the function.</p> required <p>Returns:     float: The function value at the input point.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef evaluate_Fourier_series(\n    coefficients: np.ndarray,\n    frequencies: np.ndarray,\n    inputs: Union[np.ndarray, list, float],\n) -&gt; float:\n    \"\"\"\n    Evaluate the function value of a Fourier series at one point.\n\n    Args:\n        coefficients (np.ndarray): Coefficients of the Fourier series.\n        frequencies (np.ndarray): Corresponding frequencies.\n        inputs (np.ndarray): Point at which to evaluate the function.\n    Returns:\n        float: The function value at the input point.\n    \"\"\"\n    dims = len(coefficients.shape)\n\n    if not isinstance(inputs, (np.ndarray, list)):\n        inputs = [inputs]\n\n    frequencies = np.stack(np.meshgrid(*[frequencies] * dims)).T.reshape(-1, dims)\n    freq_inputs = np.einsum(\"...j,j-&gt;...\", frequencies, inputs)\n    coeffs = coefficients.flatten()\n    freq_inputs = freq_inputs.flatten()\n\n    exp = 0.0\n    for omega_x, c in zip(freq_inputs, coeffs):\n        exp += c * np.exp(1j * omega_x)\n\n    return np.real_if_close(exp)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_psd","title":"<code>get_psd(coeffs)</code>  <code>staticmethod</code>","text":"<p>Calculates the power spectral density (PSD) from given Fourier coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>The Fourier coefficients.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The power spectral density.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_psd(coeffs: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n    Args:\n        coeffs (np.ndarray): The Fourier coefficients.\n\n    Returns:\n        np.ndarray: The power spectral density.\n    \"\"\"\n    # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n    def abs2(x):\n        return x.real**2 + x.imag**2\n\n    scale = 2.0 / (len(coeffs) ** 2)\n    return scale * abs2(coeffs)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_spectrum","title":"<code>get_spectrum(model, mfs=1, mts=1, shift=False, trim=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Extracts the coefficients of a given model using a FFT (np-fft).</p> <p>Note that the coefficients are complex numbers, but the imaginary part of the coefficients should be very close to zero, since the expectation values of the Pauli operators are real numbers.</p> <p>It can perform oversampling in both the frequency and time domain using the <code>mfs</code> and <code>mts</code> arguments.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to sample.</p> required <code>mfs</code> <code>int</code> <p>Multiplicator for the highest frequency. Default is 2.</p> <code>1</code> <code>mts</code> <code>int</code> <p>Multiplicator for the number of time samples. Default is 1.</p> <code>1</code> <code>shift</code> <code>bool</code> <p>Whether to apply np-fftshift. Default is False.</p> <code>False</code> <code>trim</code> <code>bool</code> <p>Whether to remove the Nyquist frequency if spectrum is even. Default is False.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sampled Fourier coefficients.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_spectrum(\n    model: Model,\n    mfs: int = 1,\n    mts: int = 1,\n    shift=False,\n    trim=False,\n    **kwargs,\n) -&gt; np.ndarray:\n    \"\"\"\n    Extracts the coefficients of a given model using a FFT (np-fft).\n\n    Note that the coefficients are complex numbers, but the imaginary part\n    of the coefficients should be very close to zero, since the expectation\n    values of the Pauli operators are real numbers.\n\n    It can perform oversampling in both the frequency and time domain\n    using the `mfs` and `mts` arguments.\n\n    Args:\n        model (Model): The model to sample.\n        mfs (int): Multiplicator for the highest frequency. Default is 2.\n        mts (int): Multiplicator for the number of time samples. Default is 1.\n        shift (bool): Whether to apply np-fftshift. Default is False.\n        trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n            Default is False.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        np.ndarray: The sampled Fourier coefficients.\n    \"\"\"\n    kwargs.setdefault(\"force_mean\", True)\n    kwargs.setdefault(\"execution_type\", \"expval\")\n\n    coeffs, freqs = Coefficients._fourier_transform(\n        model, mfs=mfs, mts=mts, **kwargs\n    )\n\n    if not np.isclose(np.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n        raise ValueError(\n            f\"Spectrum is not real. Imaginary part of coefficients is:\\\n            {np.sum(coeffs).imag}\"\n        )\n\n    if trim:\n        for ax in range(len(coeffs.shape) - 1):\n            if coeffs.shape[ax] % 2 == 0:\n                coeffs = np.delete(coeffs, len(coeffs) // 2, axis=ax)\n                freqs = np.delete(freqs, len(freqs) // 2, axis=ax)\n\n    if shift:\n        return np.fft.fftshift(\n            coeffs, axes=list(range(model.n_input_feat))\n        ), np.fft.fftshift(freqs)\n    else:\n        return coeffs, freqs\n</code></pre>"},{"location":"training/","title":"Training","text":"<p>This section describes how to use the model provided with this package, using a simple training scenario as an example.</p> <p>We consider a Fourier series with \\(n\\) frequencies defined as follows:</p> \\[ f(x, \\boldsymbol{\\theta})=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) e^{i \\omega x}=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) \\left(\\cos(\\omega x) + i \\sin(\\omega x)\\right) \\] <p>Here, \\(\\omega \\in \\boldsymbol{\\Omega}\\) are the frequencies in the spectrum with the Fourier coefficients \\(c_{\\omega}(\\boldsymbol{\\theta})\\), parameterized by the set of trainable parameters \\(\\boldsymbol{\\theta}\\).</p> <p>As shown by Schuld et al. (2020), a quantum circuit, parametrised by \\(\\boldsymbol{\\theta}\\) and input \\(x\\) and is equivalent to the Fourier series representation. Such circuits must be of the following form:</p> \\[ f(x, \\boldsymbol{\\theta})=\\langle 0\\vert^{\\otimes n} U^{\\dagger}(x, \\boldsymbol{\\theta}) \\mathcal{M} U(x, \\boldsymbol{\\theta})\\vert 0\\rangle^{\\otimes n} \\] <p>Therefore, training such a model on a Fourier series is a proof-of-concept which we want to demonstrate here.</p> <p>Let's start with building our dataset. A Fourier series with \\(4\\) frequencies: <pre><code>import pennylane.numpy as np\nimport matplotlib.pyplot as plt\n\ndomain = [-np.pi, np.pi]\nomegas = np.array([1, 2, 3, 4])\ncoefficients = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Calculate the number of required samples to satisfy the Nyquist criterium\nn_d = int(np.ceil(2 * np.max(np.abs(domain)) * np.max(omegas)))\n# Sample the domain linearly\nx = np.linspace(domain[0], domain[1], num=n_d)\n\n# define our Fourier series f(x)\ndef f(x):\n    return 1 / np.linalg.norm(omegas) * np.sum(coefficients * np.cos(omegas.T * x))\n\n# evaluate f(x) on the domain samples\ny = np.stack([f(sample) for sample in x])\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.show()\n</code></pre></p> <p> </p> <p>Note that we chose the coefficients to be all \\(0.5\\). Play around with those values to change the magnitude of each frequency component. Also note that we're using the Pennylane version of Numpy, which is required because of the optimizer that we will be using later. Now that we have our \"dataset\", let's move on and build a model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n)\n</code></pre></p> <p>This is the minimal amout of information needed. According to the work referenced above, a model with \\(4\\) qubits should be capable of learning a Fourier series with \\(4\\) frequencies, considering single qubit Pauli encoding (which we have by default).</p> <p>Now, let's train our model: <pre><code>import pennylane as qml\n\nopt = qml.AdamOptimizer(stepsize=0.01)\n\ndef cost_fct(params):\n    y_hat = model(params=params, inputs=x, force_mean=True)\n\n    return np.mean((y_hat - y) ** 2)\n\nfor epoch in range(1, 1001):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n\nplt.plot(x, y, label=\"True function\")\nplt.plot(x, model(params=model.params, inputs=x, force_mean=True), label=\"Model prediction\")\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.legend()\nplt.show()\n</code></pre></p> <pre><code>Epoch: 100, Cost: 0.0081\nEpoch: 200, Cost: 0.0073\nEpoch: 300, Cost: 0.0051\nEpoch: 400, Cost: 0.0043\nEpoch: 500, Cost: 0.0036\nEpoch: 600, Cost: 0.0022\nEpoch: 700, Cost: 0.0014\nEpoch: 800, Cost: 0.0008\nEpoch: 900, Cost: 0.0006\nEpoch: 1000, Cost: 0.0001\n</code></pre> <p> </p> <p>As you can see, the model is able to learn the Fourier series with the \\(4\\) frequencies.</p> <p>For the model we just trained, we considered the best possible scenario: evenly spaced, integer omegas. But, as shown by Schuld et al. (2020), we'll need an increasing and inefficient amount of qubits for larger omegas. What is more, the model will fail altogether if the frequencies are un-evenly spaced. Luckily, Jaderberg et al. (2024) showed how we can let the model choose its own frequencies by including a set of encoding parameters that act on the input before the encoding layers of the circuit. We demonstrate this functionality below. </p> <p>First, let's slighly modify the omegas from the first example and re-generate the data: <pre><code>domain = [-np.pi, np.pi]\nomegas = np.array([1.2, 2.6, 3.4, 4.9])\ncoefficients = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Calculate the number of required samples to satisfy the Nyquist criterium\nn_d = int(np.ceil(2 * np.max(np.abs(domain)) * np.max(omegas)))\n# Sample the domain linearly\nx = np.linspace(domain[0], domain[1], num=n_d)\n\n# define our Fourier series f(x)\ndef f(x):\n    return 1 / np.linalg.norm(omegas) * np.sum(coefficients * np.cos(omegas.T * x))\n\n# evaluate f(x) on the domain samples\ny = np.stack([f(sample) for sample in x])\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.show()\n</code></pre></p> <p> </p> <p>Now, let's build a model with fixed frequencies, as before, and one with trainable frequencies: <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n)\nmodel_tf = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    trainable_frequencies=True # &lt;---!\n)\n</code></pre></p> <p>Let's train both models: <pre><code># - Fixed Frequencies -\nopt = qml.AdamOptimizer(stepsize=0.01)\n\nprint(\"Training fixed frequency model\")\nfor epoch in range(1, 1001):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n\n# - Trainable Frequencies -\nopt = qml.AdamOptimizer(stepsize=0.01)\n\ndef cost_fct_tf(params, enc_params):\n    y_hat = model_tf(params=params, enc_params=enc_params, inputs=x, force_mean=True)\n    return np.mean((y_hat - y) ** 2)\n\nprint(f\"\\nTraining trainable frequency model\")\nfor epoch in range(1, 1001):\n    (model_tf.params, model_tf.enc_params), cost_val_tf = opt.step_and_cost(cost_fct_tf, model_tf.params, model_tf.enc_params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val_tf:.6f}\")\n\nplt.plot(x, y, label=\"True function\")\nplt.plot(x, model(params=model.params, inputs=x, force_mean=True), label=\"Fixed frequencies model prediction\")\nplt.plot(x, model_tf(params=model_tf.params, enc_params=model_tf.enc_params, inputs=x, force_mean=True), label=\"Trainable frequencies model prediction\")\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.legend()\nplt.show()\n</code></pre></p> <pre><code>Training fixed frequency model\nEpoch: 100, Cost: 0.0082\nEpoch: 200, Cost: 0.0067\nEpoch: 300, Cost: 0.0038\nEpoch: 400, Cost: 0.0031\nEpoch: 500, Cost: 0.0027\nEpoch: 600, Cost: 0.0026\nEpoch: 700, Cost: 0.0025\nEpoch: 800, Cost: 0.0024\nEpoch: 900, Cost: 0.0023\nEpoch: 1000, Cost: 0.0023\n\nTraining trainable frequency model\nEpoch: 100, Cost: 0.008454\nEpoch: 200, Cost: 0.002759\nEpoch: 300, Cost: 0.002382\nEpoch: 400, Cost: 0.001655\nEpoch: 500, Cost: 0.000232\nEpoch: 600, Cost: 0.000019\nEpoch: 700, Cost: 0.000010\nEpoch: 800, Cost: 0.000003\nEpoch: 900, Cost: 0.000001\nEpoch: 1000, Cost: 0.000001\n</code></pre> <p> </p> <p>As you can see, the fixed frequencies model was not able to find the underlying function representing the data, while the trainable frequencies model was successful in its training.</p> <p>Let's quickly check the final encoding parameter of both models: <pre><code>print(f\"Encoding parameters of the fixed frequencies model: {model.enc_params}\")\nprint(f\"Encoding parameters of the trainable frequencies model: {np.round(model_tf.enc_params, 3)}\")\n</code></pre></p> <pre><code>Encoding parameters of the fixed frequencies model: [1. 1. 1. 1.]\nEncoding parameters of the trainable frequencies model: [1.001 2.065 2.817 0.364]\n</code></pre> <p>Clearly, the trainable frequencies model found the set of encoding parameters that allowed it to represent the given arbitrary frequency spectrum. </p> <p>One last thing that might be interesting! Currently, the model applies  <pre><code>enc_params[qubit] * inputs[:, idx]\n</code></pre> to allow for trainable frequencies. You may try different input transformations before the encoding by modifying the <code>model.transform_input</code> method. For example, if an <code>RX</code> gate performs the encoding, you may apply the identity operator by  <pre><code>model.transform_input = lambda inputs, qubit, idx, enc_params: np.arccos(inputs[:, idx])\n</code></pre></p> <p>Btw, if you're in a hurry, we have a Jupyter notebook with the exact same examples here .</p> <p>Wondering what to do next? You can try a few different models, and see how they perform. If you're curious, checkout how this correlates with the Entanglement and Expressibility of the model.</p>"},{"location":"usage/","title":"Usage","text":"<p>Central component of our package is the Fourier model which you can import with  <pre><code>from qml_essentials.model import Model\n</code></pre></p> <p>In the simplest scenario, one would instantiate such a model with \\(4\\) qubits and a single layer using the \"Hardware Efficient\" ansatz by: <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Hardware_Efficient\",\n)\n</code></pre></p> <p>You can take a look at your model, by simply calling <pre><code>model.draw(figure=\"mpl\")\n</code></pre></p> <p> </p> <p>Looks good to you?  Head over to the Training page for getting started with an easy example, where we also show how to implement trainable frequencies </p> <p>Note that calling the model without any (<code>None</code>) values for the <code>params</code> and <code>inputs</code> argument, will implicitly call the model with the recently (or initial) parameters and <code>0</code>s as input. I.e. simply running the following <pre><code>model()\n</code></pre> will return the combined expectation value of a n-local measurement (<code>output_qubit=-1</code> is default). </p> <p>In the following we will describe some concepts of the <code>Model</code> class. For a more detailled reference on the methods and arguments that are available, please see the references page.</p>"},{"location":"usage/#the_essentials","title":"The essentials","text":"<p>There is much more to this package, than just providing a Fourier model. You can calculate the Expressibility or Entangling Capability besides the Coefficients which are unique to this kind of QML interpretation. You can also provide a custom circuit, by instantiating from the <code>Circuit</code> class in <code>qml_essentials.ansaetze.Circuit</code>. See page Ansaetze for more details and a list of available Ansatzes that we provide with this package.</p>"},{"location":"usage/#data-reuploading","title":"Data-Reuploading","text":"<p>This idea is one of the core features of our framework and builds upon the work by Schuld et al. (2020). Essentially it allows us to represent a quantum circuit as a truncated Fourier series which is a powerfull feature that enables the model to mimic arbitrary non-linear functions. The number of frequencies that the model can represent is constrained by the number of data encoding steps within the circuit.</p> <p>Typically, there is a reuploading step after each layer and on each qubit (<code>data_reupload=True</code>). However, our package also allows you to specify and array with the number of rows representing the qubits and number of columns representing the layers. Then a <code>True</code> means that encoding is applied at the corresponding position within the circuit.</p> <p>In the following example, the model has two reuploading steps (<code>model.degree</code> = 2) although it would be capable of representing four frequencies:</p> <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=2,\n    circuit_type=\"Hardware_Efficient\",\n    data_reupload=[[True, False], [False, True]],\n)\n</code></pre> <p>Checkout the Coefficients page for more details on how you can visualize such a model using tools from signal analysis. If you want to encode multi-dimensional data (checkout the Encoding section on how to do that), you can specify another dimension in the <code>data_reupload</code> argument (which just extents naturally). <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=2,\n    circuit_type=\"Hardware_Efficient\",\n    data_reupload=[[[0, 1], [1, 1]], [[1, 1], [0, 1]]],\n)\n</code></pre> Now, the first input will have two frequencies (<code>sum([0,1,1,0]) = 2</code>), and the second input will have four frequencies (<code>sum([1,1,1,1]) = 4</code>). Of course, this is just a rule of thumb and can vary depending on the exact encoding strategy.</p>"},{"location":"usage/#parameter_initialization","title":"Parameter Initialization","text":"<p>The initialization strategy can be set when instantiating the model with the <code>initialization</code> argument.</p> <p>The default strategy is \"random\" which will result in random initialization of the parameters using the domain specified in the <code>initialization_domain</code> argument. Other options are: - \"zeros\": All parameters are initialized to \\(0\\) - \"zero-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(0\\) - \"pi-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(\\\\pi\\) - \"pi\": All parameters are initialized to \\(\\\\pi\\)</p> <p>The <code>initialize_params</code> method provides the option to re-initialise the parameters after model instantiation using either the previous configuration or a different strategy.</p>"},{"location":"usage/#encoding","title":"Encoding","text":"<p>The encoding can be set when instantiating the model with the <code>encoding</code> argument.</p> <p>The default encoding is \"RX\" which will result in a single RX rotation per qubit. Other options are:</p> <ul> <li>A string such as <code>\"RX\"</code> that will result in a single RX rotation per qubit</li> <li>A list of strings such as <code>[\"RX\", \"RY\"]</code> that will result in a sequential RX and RY rotation per qubit</li> <li>Any callable such as <code>Gates.RX</code></li> <li>A list of callables such as <code>[Gates.RX, Gates.RY]</code></li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class. If a list of encodings is provided, the input is assumed to be multi-dimensional. Otherwise multiple inputs are treated as batches of inputs. If you want to visualize zero-valued encoding gates in the model, set <code>remove_zero_encoding</code> to <code>False</code> on instantiation.</p> <p>In case of a multi-dimensional input, you can obtain the highest frequency in each encoding dimension from the <code>model.frequencies</code> property. Now, <code>model.degree</code> in turn will reflect the highest number in this list.</p>"},{"location":"usage/#state_preparation","title":"State Preparation","text":"<p>While the encoding is applied in each data-reuploading step, the state preparation is only applied at the beginning of the circuit, but after the <code>StatePreparation</code> noise (see below for details). The default is no state preparation. Similar to the encoding, you can provide the <code>state_preparation</code> argument as</p> <ul> <li>A string such as <code>\"H\"</code> that will result in a single Hadamard per qubit</li> <li>A list of strings such as <code>[\"H\", \"H\"]</code> that will result in two consecutive Hadamards per qubit</li> <li>Any callable such as <code>Gates.H</code></li> <li>A list of callables such as <code>[Gates.H, Gates.H]</code></li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class.</p>"},{"location":"usage/#output_shape","title":"Output Shape","text":"<p>The output shape is determined by the <code>output_qubit</code> argument, provided in the instantiation of the model. When set to -1 all qubits are measured which will result in the shape being of size \\(n\\) by default (depending on the execution type, see below).</p> <p>If <code>force_mean</code> flag is set when calling the model, the output is averaged to a single value (while keeping the batch/ input dimension). This is usually helpful, if you want to perform a n-local measurement over all qubits where only the average over \\(n\\) expecation values is of interest.</p>"},{"location":"usage/#execution_type","title":"Execution Type","text":"<p>Our model be simulated in different ways by setting the <code>execution_type</code> property, when calling the model, to:</p> <ul> <li><code>expval</code>: Returns the expectation value between \\(0\\) and \\(1\\)</li> <li><code>density</code>: Calculates the density matrix</li> <li><code>probs</code>: Simulates the model with the number of shots, set by <code>model.shots</code></li> </ul>"},{"location":"usage/#noise","title":"Noise","text":"<p>Noise can be added to the model by providing a <code>noise_params</code> argument, when calling the model, which is a dictionary with following keys</p> <ul> <li><code>BitFlip</code></li> <li><code>PhaseFlip</code></li> <li><code>AmplitudeDamping</code></li> <li><code>PhaseDamping</code></li> <li><code>Depolarizing</code></li> <li><code>MultiQubitDepolarizing</code></li> <li><code>StatePreparation</code></li> <li><code>Measurement</code></li> </ul> <p>with values between \\(0\\) and \\(1\\). Additionally, a <code>GateError</code> can be applied, which controls the variance of a Gaussian distribution with zero mean applied on the input vector.</p> <p>While <code>BitFlip</code>, <code>PhaseFlip</code>, <code>Depolarizing</code> and <code>GateError</code>s are applied on each gate, <code>AmplitudeDamping</code>, <code>PhaseDamping</code>, <code>StatePreparation</code> and <code>Measurement</code> are applied on the whole circuit.</p> <p>Furthermore, <code>ThermalRelaxation</code> can be applied.  Instead of the probability, the entry for this type of error consists of another dict with the keys:</p> <ul> <li><code>t1</code>: The relative T1 relaxation time (a typical value might be \\(180\\mathrm{us}\\))</li> <li><code>t2</code>: The relative T2 relaxation time (a typical value might be \\(100\\mathrm{us}\\))</li> <li><code>t_factor</code>: The relative gate time factor (a typical value might be \\(0.018\\mathrm{us}\\))</li> </ul> <p>The units can be ignored as we are only interested in relative times, above values might belong to some superconducting system. Note that <code>t2</code> is required to be max. \\(2\\times\\)<code>t1</code>. Based on <code>t_factor</code> and the circuit depth the execution time is estimated, and therefore the influence of thermal relaxation over time.</p>"},{"location":"usage/#caching","title":"Caching","text":"<p>To speed up calculation, you can add <code>cache=True</code> when calling the model. The result of the model call will then be stored in a numpy format in a folder <code>.cache</code>. Each result is being identified by a md5 hash that is a representation of the following model properties:</p> <ul> <li>number of qubits</li> <li>number of layers</li> <li>ansatz</li> <li>data-reuploading flag</li> <li>parameters</li> <li>noise parameters</li> <li>execution type</li> <li>inputs</li> <li>output qubit(s)</li> </ul>"},{"location":"usage/#multiprocessing","title":"Multiprocessing","text":"<p>Our framework can parallelise the execution of the model by providing a <code>mp_threshold</code> parameter (defaults to -1). This parameter effectively determines the batch size above which the model is executed in parallel. Given a parameter shape of, i.e. <code>[x,y,1000]</code> and a <code>mp_threshold</code> of 400, three separate processes will be launched. If there are only two processes available on the machine, then the model will execute only two processes concurrently, wait for them to finish and then execute the remaining process.</p> <pre><code>n_samples = 4500\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    mp_threshold=1000,\n)\n</code></pre> <p>Depending on the chosen parameters and your machine, this can result in a significant speedup. Note however, that this is currently only available for <code>n_qubits&lt;model.lightning_threshold</code> which is 12 by default. Above this threshold, Pennylane's <code>lightning.qubit</code> device is used which would interfere with an additional parallelism. Also note, that no checks on the available memory will be performed and that the memory consumption could multiply with the number of parallel processes.</p> <p>Multiprocessing works for both parameters and inputs, meaning that if a batched input is provided, processing will be parallelized in the same way as explained above. Note, that if both, parameters and inputs are batched with size <code>B_I</code> and <code>B_P</code> respectively, the effective batch dimension will multiply, i.e. resulting in <code>B_I * B_P</code> combinations.  Internally, these combinations will be flattened during processing and then reshaped to the original shape afterwards, such that the output shape is <code>[O, B_I, B_P]</code>. Here, <code>O</code> is the general output shape depending on the execution type, <code>B_I</code> is the batch dimension of the inputs and <code>B_P</code> is the batch dimension of the parameters. This shape is also available as a property of the model: <code>model.batch_shape</code>.</p>"},{"location":"usage/#quantikz_export","title":"Quantikz Export","text":"<p>In addition to the printing the model to console and into a figure using matplotlib (thanks to Pennylane); our framework extends this functionality by allowing you to create nice Quantikz figures that you can embedd in a Latex document . This can be achieved by </p> <pre><code>fig = model.draw(figure=\"tikz\", inputs_symbols=\"x\", gate_values=False)\nfig.export(\"tikz_circuit.tex\", full_document=True)\n</code></pre> <p> </p> <p>Inputs are represented with \"x\" by default, which can be changed by adjusting the optional parameter <code>inputs_symbols</code>. If you want to see the actual gate values instead of variables, simply set <code>gate_values=True</code> which is also the default option. The returned <code>fig</code> variable is a <code>TikzFigure</code> object that stores the Latex string and allows exporting to a specified file. To create a document that can be compiled, simply pass <code>full_document=True</code> when calling <code>export</code>.</p>"}]}