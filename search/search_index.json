{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A toolbox to make working with QML models easier. <p>This repo contains some of the commonly used Ansaetze and coding stuff required for working with QML and Data-Reuploading models. There are also dedicated classes to calculate entanglement and expressiblity of a provided model as well as its Fourier coefficients.</p> <p>Curious?  Installing this package is as simple as with any other package </p> <p><code>pip install qml-essentials</code></p> <p>Or, if you prefer poetry:</p> <p><code>poetry add qml-essentials</code></p> <p>Once you have set things up, go ahead and checkout how to use qml-essentials.</p> <p>If you want to contribute, please refer to our CONTRIBUTING guide on Github. Also checkout our coverage report.</p> <p>Do you want to use our software in a research project?  Please checkout the github repository and follow the instructions (\"Cite this repository\") there.</p>"},{"location":"ansaetze/","title":"Ansaetze","text":"<p>.. or Ansatzes as preferred by the english community. Anyway, we got various of the most-used Ansaetze implemented in this package. </p> <p>You can load them manually by <pre><code>from qml_essentials.ansaetze import Ansaetze\nall_ansaetze = Ansaetze.get_available()\n\nfor ansatz in all_ansaetze:\n    print(ansatz.__name__)\n</code></pre></p> <pre><code>No_Ansatz\nCircuit_1\nCircuit_2\nCircuit_3\nCircuit_4\nCircuit_6\nCircuit_9\nCircuit_10\nCircuit_15\nCircuit_16\nCircuit_17\nCircuit_18\nCircuit_19\nNo_Entangling\nStrongly_Entangling\nHardware_Efficient\n</code></pre> <p>Note that Circuit 10 deviates from the original implementation!</p> <p>However, usually you just want reference to them (by name) when instantiating a model. To get an overview of all the available Ansaetze, checkout the references.</p>"},{"location":"ansaetze/#custom_ansatz","title":"Custom Ansatz","text":"<p>If you want to implement your own ansatz, you can do so by inheriting from the <code>Circuit</code> class: <pre><code>from qml_essentials.ansaetze import Circuit\n\nclass MyHardwareEfficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        w_idx = 0\n        for q in range(n_qubits):\n            qml.RY(w[w_idx], wires=q)\n            w_idx += 1\n            qml.RZ(w[w_idx], wires=q)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                qml.CZ(wires=[q, q + 1])\n</code></pre></p> <p>and then pass it to the model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n)\n</code></pre></p> <p>Checkout page Usage on how to proceed from here.</p>"},{"location":"ansaetze/#custom_encoding","title":"Custom Encoding","text":"<p>On model instantiation, you can choose how your inputs are encoded. The default encoding is \"RX\" which will result in a single RX rotation per qubit. You can change this behavior, by setting the optional <code>encoding</code> argument to - a string or a list of strings where each is checked agains the <code>Gates</code> class - a callable or a list of callables</p> <p>A callable must take an input, the wire where it's acting on and an optional noise_params dictionary. Let's look at an example, where we wan't to encode a two-dimensional input: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.ansaetze import Gates\n\ndef MyCustomEncoding(w, wires, noise_params=None):\n    Gates.RX(w[0], wires, noise_params=noise_params)\n    Gates.RY(w[1], wires, noise_params=noise_params)\n\nmodel = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=MyHardwareEfficient,\n    encoding=MyCustomEncoding,\n)\n\nmodel(inputs=[1, 2])\n</code></pre></p>"},{"location":"ansaetze/#noise","title":"Noise","text":"<p>You might have noticed, that the <code>build</code> method takes an additional input <code>noise_params</code>, which we did not used so far. In general, all of the Ansatzes, that are implemented in this package allow this additional input which is a dictionary containing all the noise parameters of the circuit (here all with probability \\(0.0\\)): <pre><code>noise_params = {\n    \"BitFlip\": 0.0,\n    \"PhaseFlip\": 0.0,\n    \"AmplitudeDamping\": 0.0,\n    \"PhaseDamping\": 0.0,\n    \"Depolarizing\": 0.0,\n}\n</code></pre></p> <p>Providing this optional input will apply the corresponding noise to the model where the Bit Flip, Phase Flip and Depolarizing Channel are applied after each gate and the Amplitude and Phase Damping are applied at the end of the circuit. To achieve this, we implement our own set of noisy gates, that build upon the Pennylane gates. To demonstrate this, let's extend our example above: <pre><code>from qml_essentials.ansaetze import Gates, Circuit\n\nclass MyNoisyHardwareEfficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(wires=[q, q + 1], noise_params=noise_params)\n</code></pre></p> <p>As you can see, we slightly modified the example, by importing the <code>Gates</code> class from <code>ansaetze</code> and by adding the <code>noise_params</code> input to each of the gates. When using a noisy circuit, make sure to run the model with the <code>density</code> execution type: <pre><code>model(\n    model.params,\n    inputs=None,\n    execution_type=\"density\",\n    noise_params={\n        \"BitFlip\": 0.01,\n        \"PhaseFlip\": 0.02,\n        \"AmplitudeDamping\": 0.03,\n        \"PhaseDamping\": 0.04,\n        \"Depolarizing\": 0.05,\n})\n</code></pre></p>"},{"location":"coefficients/","title":"Coefficients","text":"<p>A characteristic property of any Fourier model are its coefficients. Our package can, given a model, calculate the corresponding coefficients.</p> <p>In the simplest case, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.coefficients import Coefficients\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\ncoeffs = Coefficients.get_spectrum(model)\n</code></pre></p> <p>But wait! There is much more to this. Let's keep on reading if you're curious .</p>"},{"location":"coefficients/#detailled_explanation","title":"Detailled Explanation","text":"<p>To visualize what happens, let's create a very simplified Fourier model <pre><code>class Model_Fct:\n    def __init__(self, c, f):\n        self.c = c\n        self.f = f\n        self.degree = max(f)\n\n    def __call__(self, inputs, **kwargs):\n        return np.sum([c * np.cos(inputs * f) for f, c in zip(self.f, self.c)], axis=0)\n</code></pre></p> <p>This model takes a vector of coefficients and frequencies on instantiation. When called, these coefficients and frequencies are used to compute the output of the model, which is the sum of sine functions determined by the length of the vectors. Let's try that for just two frequencies:</p> <pre><code>freqs = [1,3]\ncoeffs = [1,1]\n\nfs = max(freqs) * 2 + 1\nmodel_fct = Model_Fct(coeffs,freqs)\n\nx = np.arange(0,2 * np.pi, 2 * np.pi/fs)\nout = model_fct(x)\n</code></pre> <p>We can now calculate the Fast Fourier Transform of our model: <pre><code>X = np.fft.fft(out) / len(out)\nX_shift = np.fft.fftshift(X)\nX_freq = np.fft.fftfreq(X.size, 1/fs)\nX_freq_shift = np.fft.fftshift(X_freq)\n</code></pre> Note that calling <code>np.fft.fftshift</code> is not required from a technical point of view, but makes our spectrum nicely zero-centered and projected correctly.</p> <p> </p> <p>The same can be done with our framework, with a neat one-liner: <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, shift=True)\n</code></pre></p> <p> </p> <p>Note, that applying the shift can be controlled with the optional <code>shift</code> argument.</p> <p>Another important point is, that the <code>force_mean</code> flag is set, and the <code>execution_type</code> is is implicitly set to <code>expval</code>. This is mainly because, we require a single expectation value to calculate the coefficients.</p>"},{"location":"coefficients/#increasing_the_resolution","title":"Increasing the Resolution","text":"<p>You might have noticed that we choose our sampling frequency <code>fs</code> in such a way, that it just fulfills the Nyquist criterium. Also the number of samples <code>x</code> are just enough to sufficiently represent our function. In such a simplified scenario, this is fine, but there are cases, where we want to have more information both in the time and frequency domain. Therefore, two additional arguments exist in the <code>get_spectrum</code> method: - <code>mfs</code>: The multiplier for the highest frequency. Increasing this will increase the width of the spectrum - <code>mts</code>: The multiplier for the number of time samples. Increasing this will increase the resolution of the time domain and therefore \"add\" frequencies in between our original frequencies. - <code>trim</code>: Whether to remove the Nyquist frequency if spectrum is even. This will result in a symmetric spectrum</p> <pre><code>X_shift, X_freq_shift = Coefficients.get_spectrum(model_fct, mfs=2, mts=3, shift=True)\n</code></pre> <p> </p> <p>Note that, as the frequencies change with the <code>mts</code> argument, we have to take that into account when calculating the frequencies with the last call.</p> <p>Feel free to checkout our jupyter notebook if you would like to play around with this.</p> <p>A sidenote on the performance; Increasing the <code>mts</code> value effectively increases the input lenght that goes into the model. This means that <code>mts=2</code> will require twice the time to compute, which will be very noticable when running noisy simulations.</p>"},{"location":"coefficients/#power_spectral_density","title":"Power spectral density","text":"<p>In some cases it can be useful to get the power spectral density (PSD). As calculation of this metric might differ between the different research domains, we included a function to get the PSD of a given spectrum using the following formula:</p> \\[ PSD = \\frac{2 (\\mathrm{Re}(F)^2+\\mathrm{Im}(F)^2)}{n_\\text{samples}^2} \\] <p>where \\(F\\) is the spectrum and \\(n_\\text{samples}\\) the length of the input vector.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p> </p>"},{"location":"coefficients/#analytic_coefficients","title":"Analytic Coefficients","text":"<p>All of the calculations above were performed by applying a Fast Fourier Transform to the output of our Model. However, we can also calculate the coefficients analytically.</p> <p>This can be achieved by the so called <code>FourierTree</code> class: <pre><code>from qml_essentials.coefficients import FourierTree\n\nfourier_tree = FourierTree(model)\nan_coeffs, an_freqs = fourier_tree.get_spectrum(force_mean=True)\n</code></pre></p> <p>Note that while this takes significantly longer to compute, it gives us the precise coefficients, solely depending on the parameters. We can verify this by comparing it to the previous results:</p> <p> </p>"},{"location":"coefficients/#technical_details","title":"Technical Details","text":"<p>We use an approach developed by Nemkov et al., which was later extended by Wiedmann et al.. The implementation is also inspired by the corresponding code for Nemkov et al.'s paper.</p> <p>In Nemkov et al.'s algorithm the first step is to separate Clifford and non-Clifford gates, such that all Clifford gates can be regarded as part of the observable, and the actual circuit only consists of Pauli rotations (cf. qml_essentials.utils.PauliCircuit). The main idea is then to split each Pauli rotation into sine and cosine product terms to obtain the coefficients, which are only dependent on the parameters of the circuit.</p> <p>Currently, our implementation supports only one input feature, albeit more are theoretical possible.</p>"},{"location":"coefficients/#multi-dimensional_coefficients","title":"Multi-Dimensional Coefficients","text":"<p>The <code>get_spectrum</code> method can also be used to calculate the coefficients of a model with multiple input dimensions. This feature can be enabled, by explicitly providing an encoding that supports multi-dimensional input, e.g. a list of single encodings (see Usage for details on how encodings are applied).  Currently, only the FFT-based method supports this.</p> <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n    random_seed=1000,\n    encoding=[\"RX\", \"RY\"]\n)\n\ncoeffs, freqs = Coefficients.get_spectrum(model, mfs=1, mts=1\n, shift=True)\n\npsd = Coefficients.get_psd(coeffs)\n</code></pre> <p>Using a logarithmic color bar, one obtains the following 2d-spectrum:</p> <p> </p> <p>Note that \"X1\" refers to the \"RX\" encoding and \"X2\" to the \"RY\" encoding.</p>"},{"location":"entanglement/","title":"Entanglement","text":"<p>As one of the fundamental aspects of quantum computing, entanglement plays also an important role in quantum machine learning. Our package offers methods for calculating the entangling capability of a particular model.</p> <p>In the simplest case, using the Meyer-Wallach measure, this could look as follows: <pre><code>from qml_essentials.model import Model\nfrom qml_essentials.entanglement import Entanglement\n\nmodel = Model(\n            n_qubits=2,\n            n_layers=1,\n            circuit_type=\"Hardware_Efficient\",\n        )\n\nent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000\n)\n</code></pre></p> <p>Here, <code>n_samples</code> is the number of samples for the parameters, sampled according to the default initialization strategy of the model, and <code>seed</code> is the random number generator seed.</p> <p>Note, that every function in this class accepts keyword-arguments which are being passed to the model call, so you could e.g. enable caching by</p> <pre><code>ent_cap = Entanglement.meyer_wallach(\n    model, n_samples=1000, seed=1000, cache=True\n)\n</code></pre> <p>If you set <code>n_samples=None</code>, we will use the currently stored parameters of the model to estimate the degree of entanglement.</p>"},{"location":"entanglement/#bell-measurement","title":"Bell-Measurement","text":"<p>An alternate method for calculating the entangling capability is the Bell-measurement method. We can utilize this by</p> <pre><code>ent_cap = Entanglement.bell_measurements(\n    model, n_samples=1000, seed=1000\n)\n</code></pre>"},{"location":"expressibility/","title":"Expressibility","text":"<p>Our package allows you estimate the expressiblity of a given model. <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=1,\n    circuit_type=\"HardwareEfficient\",\n)\n\ninput_domain, bins, dist_circuit = Expressibility.state_fidelities(\n    seed=1000,\n    n_samples=200,\n    n_bins=10,\n    n_input_samples=5,\n    input_domain=[0, 2*np.pi],\n    model=model,\n)\n</code></pre></p> <p>Here, <code>n_bins</code> is the number of bins that you want to use in the histogram, <code>n_samples</code> is the number of parameter sets to generate (using the default initialization strategy of the model), <code>n_input_samples</code> is the number of samples for the input domain in \\([0, 2\\pi]\\), and <code>seed</code> is the random number generator seed.</p> <p>Note that <code>state_fidelities</code> accepts keyword arguments that are being passed to the model call. This allows you to utilize e.g. caching.</p> <p>Next, you can calculate the Haar integral (as reference), by <pre><code>input_domain, dist_haar = Expressibility.haar_integral(\n    n_qubits=2,\n    n_bins=10,\n    cache=True,\n)\n</code></pre></p> <p>Finally, the Kullback-Leibler divergence allows you to see how well the particular circuit performs compared to the Haar integral: <pre><code>kl_dist = Expressibility.kullback_leibler_divergence(dist_circuit, dist_haar).mean()\n</code></pre></p>"},{"location":"references/","title":"References","text":""},{"location":"references/#ansaetze","title":"Ansaetze","text":"<pre><code>from qml_essentials.ansaetze import Ansaetze\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Ansaetze:\n\n    def get_available():\n        return [\n            Ansaetze.No_Ansatz,\n            Ansaetze.Circuit_1,\n            Ansaetze.Circuit_2,\n            Ansaetze.Circuit_3,\n            Ansaetze.Circuit_4,\n            Ansaetze.Circuit_6,\n            Ansaetze.Circuit_9,\n            Ansaetze.Circuit_10,\n            Ansaetze.Circuit_15,\n            Ansaetze.Circuit_16,\n            Ansaetze.Circuit_17,\n            Ansaetze.Circuit_18,\n            Ansaetze.Circuit_19,\n            Ansaetze.No_Entangling,\n            Ansaetze.Strongly_Entangling,\n            Ansaetze.Hardware_Efficient,\n        ]\n\n    class No_Ansatz(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            return 0\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            pass\n\n    class Hardware_Efficient(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Hardware Efficient Ansatz.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &lt; 2:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 3\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Hardware-Efficient ansatz, as proposed in\n            https://arxiv.org/pdf/2309.03279\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CX(\n                        wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n                    )\n                if n_qubits &gt; 2:\n                    Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n\n    class Circuit_19(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_19.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit19 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_18(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_18.\n\n            The number of parameters is 3 times the number of qubits when there\n            is more than one qubit, as each qubit contributes 3 parameters.\n            If the number of qubits is less than 2, a warning is logged since\n            no entanglement is possible, and a fixed number of 2 parameters is used.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit18 ansatz.\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_15(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_15.\n\n            The number of parameters is 2 times the number of qubits.\n            A warning is logged if the number of qubits is less than 2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 2\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit15 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n            because for &gt;1 qubits there are three gates\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n    class Circuit_9(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_9.\n\n            The number of parameters is equal to the number of qubits.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters required for one layer of the circuit\n            \"\"\"\n            return n_qubits\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit9 ansatz.\n\n            Length of flattened vector must be n_qubits\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.H(wires=q, noise_params=noise_params)\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CZ(\n                        wires=[n_qubits - q - 2, n_qubits - q - 1],\n                        noise_params=noise_params,\n                    )\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_6(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_6.\n\n            The total number of parameters is n_qubits*3+n_qubits**2, which is\n            the number of rotations n_qubits*3 plus the number of entangling gates\n            n_qubits**2.\n\n            If n_qubits is 1, the number of parameters is 4, and a warning is logged\n            since no entanglement is possible.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &gt; 1:\n                return n_qubits * 3 + n_qubits**2\n            else:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n                return 4\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            Returns the indices for the controlled rotation gates for one layer.\n            Indices should slice the list of all parameters for one layer as follows:\n            [indices[0]:indices[1]:indices[2]]\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            if n_qubits &gt; 1:\n                return [-n_qubits, None, None]\n            else:\n                return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit6 ansatz.\n\n            Length of flattened vector must be\n                n_qubits*4+n_qubits*(n_qubits-1) =\n                n_qubits*3+n_qubits**2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size\n                    n_layers*(n_qubits*3+n_qubits**2)\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for ql in range(n_qubits):\n                    for q in range(n_qubits):\n                        if q == ql:\n                            continue\n                        Gates.CRX(\n                            w[w_idx],\n                            wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                            noise_params=noise_params,\n                        )\n                        w_idx += 1\n\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_1(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_1.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit1 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_2(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for Circuit_2.\n\n            The total number of parameters is determined by the number of qubits, with\n            each qubit contributing 2 parameters.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit2 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CX(\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n\n    class Circuit_3(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Calculates the number of parameters per layer for Circuit3.\n\n            The number of parameters per layer is given by the number of qubits, with\n            each qubit contributing 3 parameters. The last qubit only contributes 2\n            parameters because it is the target qubit for the controlled gates.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit3 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_4(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit4 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - q - 1, n_qubits - q - 2],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_10(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n            The number of parameters is calculated as n_qubits*2.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit10 ansatz.\n\n            Length of flattened vector must be n_qubits*2\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*2\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            # constant gates, independent of layers. has to be fixed\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits - 1):\n                    Gates.CZ(\n                        wires=[\n                            (n_qubits - q - 2) % n_qubits,\n                            (n_qubits - q - 1) % n_qubits,\n                        ],\n                        noise_params=noise_params,\n                    )\n                if n_qubits &gt; 2:\n                    Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n            for q in range(n_qubits):\n                Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n    class Circuit_16(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit16 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRZ(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Circuit_17(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n            The number of parameters is calculated as n_qubits*3-1.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n\n            return n_qubits * 3 - 1\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a Circuit17 ansatz.\n\n            Length of flattened vector must be n_qubits*3-1\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3-1\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n                Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n                w_idx += 1\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 1), (2 * q)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n                for q in range((n_qubits - 1) // 2):\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[(2 * q + 2), (2 * q + 1)],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n    class Strongly_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the\n            Strongly Entangling ansatz.\n\n            The number of parameters is calculated as n_qubits*6.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            if n_qubits &lt; 2:\n                log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return n_qubits * 6\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n            \"\"\"\n            Creates a Strongly Entangling ansatz.\n\n            Length of flattened vector must be n_qubits*6\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*6\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n\n            if n_qubits &gt; 1:\n                for q in range(n_qubits):\n                    Gates.CX(\n                        wires=[q, (q + n_qubits // 2) % n_qubits],\n                        noise_params=noise_params,\n                    )\n\n    class No_Entangling(Circuit):\n        @staticmethod\n        def n_params_per_layer(n_qubits: int) -&gt; int:\n            \"\"\"\n            Returns the number of parameters per layer for the NoEntangling ansatz.\n\n            The number of parameters is calculated as n_qubits*3.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            int\n                Number of parameters per layer\n            \"\"\"\n            return n_qubits * 3\n\n        @staticmethod\n        def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n            \"\"\"\n            No controlled rotation gates available. Always None.\n\n            Parameters\n            ----------\n            n_qubits : int\n                Number of qubits in the circuit\n\n            Returns\n            -------\n            Optional[np.ndarray]\n                List of all controlled indices, or None if the circuit does not\n                contain controlled rotation gates.\n            \"\"\"\n            return None\n\n        @staticmethod\n        def build(w: np.ndarray, n_qubits: int, noise_params=None):\n            \"\"\"\n            Creates a circuit without entangling, but with U3 gates on all qubits\n\n            Length of flattened vector must be n_qubits*3\n\n            Parameters\n            ----------\n            w : np.ndarray\n                Weight vector of size n_qubits*3\n            n_qubits : int\n                Number of qubits\n            noise_params : Optional[Dict[str, float]], optional\n                Dictionary of noise parameters to apply to the gates\n            \"\"\"\n            w_idx = 0\n            for q in range(n_qubits):\n                Gates.Rot(\n                    w[w_idx],\n                    w[w_idx + 1],\n                    w[w_idx + 2],\n                    wires=q,\n                    noise_params=noise_params,\n                )\n                w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1","title":"<code>Circuit_1</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_1(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_1.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit1 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit1 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit1 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_1.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_1.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_1.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10","title":"<code>Circuit_10</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_10(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n        The number of parameters is calculated as n_qubits*2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2  # constant gates not considered yet. has to be fixed\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit10 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        # constant gates, independent of layers. has to be fixed\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[\n                        (n_qubits - q - 2) % n_qubits,\n                        (n_qubits - q - 1) % n_qubits,\n                    ],\n                    noise_params=noise_params,\n                )\n            if n_qubits &gt; 2:\n                Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit10 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit10 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    # constant gates, independent of layers. has to be fixed\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[\n                    (n_qubits - q - 2) % n_qubits,\n                    (n_qubits - q - 1) % n_qubits,\n                ],\n                noise_params=noise_params,\n            )\n        if n_qubits &gt; 2:\n            Gates.CZ(wires=[n_qubits - 1, 0], noise_params=noise_params)\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_10 ansatz.</p> <p>The number of parameters is calculated as n_qubits*2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_10.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_10 ansatz.\n\n    The number of parameters is calculated as n_qubits*2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2  # constant gates not considered yet. has to be fixed\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15","title":"<code>Circuit_15</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_15(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_15.\n\n        The number of parameters is 2 times the number of qubits.\n        A warning is logged if the number of qubits is less than 2.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 2\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit15 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit15 ansatz.</p> <p>Length of flattened vector must be n_qubits*2 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit15 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[(q - 1) % n_qubits, (q - 2) % n_qubits],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_15.</p> <p>The number of parameters is 2 times the number of qubits. A warning is logged if the number of qubits is less than 2.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_15.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_15.\n\n    The number of parameters is 2 times the number of qubits.\n    A warning is logged if the number of qubits is less than 2.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 2\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16","title":"<code>Circuit_16</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_16(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit16 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit16 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit16 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_16 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_16.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_16 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17","title":"<code>Circuit_17</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_17(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit17 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 1), (2 * q)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n            for q in range((n_qubits - 1) // 2):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[(2 * q + 2), (2 * q + 1)],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit17 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit17 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 1), (2 * q)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n\n        for q in range((n_qubits - 1) // 2):\n            Gates.CRX(\n                w[w_idx],\n                wires=[(2 * q + 2), (2 * q + 1)],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_17 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_17.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_17 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18","title":"<code>Circuit_18</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_18(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_18.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit18 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit18 ansatz.</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit18 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_18.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_18.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_18.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19","title":"<code>Circuit_19</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_19(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_19.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n\n        if n_qubits &gt; 1:\n            return n_qubits * 3\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit19 ansatz.\n\n        Length of flattened vector must be n_qubits*3\n        because for &gt;1 qubits there are three gates\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit19 ansatz.</p> <p>Length of flattened vector must be n_qubits*3 because for &gt;1 qubits there are three gates</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit19 ansatz.\n\n    Length of flattened vector must be n_qubits*3\n    because for &gt;1 qubits there are three gates\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, (n_qubits - q) % n_qubits],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_19.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_19.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_19.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n\n    if n_qubits &gt; 1:\n        return n_qubits * 3\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2","title":"<code>Circuit_2</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_2(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_2.\n\n        The total number of parameters is determined by the number of qubits, with\n        each qubit contributing 2 parameters.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 2\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit2 ansatz.\n\n        Length of flattened vector must be n_qubits*2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*2\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CX(\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit2 ansatz.</p> <p>Length of flattened vector must be n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*2 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit2 ansatz.\n\n    Length of flattened vector must be n_qubits*2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*2\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CX(\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_2.</p> <p>The total number of parameters is determined by the number of qubits, with each qubit contributing 2 parameters.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_2.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_2.\n\n    The total number of parameters is determined by the number of qubits, with\n    each qubit contributing 2 parameters.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 2\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3","title":"<code>Circuit_3</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_3(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Calculates the number of parameters per layer for Circuit3.\n\n        The number of parameters per layer is given by the number of qubits, with\n        each qubit contributing 3 parameters. The last qubit only contributes 2\n        parameters because it is the target qubit for the controlled gates.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit3 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CRZ(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit3 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit3 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CRZ(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Calculates the number of parameters per layer for Circuit3.</p> <p>The number of parameters per layer is given by the number of qubits, with each qubit contributing 3 parameters. The last qubit only contributes 2 parameters because it is the target qubit for the controlled gates.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_3.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Calculates the number of parameters per layer for Circuit3.\n\n    The number of parameters per layer is given by the number of qubits, with\n    each qubit contributing 3 parameters. The last qubit only contributes 2\n    parameters because it is the target qubit for the controlled gates.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4","title":"<code>Circuit_4</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_4(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n        The number of parameters is calculated as n_qubits*3-1.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3 - 1\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit4 ansatz.\n\n        Length of flattened vector must be n_qubits*3-1\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3-1\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - q - 1, n_qubits - q - 2],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit4 ansatz.</p> <p>Length of flattened vector must be n_qubits*3-1</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3-1 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit4 ansatz.\n\n    Length of flattened vector must be n_qubits*3-1\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3-1\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CRX(\n                w[w_idx],\n                wires=[n_qubits - q - 1, n_qubits - q - 2],\n                noise_params=noise_params,\n            )\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Circuit_4 ansatz.</p> <p>The number of parameters is calculated as n_qubits*3-1.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_4.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the Circuit_4 ansatz.\n\n    The number of parameters is calculated as n_qubits*3-1.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3 - 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6","title":"<code>Circuit_6</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_6(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_6.\n\n        The total number of parameters is n_qubits*3+n_qubits**2, which is\n        the number of rotations n_qubits*3 plus the number of entangling gates\n        n_qubits**2.\n\n        If n_qubits is 1, the number of parameters is 4, and a warning is logged\n        since no entanglement is possible.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &gt; 1:\n            return n_qubits * 3 + n_qubits**2\n        else:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n            return 4\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        Returns the indices for the controlled rotation gates for one layer.\n        Indices should slice the list of all parameters for one layer as follows:\n        [indices[0]:indices[1]:indices[2]]\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        if n_qubits &gt; 1:\n            return [-n_qubits, None, None]\n        else:\n            return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit6 ansatz.\n\n        Length of flattened vector must be\n            n_qubits*4+n_qubits*(n_qubits-1) =\n            n_qubits*3+n_qubits**2\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size\n                n_layers*(n_qubits*3+n_qubits**2)\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for ql in range(n_qubits):\n                for q in range(n_qubits):\n                    if q == ql:\n                        continue\n                    Gates.CRX(\n                        w[w_idx],\n                        wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                        noise_params=noise_params,\n                    )\n                    w_idx += 1\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit6 ansatz.</p> <p>Length of flattened vector must be     n_qubits4+n_qubits(n_qubits-1) =     n_qubits3+n_qubits*2</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size         n_layers(n_qubits3+n_qubits**2) n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit6 ansatz.\n\n    Length of flattened vector must be\n        n_qubits*4+n_qubits*(n_qubits-1) =\n        n_qubits*3+n_qubits**2\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size\n            n_layers*(n_qubits*3+n_qubits**2)\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for ql in range(n_qubits):\n            for q in range(n_qubits):\n                if q == ql:\n                    continue\n                Gates.CRX(\n                    w[w_idx],\n                    wires=[n_qubits - ql - 1, (n_qubits - q - 1) % n_qubits],\n                    noise_params=noise_params,\n                )\n                w_idx += 1\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the indices for the controlled rotation gates for one layer. Indices should slice the list of all parameters for one layer as follows: [indices[0]:indices[1]:indices[2]]</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    Returns the indices for the controlled rotation gates for one layer.\n    Indices should slice the list of all parameters for one layer as follows:\n    [indices[0]:indices[1]:indices[2]]\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    if n_qubits &gt; 1:\n        return [-n_qubits, None, None]\n    else:\n        return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_6.</p> <p>The total number of parameters is n_qubits3+n_qubits2, which is the number of rotations n_qubits3 plus the number of entangling gates n_qubits**2.</p> <p>If n_qubits is 1, the number of parameters is 4, and a warning is logged since no entanglement is possible.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_6.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_6.\n\n    The total number of parameters is n_qubits*3+n_qubits**2, which is\n    the number of rotations n_qubits*3 plus the number of entangling gates\n    n_qubits**2.\n\n    If n_qubits is 1, the number of parameters is 4, and a warning is logged\n    since no entanglement is possible.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &gt; 1:\n        return n_qubits * 3 + n_qubits**2\n    else:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return 4\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9","title":"<code>Circuit_9</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Circuit_9(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for Circuit_9.\n\n        The number of parameters is equal to the number of qubits.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        return n_qubits\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Circuit9 ansatz.\n\n        Length of flattened vector must be n_qubits\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.H(wires=q, noise_params=noise_params)\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits - 1):\n                Gates.CZ(\n                    wires=[n_qubits - q - 2, n_qubits - q - 1],\n                    noise_params=noise_params,\n                )\n\n        for q in range(n_qubits):\n            Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Circuit9 ansatz.</p> <p>Length of flattened vector must be n_qubits</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Circuit9 ansatz.\n\n    Length of flattened vector must be n_qubits\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.H(wires=q, noise_params=noise_params)\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits - 1):\n            Gates.CZ(\n                wires=[n_qubits - q - 2, n_qubits - q - 1],\n                noise_params=noise_params,\n            )\n\n    for q in range(n_qubits):\n        Gates.RX(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for Circuit_9.</p> <p>The number of parameters is equal to the number of qubits.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Circuit_9.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for Circuit_9.\n\n    The number of parameters is equal to the number of qubits.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    return n_qubits\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient","title":"<code>Hardware_Efficient</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Hardware_Efficient(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Hardware Efficient Ansatz.\n\n        The number of parameters is 3 times the number of qubits when there\n        is more than one qubit, as each qubit contributes 3 parameters.\n        If the number of qubits is less than 2, a warning is logged since\n        no entanglement is possible, and a fixed number of 2 parameters is used.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters required for one layer of the circuit\n        \"\"\"\n        if n_qubits &lt; 2:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a Hardware-Efficient ansatz, as proposed in\n        https://arxiv.org/pdf/2309.03279\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n            Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n            w_idx += 1\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits // 2):\n                Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n            for q in range((n_qubits - 1) // 2):\n                Gates.CX(\n                    wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n                )\n            if n_qubits &gt; 2:\n                Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Hardware-Efficient ansatz, as proposed in https://arxiv.org/pdf/2309.03279</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a Hardware-Efficient ansatz, as proposed in\n    https://arxiv.org/pdf/2309.03279\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RZ(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n        Gates.RY(w[w_idx], wires=q, noise_params=noise_params)\n        w_idx += 1\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits // 2):\n            Gates.CX(wires=[(2 * q), (2 * q + 1)], noise_params=noise_params)\n        for q in range((n_qubits - 1) // 2):\n            Gates.CX(\n                wires=[(2 * q + 1), (2 * q + 2)], noise_params=noise_params\n            )\n        if n_qubits &gt; 2:\n            Gates.CX(wires=[(n_qubits - 1), 0], noise_params=noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Hardware Efficient Ansatz.</p> <p>The number of parameters is 3 times the number of qubits when there is more than one qubit, as each qubit contributes 3 parameters. If the number of qubits is less than 2, a warning is logged since no entanglement is possible, and a fixed number of 2 parameters is used.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Hardware_Efficient.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters required for one layer of the circuit</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Hardware Efficient Ansatz.\n\n    The number of parameters is 3 times the number of qubits when there\n    is more than one qubit, as each qubit contributes 3 parameters.\n    If the number of qubits is less than 2, a warning is logged since\n    no entanglement is possible, and a fixed number of 2 parameters is used.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters required for one layer of the circuit\n    \"\"\"\n    if n_qubits &lt; 2:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling","title":"<code>No_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class No_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the NoEntangling ansatz.\n\n        The number of parameters is calculated as n_qubits*3.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        return n_qubits * 3\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None):\n        \"\"\"\n        Creates a circuit without entangling, but with U3 gates on all qubits\n\n        Length of flattened vector must be n_qubits*3\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*3\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a circuit without entangling, but with U3 gates on all qubits</p> <p>Length of flattened vector must be n_qubits*3</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*3 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None):\n    \"\"\"\n    Creates a circuit without entangling, but with U3 gates on all qubits\n\n    Length of flattened vector must be n_qubits*3\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*3\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the NoEntangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*3.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.No_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the NoEntangling ansatz.\n\n    The number of parameters is calculated as n_qubits*3.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    return n_qubits * 3\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling","title":"<code>Strongly_Entangling</code>","text":"<p>               Bases: <code>Circuit</code></p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Strongly_Entangling(Circuit):\n    @staticmethod\n    def n_params_per_layer(n_qubits: int) -&gt; int:\n        \"\"\"\n        Returns the number of parameters per layer for the\n        Strongly Entangling ansatz.\n\n        The number of parameters is calculated as n_qubits*6.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        int\n            Number of parameters per layer\n        \"\"\"\n        if n_qubits &lt; 2:\n            log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n        return n_qubits * 6\n\n    @staticmethod\n    def get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n        \"\"\"\n        No controlled rotation gates available. Always None.\n\n        Parameters\n        ----------\n        n_qubits : int\n            Number of qubits in the circuit\n\n        Returns\n        -------\n        Optional[np.ndarray]\n            List of all controlled indices, or None if the circuit does not\n            contain controlled rotation gates.\n        \"\"\"\n        return None\n\n    @staticmethod\n    def build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n        \"\"\"\n        Creates a Strongly Entangling ansatz.\n\n        Length of flattened vector must be n_qubits*6\n\n        Parameters\n        ----------\n        w : np.ndarray\n            Weight vector of size n_qubits*6\n        n_qubits : int\n            Number of qubits\n        noise_params : Optional[Dict[str, float]], optional\n            Dictionary of noise parameters to apply to the gates\n        \"\"\"\n        w_idx = 0\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n        for q in range(n_qubits):\n            Gates.Rot(\n                w[w_idx],\n                w[w_idx + 1],\n                w[w_idx + 2],\n                wires=q,\n                noise_params=noise_params,\n            )\n            w_idx += 3\n\n        if n_qubits &gt; 1:\n            for q in range(n_qubits):\n                Gates.CX(\n                    wires=[q, (q + n_qubits // 2) % n_qubits],\n                    noise_params=noise_params,\n                )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build","title":"<code>build(w, n_qubits, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Creates a Strongly Entangling ansatz.</p> <p>Length of flattened vector must be n_qubits*6</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.build--parameters","title":"Parameters","text":"<p>w : np.ndarray     Weight vector of size n_qubits*6 n_qubits : int     Number of qubits noise_params : Optional[Dict[str, float]], optional     Dictionary of noise parameters to apply to the gates</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef build(w: np.ndarray, n_qubits: int, noise_params=None) -&gt; None:\n    \"\"\"\n    Creates a Strongly Entangling ansatz.\n\n    Length of flattened vector must be n_qubits*6\n\n    Parameters\n    ----------\n    w : np.ndarray\n        Weight vector of size n_qubits*6\n    n_qubits : int\n        Number of qubits\n    noise_params : Optional[Dict[str, float]], optional\n        Dictionary of noise parameters to apply to the gates\n    \"\"\"\n    w_idx = 0\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(wires=[q, (q + 1) % n_qubits], noise_params=noise_params)\n\n    for q in range(n_qubits):\n        Gates.Rot(\n            w[w_idx],\n            w[w_idx + 1],\n            w[w_idx + 2],\n            wires=q,\n            noise_params=noise_params,\n        )\n        w_idx += 3\n\n    if n_qubits &gt; 1:\n        for q in range(n_qubits):\n            Gates.CX(\n                wires=[q, (q + n_qubits // 2) % n_qubits],\n                noise_params=noise_params,\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices","title":"<code>get_control_indices(n_qubits)</code>  <code>staticmethod</code>","text":"<p>No controlled rotation gates available. Always None.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.get_control_indices--returns","title":"Returns","text":"<p>Optional[np.ndarray]     List of all controlled indices, or None if the circuit does not     contain controlled rotation gates.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef get_control_indices(n_qubits: int) -&gt; Optional[np.ndarray]:\n    \"\"\"\n    No controlled rotation gates available. Always None.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    Optional[np.ndarray]\n        List of all controlled indices, or None if the circuit does not\n        contain controlled rotation gates.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer","title":"<code>n_params_per_layer(n_qubits)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters per layer for the Strongly Entangling ansatz.</p> <p>The number of parameters is calculated as n_qubits*6.</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--parameters","title":"Parameters","text":"<p>n_qubits : int     Number of qubits in the circuit</p>"},{"location":"references/#qml_essentials.ansaetze.Ansaetze.Strongly_Entangling.n_params_per_layer--returns","title":"Returns","text":"<p>int     Number of parameters per layer</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef n_params_per_layer(n_qubits: int) -&gt; int:\n    \"\"\"\n    Returns the number of parameters per layer for the\n    Strongly Entangling ansatz.\n\n    The number of parameters is calculated as n_qubits*6.\n\n    Parameters\n    ----------\n    n_qubits : int\n        Number of qubits in the circuit\n\n    Returns\n    -------\n    int\n        Number of parameters per layer\n    \"\"\"\n    if n_qubits &lt; 2:\n        log.warning(\"Number of Qubits &lt; 2, no entanglement available\")\n    return n_qubits * 6\n</code></pre>"},{"location":"references/#gates","title":"Gates","text":"<pre><code>from qml_essentials.ansaetze import Gates\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>class Gates:\n    rng = np.random.default_rng()\n\n    @staticmethod\n    def init_rng(seed: int):\n        \"\"\"\n        Initializes the random number generator with the given seed.\n\n        Parameters\n        ----------\n        seed : int\n            The seed for the random number generator.\n        \"\"\"\n        Gates.rng = np.random.default_rng(seed)\n\n    @staticmethod\n    def Noise(\n        wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n    ) -&gt; None:\n        \"\"\"\n        Applies noise to the given wires.\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the noise to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        if noise_params is not None:\n            if isinstance(wires, int):\n                wires = [wires]  # single qubit gate\n            # iterate for multi qubit gates\n            for wire in wires:\n                qml.BitFlip(noise_params.get(\"BitFlip\", 0.0), wires=wire)\n                qml.PhaseFlip(noise_params.get(\"PhaseFlip\", 0.0), wires=wire)\n                qml.DepolarizingChannel(\n                    noise_params.get(\"Depolarizing\", 0.0), wires=wire\n                )\n\n    @staticmethod\n    def GateError(\n        w: np.ndarray, noise_params: Optional[Dict[str, float]] = None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Applies a gate error to the given rotation angle(s).\n\n        Parameters\n        ----------\n        w : np.ndarray\n            The rotation angle(s) in radians.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -GateError: Applies a normal distribution error to the rotation\n            angle(s). The standard deviation of the noise is specified by\n            the \"GateError\" key in the dictionary.\n\n            All parameters are optional and default to 0.0 if not provided.\n\n        Returns\n        -------\n        np.ndarray\n            The modified rotation angle(s) after applying the gate error.\n        \"\"\"\n        if noise_params is not None:\n            w += Gates.rng.normal(0, noise_params[\"GateError\"], w.shape)\n        return w\n\n    @staticmethod\n    def Rot(phi, theta, omega, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        phi : float\n            The first rotation angle in radians.\n        theta : float\n            The second rotation angle in radians.\n        omega : float\n            The third rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        if noise_params is not None and \"GateError\" in noise_params:\n            phi += Gates.rng.normal(0, noise_params[\"GateError\"])\n            theta += Gates.rng.normal(0, noise_params[\"GateError\"])\n            omega += Gates.rng.normal(0, noise_params[\"GateError\"])\n        qml.Rot(phi, theta, omega, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RX(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the X axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.RX(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RY(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the Y axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n            given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.RY(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def RZ(w, wires, noise_params=None):\n        \"\"\"\n        Applies a rotation around the Z axis to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.RZ(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRX(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the X axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRX(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRY(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the Y axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRY(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CRZ(w, wires, noise_params=None):\n        \"\"\"\n        Applies a controlled rotation around the Z axis to the given wires\n        and adds `Noise`\n\n        Parameters\n        ----------\n        w : float\n            The rotation angle in radians.\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled rotation gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n            given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        w = Gates.GateError(w, noise_params)\n        qml.CRZ(w, wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CX(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled NOT gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled NOT gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CNOT(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CY(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled Y gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled Y gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CY(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def CZ(wires, noise_params=None):\n        \"\"\"\n        Applies a controlled Z gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the controlled Z gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.CZ(wires=wires)\n        Gates.Noise(wires, noise_params)\n\n    @staticmethod\n    def H(wires, noise_params=None):\n        \"\"\"\n        Applies a Hadamard gate to the given wires and adds `Noise`\n\n        Parameters\n        ----------\n        wires : Union[int, List[int]]\n            The wire(s) to apply the Hadamard gate to.\n        noise_params : Optional[Dict[str, float]]\n            A dictionary of noise parameters. The following noise gates are\n            supported:\n           -BitFlip: Applies a bit flip error to the given wires.\n           -PhaseFlip: Applies a phase flip error to the given wires.\n           -Depolarizing: Applies a depolarizing channel error to the\n              given wires.\n\n            All parameters are optional and default to 0.0 if not provided.\n        \"\"\"\n        qml.Hadamard(wires=wires)\n        Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRX","title":"<code>CRX(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the X axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRX--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRX(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the X axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRX(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRY","title":"<code>CRY(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the Y axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRY--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRY(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the Y axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRY(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRZ","title":"<code>CRZ(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled rotation around the Z axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CRZ--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the controlled rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the     given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CRZ(w, wires, noise_params=None):\n    \"\"\"\n    Applies a controlled rotation around the Z axis to the given wires\n    and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n        given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.CRZ(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CX","title":"<code>CX(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled NOT gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CX--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled NOT gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CX(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled NOT gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled NOT gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CNOT(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CY","title":"<code>CY(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled Y gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CY--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled Y gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CY(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled Y gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled Y gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CY(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.CZ","title":"<code>CZ(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a controlled Z gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.CZ--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the controlled Z gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef CZ(wires, noise_params=None):\n    \"\"\"\n    Applies a controlled Z gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the controlled Z gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.CZ(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError","title":"<code>GateError(w, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a gate error to the given rotation angle(s).</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError--parameters","title":"Parameters","text":"<p>w : np.ndarray     The rotation angle(s) in radians. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -GateError: Applies a normal distribution error to the rotation     angle(s). The standard deviation of the noise is specified by     the \"GateError\" key in the dictionary.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.GateError--returns","title":"Returns","text":"<p>np.ndarray     The modified rotation angle(s) after applying the gate error.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef GateError(\n    w: np.ndarray, noise_params: Optional[Dict[str, float]] = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Applies a gate error to the given rotation angle(s).\n\n    Parameters\n    ----------\n    w : np.ndarray\n        The rotation angle(s) in radians.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -GateError: Applies a normal distribution error to the rotation\n        angle(s). The standard deviation of the noise is specified by\n        the \"GateError\" key in the dictionary.\n\n        All parameters are optional and default to 0.0 if not provided.\n\n    Returns\n    -------\n    np.ndarray\n        The modified rotation angle(s) after applying the gate error.\n    \"\"\"\n    if noise_params is not None:\n        w += Gates.rng.normal(0, noise_params[\"GateError\"], w.shape)\n    return w\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.H","title":"<code>H(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a Hadamard gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.H--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the Hadamard gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef H(wires, noise_params=None):\n    \"\"\"\n    Applies a Hadamard gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the Hadamard gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.Hadamard(wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.Noise","title":"<code>Noise(wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies noise to the given wires.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.Noise--parameters","title":"Parameters","text":"<p>wires : Union[int, List[int]]     The wire(s) to apply the noise to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Noise(\n    wires: Union[int, List[int]], noise_params: Optional[Dict[str, float]] = None\n) -&gt; None:\n    \"\"\"\n    Applies noise to the given wires.\n\n    Parameters\n    ----------\n    wires : Union[int, List[int]]\n        The wire(s) to apply the noise to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    if noise_params is not None:\n        if isinstance(wires, int):\n            wires = [wires]  # single qubit gate\n        # iterate for multi qubit gates\n        for wire in wires:\n            qml.BitFlip(noise_params.get(\"BitFlip\", 0.0), wires=wire)\n            qml.PhaseFlip(noise_params.get(\"PhaseFlip\", 0.0), wires=wire)\n            qml.DepolarizingChannel(\n                noise_params.get(\"Depolarizing\", 0.0), wires=wire\n            )\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RX","title":"<code>RX(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the X axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RX--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RX(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the X axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.RX(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RY","title":"<code>RY(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the Y axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RY--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the     given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RY(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the Y axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n        given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    w = Gates.GateError(w, noise_params)\n    qml.RY(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.RZ","title":"<code>RZ(w, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation around the Z axis to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.RZ--parameters","title":"Parameters","text":"<p>w : float     The rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef RZ(w, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation around the Z axis to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    w : float\n        The rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    qml.RZ(w, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.Rot","title":"<code>Rot(phi, theta, omega, wires, noise_params=None)</code>  <code>staticmethod</code>","text":"<p>Applies a rotation gate to the given wires and adds <code>Noise</code></p>"},{"location":"references/#qml_essentials.ansaetze.Gates.Rot--parameters","title":"Parameters","text":"<p>phi : float     The first rotation angle in radians. theta : float     The second rotation angle in radians. omega : float     The third rotation angle in radians. wires : Union[int, List[int]]     The wire(s) to apply the rotation gate to. noise_params : Optional[Dict[str, float]]     A dictionary of noise parameters. The following noise gates are     supported:    -BitFlip: Applies a bit flip error to the given wires.    -PhaseFlip: Applies a phase flip error to the given wires.    -Depolarizing: Applies a depolarizing channel error to the       given wires.</p> <pre><code>All parameters are optional and default to 0.0 if not provided.\n</code></pre> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef Rot(phi, theta, omega, wires, noise_params=None):\n    \"\"\"\n    Applies a rotation gate to the given wires and adds `Noise`\n\n    Parameters\n    ----------\n    phi : float\n        The first rotation angle in radians.\n    theta : float\n        The second rotation angle in radians.\n    omega : float\n        The third rotation angle in radians.\n    wires : Union[int, List[int]]\n        The wire(s) to apply the rotation gate to.\n    noise_params : Optional[Dict[str, float]]\n        A dictionary of noise parameters. The following noise gates are\n        supported:\n       -BitFlip: Applies a bit flip error to the given wires.\n       -PhaseFlip: Applies a phase flip error to the given wires.\n       -Depolarizing: Applies a depolarizing channel error to the\n          given wires.\n\n        All parameters are optional and default to 0.0 if not provided.\n    \"\"\"\n    if noise_params is not None and \"GateError\" in noise_params:\n        phi += Gates.rng.normal(0, noise_params[\"GateError\"])\n        theta += Gates.rng.normal(0, noise_params[\"GateError\"])\n        omega += Gates.rng.normal(0, noise_params[\"GateError\"])\n    qml.Rot(phi, theta, omega, wires=wires)\n    Gates.Noise(wires, noise_params)\n</code></pre>"},{"location":"references/#qml_essentials.ansaetze.Gates.init_rng","title":"<code>init_rng(seed)</code>  <code>staticmethod</code>","text":"<p>Initializes the random number generator with the given seed.</p>"},{"location":"references/#qml_essentials.ansaetze.Gates.init_rng--parameters","title":"Parameters","text":"<p>seed : int     The seed for the random number generator.</p> Source code in <code>qml_essentials/ansaetze.py</code> <pre><code>@staticmethod\ndef init_rng(seed: int):\n    \"\"\"\n    Initializes the random number generator with the given seed.\n\n    Parameters\n    ----------\n    seed : int\n        The seed for the random number generator.\n    \"\"\"\n    Gates.rng = np.random.default_rng(seed)\n</code></pre>"},{"location":"references/#model","title":"Model","text":"<pre><code>from qml_essentials.model import Model\n</code></pre> <p>A quantum circuit model.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>class Model:\n    \"\"\"\n    A quantum circuit model.\n    \"\"\"\n\n    lightning_threshold = 12\n\n    def __init__(\n        self,\n        n_qubits: int,\n        n_layers: int,\n        circuit_type: Union[str, Circuit],\n        data_reupload: Union[bool, List[int]] = True,\n        state_preparation: Union[str, Callable, List[str], List[Callable]] = None,\n        encoding: Union[str, Callable, List[str], List[Callable]] = Gates.RX,\n        initialization: str = \"random\",\n        initialization_domain: List[float] = [0, 2 * np.pi],\n        output_qubit: Union[List[int], int] = -1,\n        shots: Optional[int] = None,\n        random_seed: int = 1000,\n        as_pauli_circuit: bool = False,\n        remove_zero_encoding: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the quantum circuit model.\n        Parameters will have the shape [impl_n_layers, parameters_per_layer]\n        where impl_n_layers is the number of layers provided and added by one\n        depending if data_reupload is True and parameters_per_layer is given by\n        the chosen ansatz.\n\n        The model is initialized with the following parameters as defaults:\n        - noise_params: None\n        - execution_type: \"expval\"\n        - shots: None\n\n        Args:\n            n_qubits (int): The number of qubits in the circuit.\n            n_layers (int): The number of layers in the circuit.\n            circuit_type (str, Circuit): The type of quantum circuit to use.\n                If None, defaults to \"no_ansatz\".\n            data_reupload (bool, optional): Whether to reupload data to the\n                quantum device on each measurement. Defaults to True.\n            encoding (Union[str, Callable, List[str], List[Callable]], optional):\n                The unitary to use for encoding the input data. Can be a string\n                (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n                If input is multidimensional it is assumed to be a list of\n                unitaries or a list of strings.\n            initialization (str, optional): The strategy to initialize the parameters.\n                Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n                Defaults to \"random\".\n            output_qubit (List[int], int, optional): The index of the output\n                qubit (or qubits). When set to -1 all qubits are measured, or a\n                global measurement is conducted, depending on the execution\n                type.\n            shots (Optional[int], optional): The number of shots to use for\n                the quantum device. Defaults to None.\n            random_seed (int, optional): seed for the random number generator\n                in initialization is \"random\" and for random noise parameters.\n                Defaults to 1000.\n            as_pauli_circuit (bool, optional): whether the circuit is\n                transformed to a Pauli-Clifford circuit as described by Nemkov\n                et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is\n                required for analytical Fourier coefficient computation.\n                Defaults to False.\n            remove_zero_encoding (bool, optional): whether to\n                remove the zero encoding from the circuit. Defaults to True.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialize default parameters needed for circuit evaluation\n        self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n        self.execution_type: Optional[str] = \"expval\"\n        self.shots = shots\n        self.remove_zero_encoding = remove_zero_encoding\n\n        if isinstance(output_qubit, list):\n            assert (\n                len(output_qubit) &lt;= n_qubits\n            ), f\"Size of output_qubit {len(output_qubit)} cannot be\\\n            larger than number of qubits {n_qubits}.\"\n        self.output_qubit: Union[List[int], int] = output_qubit\n\n        # Copy the parameters\n        self.n_qubits: int = n_qubits\n        self.n_layers: int = n_layers\n\n        # Process data reuploading strategy and set degree\n        if not isinstance(data_reupload, bool):\n            if not isinstance(data_reupload, np.ndarray):\n                data_reupload = np.array(data_reupload)\n            assert data_reupload.shape == (n_layers, n_qubits)\n        else:\n            if data_reupload:\n                impl_n_layers: int = (\n                    n_layers + 1\n                )  # we need L+1 according to Schuld et al.\n                data_reupload = np.ones((n_layers, n_qubits))\n            else:\n                impl_n_layers: int = n_layers\n                data_reupload = np.zeros((n_layers, n_qubits))\n                data_reupload[0][0] = 1\n\n        self.degree = np.count_nonzero(data_reupload)\n        self.data_reupload = data_reupload\n\n        if self.degree &gt; 1:\n            impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n        else:\n            impl_n_layers = n_layers\n\n        # Initialize ansatz\n        # only weak check for str. We trust the user to provide sth useful\n        if isinstance(circuit_type, str):\n            self.pqc: Callable[[Optional[np.ndarray], int], int] = getattr(\n                Ansaetze, circuit_type or \"No_Ansatz\"\n            )()\n        else:\n            self.pqc = circuit_type()\n\n        # Initialize rng in Gates\n        Gates.init_rng(random_seed)\n\n        # Initialize state preparation\n        # first check if we have a str, list or callable\n        if isinstance(state_preparation, str):\n            # if str, use the pennylane fct\n            self._sp = [getattr(Gates, f\"{state_preparation}\")]\n        elif isinstance(state_preparation, list):\n            # if list, check if str or callable\n            if isinstance(state_preparation[0], str):\n                self._sp = [getattr(Gates, f\"{sp}\") for sp in state_preparation]\n            else:\n                self._sp = state_preparation\n        elif state_preparation is None:\n            self._sp = [lambda *args, **kwargs: None]\n        else:\n            # default to callable\n            self._sp = [state_preparation]\n\n        # Initialize encoding\n        # first check if we have a str, list or callable\n        if isinstance(encoding, str):\n            # if str, use the pennylane fct\n            self._enc = getattr(Gates, f\"{encoding}\")\n        elif isinstance(encoding, list):\n            # if list, check if str or callable\n            if isinstance(encoding[0], str):\n                self._enc = [getattr(Gates, f\"{enc}\") for enc in encoding]\n            else:\n                self._enc = encoding\n\n            if len(self._enc) == 1:\n                self._enc = self._enc[0]\n        else:\n            # default to callable\n            self._enc = encoding\n\n        # Number of possible inputs\n        self.n_input_feat = len(encoding) if isinstance(encoding, List) else 1\n\n        log.info(f\"Using {circuit_type} circuit.\")\n\n        log.info(f\"Number of implicit layers set to {impl_n_layers}.\")\n        # calculate the shape of the parameter vector here, we will re-use this in init.\n        self._params_shape: Tuple[int, int] = (\n            impl_n_layers,\n            self.pqc.n_params_per_layer(self.n_qubits),\n        )\n        # this will also be re-used in the init method,\n        # however, only if nothing is provided\n        self._inialization_strategy = initialization\n        self._initialization_domain = initialization_domain\n\n        # ..here! where we only require a rng\n        self.initialize_params(np.random.default_rng(random_seed))\n\n        # Initialize two circuits, one with the default device and\n        # one with the mixed device\n        # which allows us to later route depending on the state_vector flag\n        self.as_pauli_circuit = as_pauli_circuit\n\n        self.circuit_mixed: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n        )\n\n    @property\n    def as_pauli_circuit(self) -&gt; bool:\n        return self._as_pauli_circuit\n\n    @as_pauli_circuit.setter\n    def as_pauli_circuit(self, value: bool) -&gt; None:\n        self._as_pauli_circuit = value\n\n        self.circuit: qml.QNode = qml.QNode(\n            self._circuit,\n            qml.device(\n                (\n                    \"default.qubit\"\n                    if self.n_qubits &lt; self.lightning_threshold\n                    else \"lightning.qubit\"\n                ),\n                shots=self.shots,\n                wires=self.n_qubits,\n            ),\n            interface=\"autograd\" if self.shots is not None else \"auto\",\n            diff_method=\"parameter-shift\" if self.shots is not None else \"best\",\n        )\n\n        if value:\n            pauli_circuit_transform = qml.transform(\n                PauliCircuit.from_parameterised_circuit\n            )\n            self.circuit = pauli_circuit_transform(self.circuit)\n\n    @property\n    def noise_params(self) -&gt; Optional[Dict[str, Union[float, Dict[str, float]]]]:\n        \"\"\"\n        Gets the noise parameters of the model.\n\n        Returns:\n            Optional[Dict[str, float]]: A dictionary of\n            noise parameters or None if not set.\n        \"\"\"\n        return self._noise_params\n\n    @noise_params.setter\n    def noise_params(\n        self, kvs: Optional[Dict[str, Union[float, Dict[str, float]]]]\n    ) -&gt; None:\n        \"\"\"\n        Sets the noise parameters of the model.\n\n        Typically a \"noise parameter\" refers to the error probability.\n        ThermalRelaxation is a special case, and supports a dict as value with\n        structure:\n            \"ThermalRelaxation\":\n            {\n                \"t1\": 2000, # relative t1 time.\n                \"t2\": 1000, # relative t2 time\n                \"t_factor\" 1: # relative gate time factor\n            },\n\n        Args:\n            value (Optional[Dict[str, Union[float, Dict[str, float]]]]): A\n            dictionary of noise parameters. If all values are 0.0, the noise\n            parameters are set to None.\n\n        Returns:\n            None\n        \"\"\"\n        # set to None if only zero values provided\n        if kvs is not None and all(np == 0.0 for np in kvs.values()):\n            kvs = None\n\n        # set default values\n        if kvs is not None:\n            kvs.setdefault(\"BitFlip\", 0.0)\n            kvs.setdefault(\"PhaseFlip\", 0.0)\n            kvs.setdefault(\"Depolarizing\", 0.0)\n            kvs.setdefault(\"AmplitudeDamping\", 0.0)\n            kvs.setdefault(\"PhaseDamping\", 0.0)\n            kvs.setdefault(\"GateError\", 0.0)\n            kvs.setdefault(\"ThermalRelaxation\", None)\n            kvs.setdefault(\"StatePreparation\", 0.0)\n            kvs.setdefault(\"Measurement\", 0.0)\n\n            # check if there are any keys not supported\n            for key in kvs.keys():\n                if key not in [\n                    \"BitFlip\",\n                    \"PhaseFlip\",\n                    \"Depolarizing\",\n                    \"AmplitudeDamping\",\n                    \"PhaseDamping\",\n                    \"GateError\",\n                    \"ThermalRelaxation\",\n                    \"StatePreparation\",\n                    \"Measurement\",\n                ]:\n                    warnings.warn(\n                        f\"Noise type {key} is not supported by this package\",\n                        UserWarning,\n                    )\n\n            # check valid params for thermal relaxation noise channel\n            tr_params = kvs[\"ThermalRelaxation\"]\n            if isinstance(tr_params, dict):\n                tr_params.setdefault(\"t1\", 0.0)\n                tr_params.setdefault(\"t2\", 0.0)\n                tr_params.setdefault(\"t_factor\", 0.0)\n                for k in tr_params.keys():\n                    if k not in [\n                        \"t1\",\n                        \"t2\",\n                        \"t_factor\",\n                    ]:\n                        warnings.warn(\n                            f\"Thermal Relaxation parameter {k} is not supported \"\n                            f\"by this package\",\n                            UserWarning,\n                        )\n                if not all(tr_params.values()) or tr_params[\"t2\"] &gt; 2 * tr_params[\"t1\"]:\n                    warnings.warn(\n                        \"Received invalid values for Thermal Relaxation noise \"\n                        \"parameter. Thermal relaxation is not applied!\",\n                        UserWarning,\n                    )\n                    kvs[\"ThermalRelaxation\"] = 0.0\n\n        self._noise_params = kvs\n\n    @property\n    def execution_type(self) -&gt; str:\n        \"\"\"\n        Gets the execution type of the model.\n\n        Returns:\n            str: The execution type, one of 'density', 'expval', or 'probs'.\n        \"\"\"\n        return self._execution_type\n\n    @execution_type.setter\n    def execution_type(self, value: str) -&gt; None:\n        if value not in [\"density\", \"state\", \"expval\", \"probs\"]:\n            raise ValueError(f\"Invalid execution type: {value}.\")\n\n        if (value == \"density\" or value == \"state\") and self.output_qubit != -1:\n            warnings.warn(\n                f\"{value} measurement does ignore output_qubit, which is \"\n                f\"{self.output_qubit}.\",\n                UserWarning,\n            )\n\n        if value == \"probs\" and self.shots is None:\n            warnings.warn(\n                \"Setting execution_type to probs without specifying shots.\",\n                UserWarning,\n            )\n\n        if value == \"density\" and self.shots is not None:\n            warnings.warn(\n                \"Setting execution_type to density with specified shots.\",\n                UserWarning,\n            )\n\n        self._execution_type = value\n\n    @property\n    def shots(self) -&gt; Optional[int]:\n        \"\"\"\n        Gets the number of shots to use for the quantum device.\n\n        Returns:\n            Optional[int]: The number of shots.\n        \"\"\"\n        return self._shots\n\n    @shots.setter\n    def shots(self, value: Optional[int]) -&gt; None:\n        \"\"\"\n        Sets the number of shots to use for the quantum device.\n\n        Args:\n            value (Optional[int]): The number of shots.\n            If an integer less than or equal to 0 is provided, it is set to None.\n\n        Returns:\n            None\n        \"\"\"\n        if type(value) is int and value &lt;= 0:\n            value = None\n        self._shots = value\n\n    def initialize_params(\n        self,\n        rng: np.random.Generator,\n        repeat: int = None,\n        initialization: str = None,\n        initialization_domain: List[float] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the parameters of the model.\n\n        Args:\n            rng: A random number generator to use for initialization.\n            repeat: The number of times to repeat the parameters.\n                If None, the number of layers is used.\n            initialization: The strategy to use for parameter initialization.\n                If None, the strategy specified in the constructor is used.\n            initialization_domain: The domain to use for parameter initialization.\n                If None, the domain specified in the constructor is used.\n\n        Returns:\n            None\n        \"\"\"\n        params_shape = (\n            self._params_shape if repeat is None else [*self._params_shape, repeat]\n        )\n        # use existing strategy if not specified\n        initialization = initialization or self._inialization_strategy\n        initialization_domain = initialization_domain or self._initialization_domain\n\n        def set_control_params(params: np.ndarray, value: float) -&gt; np.ndarray:\n            indices = self.pqc.get_control_indices(self.n_qubits)\n            if indices is None:\n                warnings.warn(\n                    f\"Specified {initialization} but circuit\\\n                    does not contain controlled rotation gates.\\\n                    Parameters are intialized randomly.\",\n                    UserWarning,\n                )\n            else:\n                params[:, indices[0] : indices[1] : indices[2]] = (\n                    np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                    * value\n                )\n            return params\n\n        if initialization == \"random\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n        elif initialization == \"zeros\":\n            self.params: np.ndarray = np.zeros(params_shape, requires_grad=True)\n        elif initialization == \"pi\":\n            self.params: np.ndarray = np.ones(params_shape, requires_grad=True) * np.pi\n        elif initialization == \"zero-controlled\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n            self.params = set_control_params(self.params, 0)\n        elif initialization == \"pi-controlled\":\n            self.params: np.ndarray = rng.uniform(\n                *initialization_domain, params_shape, requires_grad=True\n            )\n            self.params = set_control_params(self.params, np.pi)\n        else:\n            raise Exception(\"Invalid initialization method\")\n\n        log.info(\n            f\"Initialized parameters with shape {self.params.shape}\\\n            using strategy {initialization}.\"\n        )\n\n    def _iec(\n        self,\n        inputs: np.ndarray,\n        data_reupload: bool,\n        enc: Union[Callable, List[Callable]],\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Creates an AngleEncoding using RX gates\n\n        Args:\n            inputs (np.ndarray): length of vector must be 1, shape (1,)\n            data_reupload (bool, optional): Whether to reupload the data\n                for the IEC or not, default is True.\n\n        Returns:\n            None\n        \"\"\"\n        # check for zero, because due to input validation, input cannot be none\n        if self.remove_zero_encoding and not inputs.any():\n            return\n\n        if inputs.shape[1] == 1:\n            for q in range(self.n_qubits):\n                if data_reupload[q]:\n                    enc(inputs[:, 0], wires=q, noise_params=noise_params)\n        else:\n            for q in range(self.n_qubits):\n                if data_reupload[q]:\n                    for idx in range(inputs.shape[1]):\n                        enc[idx](inputs[:, idx], wires=q, noise_params=noise_params)\n\n    def _circuit(\n        self,\n        params: np.ndarray,\n        inputs: np.ndarray,\n    ) -&gt; Union[float, np.ndarray]:\n        \"\"\"\n        Creates a circuit with noise.\n\n        Args:\n            params (np.ndarray): weight vector of shape\n                [n_layers, n_qubits*n_params_per_layer]\n            inputs (np.ndarray): input vector of size 1\n        Returns:\n            Union[float, np.ndarray]: Expectation value of PauliZ(0)\n                of the circuit if state_vector is False and expval is True,\n                otherwise the density matrix of all qubits.\n        \"\"\"\n        self._variational(params=params, inputs=inputs)\n        return self._observable()\n\n    def _variational(self, params, inputs):\n        if self.noise_params is not None:\n            self._apply_state_prep_noise()\n\n        for q in range(self.n_qubits):\n            for _sp in self._sp:\n                _sp(wires=q, noise_params=self.noise_params)\n\n        for layer in range(0, self.n_layers):\n            self.pqc(params[layer], self.n_qubits, noise_params=self.noise_params)\n\n            self._iec(\n                inputs,\n                data_reupload=self.data_reupload[layer],\n                enc=self._enc,\n                noise_params=self.noise_params,\n            )\n\n            qml.Barrier(wires=list(range(self.n_qubits)), only_visual=True)\n\n        if self.degree &gt; 1:  # same check as in init\n            self.pqc(params[-1], self.n_qubits, noise_params=self.noise_params)\n\n        if self.noise_params is not None:\n            self._apply_general_noise()\n\n    def _observable(self):\n        # run mixed simualtion and get density matrix\n        if self.execution_type == \"density\":\n            return qml.density_matrix(wires=list(range(self.n_qubits)))\n        elif self.execution_type == \"state\":\n            return qml.state()\n        # run default simulation and get expectation value\n        elif self.execution_type == \"expval\":\n            # n-local measurement\n            if self.output_qubit == -1:\n                return [qml.expval(qml.PauliZ(q)) for q in range(self.n_qubits)]\n            # local measurement(s)\n            elif isinstance(self.output_qubit, int):\n                return qml.expval(qml.PauliZ(self.output_qubit))\n            # parity measurenment\n            elif isinstance(self.output_qubit, list):\n                obs = qml.PauliZ(self.output_qubit[0])\n                for out_qubit in self.output_qubit[1:]:\n                    obs = obs @ qml.PauliZ(out_qubit)\n                return qml.expval(obs)\n            else:\n                raise ValueError(\n                    f\"Invalid parameter 'output_qubit': {self.output_qubit}.\\\n                        Must be int, list or -1.\"\n                )\n        # run default simulation and get probs\n        elif self.execution_type == \"probs\":\n            if self.output_qubit == -1:\n                return qml.probs(wires=list(range(self.n_qubits)))\n            else:\n                return qml.probs(wires=self.output_qubit)\n        else:\n            raise ValueError(f\"Invalid execution_type: {self.execution_type}.\")\n\n    def _apply_state_prep_noise(self) -&gt; None:\n        \"\"\"\n        Applies a state preparation error on each qubit according to the\n        probability for StatePreparation provided in the noise_params.\n        \"\"\"\n        sp = self.noise_params.get(\"StatePreparation\", 0.0)\n        for q in range(self.n_qubits):\n            if sp &gt; 0:\n                qml.BitFlip(sp, wires=q)\n\n    def _apply_general_noise(self) -&gt; None:\n        \"\"\"\n        Applies general types of noise the full circuit (in contrast to gate\n        errors, applied directly at gate level, see Gates.Noise).\n\n        Possible types of noise are:\n            - AmplitudeDamping (specified through probability)\n            - PhaseDamping (specified through probability)\n            - ThermalRelaxation (specified through a dict, containing keys\n                                 \"t1\", \"t2\", \"t_factor\")\n            - Measurement (specified through probability)\n        \"\"\"\n        amp_damp = self.noise_params.get(\"AmplitudeDamping\", 0.0)\n        phase_damp = self.noise_params.get(\"PhaseDamping\", 0.0)\n        thermal_relax = self.noise_params.get(\"ThermalRelaxation\", 0.0)\n        meas = self.noise_params.get(\"Measurement\", 0.0)\n        for q in range(self.n_qubits):\n            if amp_damp &gt; 0:\n                qml.AmplitudeDamping(amp_damp, wires=q)\n            if phase_damp &gt; 0:\n                qml.PhaseDamping(phase_damp, wires=q)\n            if meas &gt; 0:\n                qml.BitFlip(meas, wires=q)\n            if isinstance(thermal_relax, dict):\n                t1 = thermal_relax[\"t1\"]\n                t2 = thermal_relax[\"t2\"]\n                t_factor = thermal_relax[\"t_factor\"]\n                circuit_depth = self.get_circuit_depth()\n                tg = circuit_depth * t_factor\n                qml.ThermalRelaxationError(1.0, t1, t2, tg, q)\n\n    def draw(self, inputs=None, figure=\"text\", *args, **kwargs):\n        \"\"\"\n        Draws the quantum circuit using the specified visualization method.\n\n        Args:\n            inputs (Optional[np.ndarray]): Input vector for the circuit. If None,\n                the default inputs are used.\n            figure (str, optional): The type of figure to generate. Must be one of\n                'text', 'mpl', or 'tikz'. Defaults to 'text'.\n            *args, **kwargs (optional): Additional arguments to the specific\n                visualization methods\n\n        Returns:\n            Either a string, matplotlib figure or TikzFigure object (similar to string)\n            depending on the chosen visualization.\n\n        Raises:\n            AssertionError: If the 'figure' argument is not one of the accepted values.\n        \"\"\"\n\n        if not isinstance(self.circuit, qml.QNode):\n            # TODO: throws strange argument error if not catched\n            return \"\"\n\n        assert figure in [\n            \"text\",\n            \"mpl\",\n            \"tikz\",\n        ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n        inputs = self._inputs_validation(inputs)\n\n        if figure == \"mpl\":\n            result = qml.draw_mpl(self.circuit)(\n                params=self.params, inputs=inputs, *args, **kwargs\n            )\n        elif figure == \"tikz\":\n            result = QuanTikz.build(\n                self.circuit, params=self.params, inputs=inputs, *args, **kwargs\n            )\n        else:\n            result = qml.draw(self.circuit)(params=self.params, inputs=inputs)\n        return result\n\n    def __repr__(self) -&gt; str:\n        return self.draw(figure=\"text\")\n\n    def __str__(self) -&gt; str:\n        return self.draw(figure=\"text\")\n\n    def __call__(\n        self,\n        params: Optional[np.ndarray] = None,\n        inputs: Optional[np.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        cache: Optional[bool] = False,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform a forward pass of the quantum circuit.\n\n        Args:\n            params (Optional[np.ndarray]): Weight vector of shape\n                [n_layers, n_qubits*n_params_per_layer].\n                If None, model internal parameters are used.\n            inputs (Optional[np.ndarray]): Input vector of shape [1].\n                If None, zeros are used.\n            noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n                Defaults to None which results in the last\n                set noise parameters being used.\n            cache (Optional[bool], optional): Whether to cache the results.\n                Defaults to False.\n            execution_type (str, optional): The type of execution.\n                Must be one of 'expval', 'density', or 'probs'.\n                Defaults to None which results in the last set execution type\n                being used.\n            force_mean (bool, optional): Whether to average\n                when performing n-local measurements.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: The output of the quantum circuit.\n                The shape depends on the execution_type.\n                - If execution_type is 'expval', returns an ndarray of shape\n                    (1,) if output_qubit is -1, else (len(output_qubit),).\n                - If execution_type is 'density', returns an ndarray\n                    of shape (2**n_qubits, 2**n_qubits).\n                - If execution_type is 'probs', returns an ndarray\n                    of shape (2**n_qubits,) if output_qubit is -1, else\n                    (2**len(output_qubit),).\n        \"\"\"\n        # Call forward method which handles the actual caching etc.\n        return self._forward(\n            params=params,\n            inputs=inputs,\n            noise_params=noise_params,\n            cache=cache,\n            execution_type=execution_type,\n            force_mean=force_mean,\n        )\n\n    def _params_validation(self, params) -&gt; np.ndarray:\n        \"\"\"\n        Sets the parameters when calling the quantum circuit\n\n        Args:\n            params (np.ndarray): The parameters used for the call\n        \"\"\"\n        if params is None:\n            params = self.params\n        else:\n            if numpy_boxes.ArrayBox == type(params):\n                self.params = params._value\n            else:\n                self.params = params\n        return params\n\n    def _inputs_validation(\n        self, inputs: Union[None, List, float, int, np.ndarray]\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Validate the inputs to be a 2D numpy array of shape (batch_size, n_inputs).\n\n        Args:\n            inputs (Union[None, List, float, int, np.ndarray]): The input to validate.\n\n        Returns:\n            np.ndarray: The validated input.\n        \"\"\"\n        if inputs is None:\n            # initialize to zero\n            inputs = np.array([[0] * self.n_input_feat])\n        elif isinstance(inputs, List):\n            inputs = np.stack(inputs)\n        elif isinstance(inputs, float) or isinstance(inputs, int):\n            inputs = np.array([inputs])\n\n        if len(inputs.shape) == 1:\n            if self.n_input_feat == 1:\n                # add a batch dimension\n                inputs = inputs.reshape(inputs.shape[0], 1)\n            else:\n                if inputs.shape[0] == self.n_input_feat:\n                    inputs = inputs.reshape(1, -1)\n                else:\n                    inputs = inputs.reshape(-1, 1)\n                    inputs = inputs.repeat(self.n_input_feat, axis=1)\n                    warnings.warn(\n                        f\"Expected {self.n_input_feat} inputs, but {inputs.shape[0]} \"\n                        \"was provided, replicating input for all input features.\",\n                        UserWarning,\n                    )\n        else:\n            if inputs.shape[1] != self.n_input_feat:\n                raise ValueError(\n                    f\"Wrong number of inputs provided. Expected {self.n_input_feat} \"\n                    f\"inputs, but input has shape {inputs.shape}.\"\n                )\n\n        return inputs\n\n    def _forward(\n        self,\n        params: Optional[np.ndarray] = None,\n        inputs: Optional[np.ndarray] = None,\n        noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n        cache: Optional[bool] = False,\n        execution_type: Optional[str] = None,\n        force_mean: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform a forward pass of the quantum circuit.\n\n        Args:\n            params (Optional[np.ndarray]): Weight vector of shape\n                [n_layers, n_qubits*n_params_per_layer].\n                If None, model internal parameters are used.\n            inputs (Optional[np.ndarray]): Input vector of shape [1].\n                If None, zeros are used.\n            noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n                Defaults to None which results in the last\n                set noise parameters being used.\n            cache (Optional[bool], optional): Whether to cache the results.\n                Defaults to False.\n            execution_type (str, optional): The type of execution.\n                Must be one of 'expval', 'density', or 'probs'.\n                Defaults to None which results in the last set execution type\n                being used.\n            force_mean (bool, optional): Whether to average\n                when performing n-local measurements.\n                Defaults to False.\n\n        Returns:\n            np.ndarray: The output of the quantum circuit.\n                The shape depends on the execution_type.\n                - If execution_type is 'expval', returns an ndarray of shape\n                    (1,) if output_qubit is -1, else (len(output_qubit),).\n                - If execution_type is 'density', returns an ndarray\n                    of shape (2**n_qubits, 2**n_qubits).\n                - If execution_type is 'probs', returns an ndarray\n                    of shape (2**n_qubits,) if output_qubit is -1, else\n                    (2**len(output_qubit),).\n\n        Raises:\n            NotImplementedError: If the number of shots is not None or if the\n                expectation value is True.\n        \"\"\"\n        # set the parameters as object attributes\n        if noise_params is not None:\n            self.noise_params = noise_params\n        if execution_type is not None:\n            self.execution_type = execution_type\n\n        params = self._params_validation(params)\n        inputs = self._inputs_validation(inputs)\n\n        # the qasm representation contains the bound parameters,\n        # thus it is ok to hash that\n        hs = hashlib.md5(\n            repr(\n                {\n                    \"n_qubits\": self.n_qubits,\n                    \"n_layers\": self.n_layers,\n                    \"pqc\": self.pqc.__class__.__name__,\n                    \"dru\": self.data_reupload,\n                    \"params\": self.params,  # use safe-params\n                    \"noise_params\": self.noise_params,\n                    \"execution_type\": self.execution_type,\n                    \"inputs\": inputs,\n                    \"output_qubit\": self.output_qubit,\n                }\n            ).encode(\"utf-8\")\n        ).hexdigest()\n\n        result: Optional[np.ndarray] = None\n        if cache:\n            name: str = f\"pqc_{hs}.npy\"\n\n            cache_folder: str = \".cache\"\n            if not os.path.exists(cache_folder):\n                os.mkdir(cache_folder)\n\n            file_path: str = os.path.join(cache_folder, name)\n\n            if os.path.isfile(file_path):\n                result = np.load(file_path)\n\n        if result is None:\n            # if density matrix requested or noise params used\n            if self.execution_type == \"density\" or self.noise_params is not None:\n                result = self.circuit_mixed(\n                    params=params,  # use arraybox params\n                    inputs=inputs,\n                )\n            else:\n                if not isinstance(self.circuit, qml.QNode):\n                    result = self.circuit(\n                        inputs=inputs,\n                    )\n                else:\n                    result = self.circuit(\n                        params=params,  # use arraybox params\n                        inputs=inputs,\n                    )\n\n        if isinstance(result, list):\n            result = np.stack(result)\n\n        if self.execution_type == \"expval\" and force_mean and self.output_qubit == -1:\n            # exception for torch layer because it swaps batch and output dimension\n            if not isinstance(self.circuit, qml.QNode):\n                result = result.mean(axis=-1)\n            else:\n                result = result.mean(axis=0)\n        elif self.execution_type == \"probs\" and force_mean and self.output_qubit == -1:\n            # exception for torch layer because it swaps batch and output dimension\n            if not isinstance(self.circuit, qml.QNode):\n                result = result[..., -1].sum(axis=-1)\n            else:\n                result = result[1:, ...].sum(axis=0)\n\n        if len(result.shape) == 3 and result.shape[0] == 1:\n            result = result[0]\n\n        if cache:\n            np.save(file_path, result)\n\n        return result\n\n    def get_specs(self, inputs: Optional[np.ndarray] = None) -&gt; dict:\n        \"\"\"\n        Get pennylane specs for the model.\n\n        Args:\n            inputs (Optional[np.ndarray]): The inputs, with which to call the\n                circuit. Defaults to None.\n\n        Returns:\n            dict: Dictionary of specs. The key \"resources\" contains information\n                about the circuit size and gate statistics.\n        \"\"\"\n        inputs = self._inputs_validation(inputs)\n        spec_model = deepcopy(self)\n        spec_model.noise_params = None  # remove noise\n        return qml.specs(spec_model.circuit)(self.params, inputs)\n\n    def get_circuit_depth(self, inputs: Optional[np.ndarray] = None) -&gt; int:\n        \"\"\"\n        Obtain circuit depth for the model\n\n        Args:\n            inputs (Optional[np.ndarray]): The inputs, with which to call the\n                circuit. Defaults to None.\n\n        Returns:\n            int: Circuit depth (longest path of gates in circuit.)\n        \"\"\"\n        return self.get_specs(inputs)[\"resources\"].depth\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.execution_type","title":"<code>execution_type</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the execution type of the model.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The execution type, one of 'density', 'expval', or 'probs'.</p>"},{"location":"references/#qml_essentials.model.Model.noise_params","title":"<code>noise_params</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the noise parameters of the model.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>Optional[Dict[str, float]]: A dictionary of</p> <code>Optional[Dict[str, Union[float, Dict[str, float]]]]</code> <p>noise parameters or None if not set.</p>"},{"location":"references/#qml_essentials.model.Model.shots","title":"<code>shots</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the number of shots to use for the quantum device.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The number of shots.</p>"},{"location":"references/#qml_essentials.model.Model.__call__","title":"<code>__call__(params=None, inputs=None, noise_params=None, cache=False, execution_type=None, force_mean=False)</code>","text":"<p>Perform a forward pass of the quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Optional[ndarray]</code> <p>Weight vector of shape [n_layers, n_qubits*n_params_per_layer]. If None, model internal parameters are used.</p> <code>None</code> <code>inputs</code> <code>Optional[ndarray]</code> <p>Input vector of shape [1]. If None, zeros are used.</p> <code>None</code> <code>noise_params</code> <code>Optional[Dict[str, float]]</code> <p>The noise parameters. Defaults to None which results in the last set noise parameters being used.</p> <code>None</code> <code>cache</code> <code>Optional[bool]</code> <p>Whether to cache the results. Defaults to False.</p> <code>False</code> <code>execution_type</code> <code>str</code> <p>The type of execution. Must be one of 'expval', 'density', or 'probs'. Defaults to None which results in the last set execution type being used.</p> <code>None</code> <code>force_mean</code> <code>bool</code> <p>Whether to average when performing n-local measurements. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The output of the quantum circuit. The shape depends on the execution_type. - If execution_type is 'expval', returns an ndarray of shape     (1,) if output_qubit is -1, else (len(output_qubit),). - If execution_type is 'density', returns an ndarray     of shape (2n_qubits, 2n_qubits). - If execution_type is 'probs', returns an ndarray     of shape (2n_qubits,) if output_qubit is -1, else     (2len(output_qubit),).</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __call__(\n    self,\n    params: Optional[np.ndarray] = None,\n    inputs: Optional[np.ndarray] = None,\n    noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None,\n    cache: Optional[bool] = False,\n    execution_type: Optional[str] = None,\n    force_mean: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform a forward pass of the quantum circuit.\n\n    Args:\n        params (Optional[np.ndarray]): Weight vector of shape\n            [n_layers, n_qubits*n_params_per_layer].\n            If None, model internal parameters are used.\n        inputs (Optional[np.ndarray]): Input vector of shape [1].\n            If None, zeros are used.\n        noise_params (Optional[Dict[str, float]], optional): The noise parameters.\n            Defaults to None which results in the last\n            set noise parameters being used.\n        cache (Optional[bool], optional): Whether to cache the results.\n            Defaults to False.\n        execution_type (str, optional): The type of execution.\n            Must be one of 'expval', 'density', or 'probs'.\n            Defaults to None which results in the last set execution type\n            being used.\n        force_mean (bool, optional): Whether to average\n            when performing n-local measurements.\n            Defaults to False.\n\n    Returns:\n        np.ndarray: The output of the quantum circuit.\n            The shape depends on the execution_type.\n            - If execution_type is 'expval', returns an ndarray of shape\n                (1,) if output_qubit is -1, else (len(output_qubit),).\n            - If execution_type is 'density', returns an ndarray\n                of shape (2**n_qubits, 2**n_qubits).\n            - If execution_type is 'probs', returns an ndarray\n                of shape (2**n_qubits,) if output_qubit is -1, else\n                (2**len(output_qubit),).\n    \"\"\"\n    # Call forward method which handles the actual caching etc.\n    return self._forward(\n        params=params,\n        inputs=inputs,\n        noise_params=noise_params,\n        cache=cache,\n        execution_type=execution_type,\n        force_mean=force_mean,\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.__init__","title":"<code>__init__(n_qubits, n_layers, circuit_type, data_reupload=True, state_preparation=None, encoding=Gates.RX, initialization='random', initialization_domain=[0, 2 * np.pi], output_qubit=-1, shots=None, random_seed=1000, as_pauli_circuit=False, remove_zero_encoding=True)</code>","text":"<p>Initialize the quantum circuit model. Parameters will have the shape [impl_n_layers, parameters_per_layer] where impl_n_layers is the number of layers provided and added by one depending if data_reupload is True and parameters_per_layer is given by the chosen ansatz.</p> <p>The model is initialized with the following parameters as defaults: - noise_params: None - execution_type: \"expval\" - shots: None</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits in the circuit.</p> required <code>n_layers</code> <code>int</code> <p>The number of layers in the circuit.</p> required <code>circuit_type</code> <code>(str, Circuit)</code> <p>The type of quantum circuit to use. If None, defaults to \"no_ansatz\".</p> required <code>data_reupload</code> <code>bool</code> <p>Whether to reupload data to the quantum device on each measurement. Defaults to True.</p> <code>True</code> <code>encoding</code> <code>Union[str, Callable, List[str], List[Callable]]</code> <p>The unitary to use for encoding the input data. Can be a string (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX. If input is multidimensional it is assumed to be a list of unitaries or a list of strings.</p> <code>RX</code> <code>initialization</code> <code>str</code> <p>The strategy to initialize the parameters. Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\". Defaults to \"random\".</p> <code>'random'</code> <code>output_qubit</code> <code>(List[int], int)</code> <p>The index of the output qubit (or qubits). When set to -1 all qubits are measured, or a global measurement is conducted, depending on the execution type.</p> <code>-1</code> <code>shots</code> <code>Optional[int]</code> <p>The number of shots to use for the quantum device. Defaults to None.</p> <code>None</code> <code>random_seed</code> <code>int</code> <p>seed for the random number generator in initialization is \"random\" and for random noise parameters. Defaults to 1000.</p> <code>1000</code> <code>as_pauli_circuit</code> <code>bool</code> <p>whether the circuit is transformed to a Pauli-Clifford circuit as described by Nemkov et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is required for analytical Fourier coefficient computation. Defaults to False.</p> <code>False</code> <code>remove_zero_encoding</code> <code>bool</code> <p>whether to remove the zero encoding from the circuit. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def __init__(\n    self,\n    n_qubits: int,\n    n_layers: int,\n    circuit_type: Union[str, Circuit],\n    data_reupload: Union[bool, List[int]] = True,\n    state_preparation: Union[str, Callable, List[str], List[Callable]] = None,\n    encoding: Union[str, Callable, List[str], List[Callable]] = Gates.RX,\n    initialization: str = \"random\",\n    initialization_domain: List[float] = [0, 2 * np.pi],\n    output_qubit: Union[List[int], int] = -1,\n    shots: Optional[int] = None,\n    random_seed: int = 1000,\n    as_pauli_circuit: bool = False,\n    remove_zero_encoding: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the quantum circuit model.\n    Parameters will have the shape [impl_n_layers, parameters_per_layer]\n    where impl_n_layers is the number of layers provided and added by one\n    depending if data_reupload is True and parameters_per_layer is given by\n    the chosen ansatz.\n\n    The model is initialized with the following parameters as defaults:\n    - noise_params: None\n    - execution_type: \"expval\"\n    - shots: None\n\n    Args:\n        n_qubits (int): The number of qubits in the circuit.\n        n_layers (int): The number of layers in the circuit.\n        circuit_type (str, Circuit): The type of quantum circuit to use.\n            If None, defaults to \"no_ansatz\".\n        data_reupload (bool, optional): Whether to reupload data to the\n            quantum device on each measurement. Defaults to True.\n        encoding (Union[str, Callable, List[str], List[Callable]], optional):\n            The unitary to use for encoding the input data. Can be a string\n            (e.g. \"RX\") or a callable (e.g. qml.RX). Defaults to qml.RX.\n            If input is multidimensional it is assumed to be a list of\n            unitaries or a list of strings.\n        initialization (str, optional): The strategy to initialize the parameters.\n            Can be \"random\", \"zeros\", \"zero-controlled\", \"pi\", or \"pi-controlled\".\n            Defaults to \"random\".\n        output_qubit (List[int], int, optional): The index of the output\n            qubit (or qubits). When set to -1 all qubits are measured, or a\n            global measurement is conducted, depending on the execution\n            type.\n        shots (Optional[int], optional): The number of shots to use for\n            the quantum device. Defaults to None.\n        random_seed (int, optional): seed for the random number generator\n            in initialization is \"random\" and for random noise parameters.\n            Defaults to 1000.\n        as_pauli_circuit (bool, optional): whether the circuit is\n            transformed to a Pauli-Clifford circuit as described by Nemkov\n            et al. (https://doi.org/10.1103/PhysRevA.108.032406), which is\n            required for analytical Fourier coefficient computation.\n            Defaults to False.\n        remove_zero_encoding (bool, optional): whether to\n            remove the zero encoding from the circuit. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize default parameters needed for circuit evaluation\n    self.noise_params: Optional[Dict[str, Union[float, Dict[str, float]]]] = None\n    self.execution_type: Optional[str] = \"expval\"\n    self.shots = shots\n    self.remove_zero_encoding = remove_zero_encoding\n\n    if isinstance(output_qubit, list):\n        assert (\n            len(output_qubit) &lt;= n_qubits\n        ), f\"Size of output_qubit {len(output_qubit)} cannot be\\\n        larger than number of qubits {n_qubits}.\"\n    self.output_qubit: Union[List[int], int] = output_qubit\n\n    # Copy the parameters\n    self.n_qubits: int = n_qubits\n    self.n_layers: int = n_layers\n\n    # Process data reuploading strategy and set degree\n    if not isinstance(data_reupload, bool):\n        if not isinstance(data_reupload, np.ndarray):\n            data_reupload = np.array(data_reupload)\n        assert data_reupload.shape == (n_layers, n_qubits)\n    else:\n        if data_reupload:\n            impl_n_layers: int = (\n                n_layers + 1\n            )  # we need L+1 according to Schuld et al.\n            data_reupload = np.ones((n_layers, n_qubits))\n        else:\n            impl_n_layers: int = n_layers\n            data_reupload = np.zeros((n_layers, n_qubits))\n            data_reupload[0][0] = 1\n\n    self.degree = np.count_nonzero(data_reupload)\n    self.data_reupload = data_reupload\n\n    if self.degree &gt; 1:\n        impl_n_layers: int = n_layers + 1  # we need L+1 according to Schuld et al.\n    else:\n        impl_n_layers = n_layers\n\n    # Initialize ansatz\n    # only weak check for str. We trust the user to provide sth useful\n    if isinstance(circuit_type, str):\n        self.pqc: Callable[[Optional[np.ndarray], int], int] = getattr(\n            Ansaetze, circuit_type or \"No_Ansatz\"\n        )()\n    else:\n        self.pqc = circuit_type()\n\n    # Initialize rng in Gates\n    Gates.init_rng(random_seed)\n\n    # Initialize state preparation\n    # first check if we have a str, list or callable\n    if isinstance(state_preparation, str):\n        # if str, use the pennylane fct\n        self._sp = [getattr(Gates, f\"{state_preparation}\")]\n    elif isinstance(state_preparation, list):\n        # if list, check if str or callable\n        if isinstance(state_preparation[0], str):\n            self._sp = [getattr(Gates, f\"{sp}\") for sp in state_preparation]\n        else:\n            self._sp = state_preparation\n    elif state_preparation is None:\n        self._sp = [lambda *args, **kwargs: None]\n    else:\n        # default to callable\n        self._sp = [state_preparation]\n\n    # Initialize encoding\n    # first check if we have a str, list or callable\n    if isinstance(encoding, str):\n        # if str, use the pennylane fct\n        self._enc = getattr(Gates, f\"{encoding}\")\n    elif isinstance(encoding, list):\n        # if list, check if str or callable\n        if isinstance(encoding[0], str):\n            self._enc = [getattr(Gates, f\"{enc}\") for enc in encoding]\n        else:\n            self._enc = encoding\n\n        if len(self._enc) == 1:\n            self._enc = self._enc[0]\n    else:\n        # default to callable\n        self._enc = encoding\n\n    # Number of possible inputs\n    self.n_input_feat = len(encoding) if isinstance(encoding, List) else 1\n\n    log.info(f\"Using {circuit_type} circuit.\")\n\n    log.info(f\"Number of implicit layers set to {impl_n_layers}.\")\n    # calculate the shape of the parameter vector here, we will re-use this in init.\n    self._params_shape: Tuple[int, int] = (\n        impl_n_layers,\n        self.pqc.n_params_per_layer(self.n_qubits),\n    )\n    # this will also be re-used in the init method,\n    # however, only if nothing is provided\n    self._inialization_strategy = initialization\n    self._initialization_domain = initialization_domain\n\n    # ..here! where we only require a rng\n    self.initialize_params(np.random.default_rng(random_seed))\n\n    # Initialize two circuits, one with the default device and\n    # one with the mixed device\n    # which allows us to later route depending on the state_vector flag\n    self.as_pauli_circuit = as_pauli_circuit\n\n    self.circuit_mixed: qml.QNode = qml.QNode(\n        self._circuit,\n        qml.device(\"default.mixed\", shots=self.shots, wires=self.n_qubits),\n    )\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.draw","title":"<code>draw(inputs=None, figure='text', *args, **kwargs)</code>","text":"<p>Draws the quantum circuit using the specified visualization method.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>Input vector for the circuit. If None, the default inputs are used.</p> <code>None</code> <code>figure</code> <code>str</code> <p>The type of figure to generate. Must be one of 'text', 'mpl', or 'tikz'. Defaults to 'text'.</p> <code>'text'</code> <code>*args,</code> <code>**kwargs (optional</code> <p>Additional arguments to the specific visualization methods</p> required <p>Returns:</p> Type Description <p>Either a string, matplotlib figure or TikzFigure object (similar to string)</p> <p>depending on the chosen visualization.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the 'figure' argument is not one of the accepted values.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def draw(self, inputs=None, figure=\"text\", *args, **kwargs):\n    \"\"\"\n    Draws the quantum circuit using the specified visualization method.\n\n    Args:\n        inputs (Optional[np.ndarray]): Input vector for the circuit. If None,\n            the default inputs are used.\n        figure (str, optional): The type of figure to generate. Must be one of\n            'text', 'mpl', or 'tikz'. Defaults to 'text'.\n        *args, **kwargs (optional): Additional arguments to the specific\n            visualization methods\n\n    Returns:\n        Either a string, matplotlib figure or TikzFigure object (similar to string)\n        depending on the chosen visualization.\n\n    Raises:\n        AssertionError: If the 'figure' argument is not one of the accepted values.\n    \"\"\"\n\n    if not isinstance(self.circuit, qml.QNode):\n        # TODO: throws strange argument error if not catched\n        return \"\"\n\n    assert figure in [\n        \"text\",\n        \"mpl\",\n        \"tikz\",\n    ], f\"Invalid figure: {figure}. Must be 'text', 'mpl' or 'tikz'.\"\n\n    inputs = self._inputs_validation(inputs)\n\n    if figure == \"mpl\":\n        result = qml.draw_mpl(self.circuit)(\n            params=self.params, inputs=inputs, *args, **kwargs\n        )\n    elif figure == \"tikz\":\n        result = QuanTikz.build(\n            self.circuit, params=self.params, inputs=inputs, *args, **kwargs\n        )\n    else:\n        result = qml.draw(self.circuit)(params=self.params, inputs=inputs)\n    return result\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.get_circuit_depth","title":"<code>get_circuit_depth(inputs=None)</code>","text":"<p>Obtain circuit depth for the model</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>The inputs, with which to call the circuit. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Circuit depth (longest path of gates in circuit.)</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def get_circuit_depth(self, inputs: Optional[np.ndarray] = None) -&gt; int:\n    \"\"\"\n    Obtain circuit depth for the model\n\n    Args:\n        inputs (Optional[np.ndarray]): The inputs, with which to call the\n            circuit. Defaults to None.\n\n    Returns:\n        int: Circuit depth (longest path of gates in circuit.)\n    \"\"\"\n    return self.get_specs(inputs)[\"resources\"].depth\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.get_specs","title":"<code>get_specs(inputs=None)</code>","text":"<p>Get pennylane specs for the model.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Optional[ndarray]</code> <p>The inputs, with which to call the circuit. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of specs. The key \"resources\" contains information about the circuit size and gate statistics.</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def get_specs(self, inputs: Optional[np.ndarray] = None) -&gt; dict:\n    \"\"\"\n    Get pennylane specs for the model.\n\n    Args:\n        inputs (Optional[np.ndarray]): The inputs, with which to call the\n            circuit. Defaults to None.\n\n    Returns:\n        dict: Dictionary of specs. The key \"resources\" contains information\n            about the circuit size and gate statistics.\n    \"\"\"\n    inputs = self._inputs_validation(inputs)\n    spec_model = deepcopy(self)\n    spec_model.noise_params = None  # remove noise\n    return qml.specs(spec_model.circuit)(self.params, inputs)\n</code></pre>"},{"location":"references/#qml_essentials.model.Model.initialize_params","title":"<code>initialize_params(rng, repeat=None, initialization=None, initialization_domain=None)</code>","text":"<p>Initializes the parameters of the model.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>A random number generator to use for initialization.</p> required <code>repeat</code> <code>int</code> <p>The number of times to repeat the parameters. If None, the number of layers is used.</p> <code>None</code> <code>initialization</code> <code>str</code> <p>The strategy to use for parameter initialization. If None, the strategy specified in the constructor is used.</p> <code>None</code> <code>initialization_domain</code> <code>List[float]</code> <p>The domain to use for parameter initialization. If None, the domain specified in the constructor is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>qml_essentials/model.py</code> <pre><code>def initialize_params(\n    self,\n    rng: np.random.Generator,\n    repeat: int = None,\n    initialization: str = None,\n    initialization_domain: List[float] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes the parameters of the model.\n\n    Args:\n        rng: A random number generator to use for initialization.\n        repeat: The number of times to repeat the parameters.\n            If None, the number of layers is used.\n        initialization: The strategy to use for parameter initialization.\n            If None, the strategy specified in the constructor is used.\n        initialization_domain: The domain to use for parameter initialization.\n            If None, the domain specified in the constructor is used.\n\n    Returns:\n        None\n    \"\"\"\n    params_shape = (\n        self._params_shape if repeat is None else [*self._params_shape, repeat]\n    )\n    # use existing strategy if not specified\n    initialization = initialization or self._inialization_strategy\n    initialization_domain = initialization_domain or self._initialization_domain\n\n    def set_control_params(params: np.ndarray, value: float) -&gt; np.ndarray:\n        indices = self.pqc.get_control_indices(self.n_qubits)\n        if indices is None:\n            warnings.warn(\n                f\"Specified {initialization} but circuit\\\n                does not contain controlled rotation gates.\\\n                Parameters are intialized randomly.\",\n                UserWarning,\n            )\n        else:\n            params[:, indices[0] : indices[1] : indices[2]] = (\n                np.ones_like(params[:, indices[0] : indices[1] : indices[2]])\n                * value\n            )\n        return params\n\n    if initialization == \"random\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n    elif initialization == \"zeros\":\n        self.params: np.ndarray = np.zeros(params_shape, requires_grad=True)\n    elif initialization == \"pi\":\n        self.params: np.ndarray = np.ones(params_shape, requires_grad=True) * np.pi\n    elif initialization == \"zero-controlled\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n        self.params = set_control_params(self.params, 0)\n    elif initialization == \"pi-controlled\":\n        self.params: np.ndarray = rng.uniform(\n            *initialization_domain, params_shape, requires_grad=True\n        )\n        self.params = set_control_params(self.params, np.pi)\n    else:\n        raise Exception(\"Invalid initialization method\")\n\n    log.info(\n        f\"Initialized parameters with shape {self.params.shape}\\\n        using strategy {initialization}.\"\n    )\n</code></pre>"},{"location":"references/#entanglement","title":"Entanglement","text":"<pre><code>from qml_essentials.entanglement import Entanglement\n</code></pre> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>class Entanglement:\n\n    @staticmethod\n    def meyer_wallach(\n        model: Model,\n        n_samples: Optional[int | None],\n        seed: Optional[int],\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; float:\n        \"\"\"\n        Calculates the entangling capacity of a given quantum circuit\n        using Meyer-Wallach measure.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (Optional[int]): Number of samples per qubit.\n                If None or &lt; 0, the current parameters of the model are used.\n            seed (Optional[int]): Seed for the random number generator.\n            scale (bool): Whether to scale the number of samples.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: Entangling capacity of the given circuit, guaranteed\n                to be between 0.0 and 1.0.\n        \"\"\"\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n\n        rng = np.random.default_rng(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            # TODO: maybe switch to JAX rng\n            model.initialize_params(rng=rng, repeat=n_samples)\n            params: np.ndarray = model.params\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n                params = model.params\n\n        n_samples = params.shape[-1]\n        mw_measure = np.zeros(n_samples)\n        qb = list(range(model.n_qubits))\n\n        # TODO: vectorize in future iterations\n        for i in range(n_samples):\n            # implicitly set input to none in case it's not needed\n            kwargs.setdefault(\"inputs\", None)\n            # explicitly set execution type because everything else won't work\n            U = model(params=params[:, :, i], execution_type=\"density\", **kwargs)\n\n            # Formula 6 in https://doi.org/10.48550/arXiv.quant-ph/0305094\n            # ---\n            entropy = 0\n            for j in range(model.n_qubits):\n                density = qml.math.partial_trace(U, qb[:j] + qb[j + 1 :])\n                # only real values, because imaginary part will be separate\n                # in all following calculations anyway\n                # entropy should be 1/2 &lt;= entropy &lt;= 1\n                entropy += np.trace((density @ density).real)\n\n            # inverse averaged entropy and scale to [0, 1]\n            mw_measure[i] = 2 * (1 - entropy / model.n_qubits)\n            # ---\n\n        # Average all iterated states\n        # catch floating point errors\n        entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n        log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n        return float(entangling_capability)\n\n    @staticmethod\n    def bell_measurements(\n        model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n    ) -&gt; float:\n        \"\"\"\n        Compute the Bell measurement for a given model.\n\n        Args:\n            model (Model): The quantum circuit model.\n            n_samples (int): The number of samples to compute the measure for.\n            seed (int): The seed for the random number generator.\n            scale (bool): Whether to scale the number of samples\n                according to the number of qubits.\n            **kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            float: The Bell measurement value.\n        \"\"\"\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n\n        def _circuit(params: np.ndarray, inputs: np.ndarray) -&gt; List[np.ndarray]:\n            \"\"\"\n            Compute the Bell measurement circuit.\n\n            Args:\n                params (np.ndarray): The model parameters.\n                inputs (np.ndarray): The input to the model.\n\n            Returns:\n                List[np.ndarray]: The probabilities of the Bell measurement.\n            \"\"\"\n            model._variational(params, inputs)\n\n            qml.map_wires(\n                model._variational,\n                {i: i + model.n_qubits for i in range(model.n_qubits)},\n            )(params, inputs)\n\n            for q in range(model.n_qubits):\n                qml.CNOT(wires=[q, q + model.n_qubits])\n                qml.H(q)\n\n            obs_wires = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n            return [qml.probs(wires=w) for w in obs_wires]\n\n        model.circuit = qml.QNode(\n            _circuit,\n            qml.device(\n                \"default.qubit\",\n                shots=model.shots,\n                wires=model.n_qubits * 2,\n            ),\n        )\n\n        rng = np.random.default_rng(seed)\n        if n_samples is not None and n_samples &gt; 0:\n            assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n            # TODO: maybe switch to JAX rng\n            model.initialize_params(rng=rng, repeat=n_samples)\n            params = model.params\n        else:\n            if seed is not None:\n                log.warning(\"Seed is ignored when samples is 0\")\n\n            if len(model.params.shape) &lt;= 2:\n                params = model.params.reshape(*model.params.shape, 1)\n            else:\n                log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n                params = model.params\n\n        n_samples = params.shape[-1]\n        mw_measure = np.zeros(n_samples)\n\n        for i in range(n_samples):\n            # implicitly set input to none in case it's not needed\n            kwargs.setdefault(\"inputs\", None)\n            exp = model(params=params[:, :, i], **kwargs)\n\n            exp = 1 - 2 * exp[:, -1]\n            mw_measure[i] = 2 * (1 - exp.mean())\n        entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n        log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n        return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.bell_measurements","title":"<code>bell_measurements(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Compute the Bell measurement for a given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>int</code> <p>The number of samples to compute the measure for.</p> required <code>seed</code> <code>int</code> <p>The seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples according to the number of qubits.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Bell measurement value.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef bell_measurements(\n    model: Model, n_samples: int, seed: int, scale: bool = False, **kwargs: Any\n) -&gt; float:\n    \"\"\"\n    Compute the Bell measurement for a given model.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (int): The number of samples to compute the measure for.\n        seed (int): The seed for the random number generator.\n        scale (bool): Whether to scale the number of samples\n            according to the number of qubits.\n        **kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: The Bell measurement value.\n    \"\"\"\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n\n    def _circuit(params: np.ndarray, inputs: np.ndarray) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the Bell measurement circuit.\n\n        Args:\n            params (np.ndarray): The model parameters.\n            inputs (np.ndarray): The input to the model.\n\n        Returns:\n            List[np.ndarray]: The probabilities of the Bell measurement.\n        \"\"\"\n        model._variational(params, inputs)\n\n        qml.map_wires(\n            model._variational,\n            {i: i + model.n_qubits for i in range(model.n_qubits)},\n        )(params, inputs)\n\n        for q in range(model.n_qubits):\n            qml.CNOT(wires=[q, q + model.n_qubits])\n            qml.H(q)\n\n        obs_wires = [(q, q + model.n_qubits) for q in range(model.n_qubits)]\n        return [qml.probs(wires=w) for w in obs_wires]\n\n    model.circuit = qml.QNode(\n        _circuit,\n        qml.device(\n            \"default.qubit\",\n            shots=model.shots,\n            wires=model.n_qubits * 2,\n        ),\n    )\n\n    rng = np.random.default_rng(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        # TODO: maybe switch to JAX rng\n        model.initialize_params(rng=rng, repeat=n_samples)\n        params = model.params\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n            params = model.params\n\n    n_samples = params.shape[-1]\n    mw_measure = np.zeros(n_samples)\n\n    for i in range(n_samples):\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        exp = model(params=params[:, :, i], **kwargs)\n\n        exp = 1 - 2 * exp[:, -1]\n        mw_measure[i] = 2 * (1 - exp.mean())\n    entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n    log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#qml_essentials.entanglement.Entanglement.meyer_wallach","title":"<code>meyer_wallach(model, n_samples, seed, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Calculates the entangling capacity of a given quantum circuit using Meyer-Wallach measure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum circuit model.</p> required <code>n_samples</code> <code>Optional[int]</code> <p>Number of samples per qubit. If None or &lt; 0, the current parameters of the model are used.</p> required <code>seed</code> <code>Optional[int]</code> <p>Seed for the random number generator.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Entangling capacity of the given circuit, guaranteed to be between 0.0 and 1.0.</p> Source code in <code>qml_essentials/entanglement.py</code> <pre><code>@staticmethod\ndef meyer_wallach(\n    model: Model,\n    n_samples: Optional[int | None],\n    seed: Optional[int],\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Calculates the entangling capacity of a given quantum circuit\n    using Meyer-Wallach measure.\n\n    Args:\n        model (Model): The quantum circuit model.\n        n_samples (Optional[int]): Number of samples per qubit.\n            If None or &lt; 0, the current parameters of the model are used.\n        seed (Optional[int]): Seed for the random number generator.\n        scale (bool): Whether to scale the number of samples.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        float: Entangling capacity of the given circuit, guaranteed\n            to be between 0.0 and 1.0.\n    \"\"\"\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n\n    rng = np.random.default_rng(seed)\n    if n_samples is not None and n_samples &gt; 0:\n        assert seed is not None, \"Seed must be provided when samples &gt; 0\"\n        # TODO: maybe switch to JAX rng\n        model.initialize_params(rng=rng, repeat=n_samples)\n        params: np.ndarray = model.params\n    else:\n        if seed is not None:\n            log.warning(\"Seed is ignored when samples is 0\")\n\n        if len(model.params.shape) &lt;= 2:\n            params = model.params.reshape(*model.params.shape, 1)\n        else:\n            log.info(f\"Using sample size of model params: {model.params.shape[-1]}\")\n            params = model.params\n\n    n_samples = params.shape[-1]\n    mw_measure = np.zeros(n_samples)\n    qb = list(range(model.n_qubits))\n\n    # TODO: vectorize in future iterations\n    for i in range(n_samples):\n        # implicitly set input to none in case it's not needed\n        kwargs.setdefault(\"inputs\", None)\n        # explicitly set execution type because everything else won't work\n        U = model(params=params[:, :, i], execution_type=\"density\", **kwargs)\n\n        # Formula 6 in https://doi.org/10.48550/arXiv.quant-ph/0305094\n        # ---\n        entropy = 0\n        for j in range(model.n_qubits):\n            density = qml.math.partial_trace(U, qb[:j] + qb[j + 1 :])\n            # only real values, because imaginary part will be separate\n            # in all following calculations anyway\n            # entropy should be 1/2 &lt;= entropy &lt;= 1\n            entropy += np.trace((density @ density).real)\n\n        # inverse averaged entropy and scale to [0, 1]\n        mw_measure[i] = 2 * (1 - entropy / model.n_qubits)\n        # ---\n\n    # Average all iterated states\n    # catch floating point errors\n    entangling_capability = min(max(mw_measure.mean(), 0.0), 1.0)\n    log.debug(f\"Variance of measure: {mw_measure.var()}\")\n\n    return float(entangling_capability)\n</code></pre>"},{"location":"references/#expressibility","title":"Expressibility","text":"<pre><code>from qml_essentials.expressibility import Expressibility\n</code></pre> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>class Expressibility:\n    @staticmethod\n    def _sample_state_fidelities(\n        model: Model,\n        x_samples: np.ndarray,\n        n_samples: int,\n        seed: int,\n        kwargs: Any,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Compute the fidelities for each pair of input samples and parameter sets.\n\n        Args:\n            model (Callable): Function that models the quantum circuit.\n            x_samples (np.ndarray): Array of shape (n_input_samples, n_features)\n                containing the input samples.\n            n_samples (int): Number of parameter sets to generate.\n            seed (int): Random number generator seed.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            np.ndarray: Array of shape (n_input_samples, n_samples)\n            containing the fidelities.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # Generate random parameter sets\n        # We need two sets of parameters, as we are computing fidelities for a\n        # pair of random state vectors\n        model.initialize_params(rng=rng, repeat=n_samples * 2)\n\n        n_x_samples = len(x_samples)\n\n        # Initialize array to store fidelities\n        fidelities: np.ndarray = np.zeros((n_x_samples, n_samples))\n\n        # Batch input samples and parameter sets for efficient computation\n        x_samples_batched: np.ndarray = x_samples.reshape(1, -1).repeat(\n            n_samples * 2, axis=0\n        )\n\n        # Compute the fidelity for each pair of input samples and parameters\n        for idx in range(n_x_samples):\n\n            # Evaluate the model for the current pair of input samples and parameters\n            # Execution type is explicitly set to density\n            sv: np.ndarray = model(\n                inputs=x_samples_batched[:, idx],\n                params=model.params,\n                execution_type=\"density\",\n                **kwargs,\n            )\n\n            # $\\sqrt{\\rho}$\n            sqrt_sv1: np.ndarray = np.array([sqrtm(m) for m in sv[:n_samples]])\n\n            # $\\sqrt{\\rho} \\sigma \\sqrt{\\rho}$\n            inner_fidelity = sqrt_sv1 @ sv[n_samples:] @ sqrt_sv1\n\n            # Compute the fidelity using the partial trace of the statevector\n            fidelity: np.ndarray = (\n                np.trace(\n                    np.array([sqrtm(m) for m in inner_fidelity]),\n                    axis1=1,\n                    axis2=2,\n                )\n                ** 2\n            )\n\n            fidelities[idx] = np.abs(fidelity)\n\n        return fidelities\n\n    @staticmethod\n    def state_fidelities(\n        seed: int,\n        n_samples: int,\n        n_bins: int,\n        model: Model,\n        n_input_samples: int = 0,\n        input_domain: List[float] = None,\n        scale: bool = False,\n        **kwargs: Any,\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Sample the state fidelities and histogram them into a 2D array.\n\n        Args:\n            seed (int): Random number generator seed.\n            n_samples (int): Number of parameter sets to generate.\n            n_bins (int): Number of histogram bins.\n            n_input_samples (int): Number of input samples.\n            input_domain (List[float]): Input domain.\n            model (Callable): Function that models the quantum circuit.\n            scale (bool): Whether to scale the number of samples and bins.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the\n                input samples, bin edges, and histogram values.\n        \"\"\"\n        if scale:\n            n_samples = np.power(2, model.n_qubits) * n_samples\n            n_bins = model.n_qubits * n_bins\n\n        if input_domain is None or n_input_samples is None or n_input_samples == 0:\n            x = np.zeros((1))\n            n_input_samples = 1\n        else:\n            x = np.linspace(*input_domain, n_input_samples, requires_grad=False)\n\n        fidelities = Expressibility._sample_state_fidelities(\n            x_samples=x,\n            n_samples=n_samples,\n            seed=seed,\n            model=model,\n            kwargs=kwargs,\n        )\n        z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n        y: np.ndarray = np.linspace(0, 1, n_bins + 1)\n\n        for i, f in enumerate(fidelities):\n            z[i], _ = np.histogram(f, bins=y)\n\n        z = z / n_samples\n\n        if z.shape[0] == 1:\n            z = z.flatten()\n\n        return x, y, z\n\n    @staticmethod\n    def _haar_probability(fidelity: float, n_qubits: int) -&gt; float:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876).\n\n        Args:\n            fidelity (float): fidelity of two parameter assignments in [0, 1]\n            n_qubits (int): number of qubits in the quantum system\n\n        Returns:\n            float: probability for a given fidelity\n        \"\"\"\n        N = 2**n_qubits\n\n        prob = (N - 1) * (1 - fidelity) ** (N - 2)\n        return prob\n\n    @staticmethod\n    def _sample_haar_integral(n_qubits: int, n_bins: int) -&gt; np.ndarray:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 2D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n\n        Returns:\n            np.ndarray: probability distribution for all fidelities\n        \"\"\"\n        dist = np.zeros(n_bins)\n        for idx in range(n_bins):\n            v = idx / n_bins\n            u = (idx + 1) / n_bins\n            dist[idx], _ = integrate.quad(\n                Expressibility._haar_probability, v, u, args=(n_qubits,)\n            )\n\n        return dist\n\n    @staticmethod\n    def haar_integral(\n        n_qubits: int,\n        n_bins: int,\n        cache: bool = True,\n        scale: bool = False,\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Calculates theoretical probability density function for random Haar states\n        as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n        into a 3D-histogram.\n\n        Args:\n            n_qubits (int): number of qubits in the quantum system\n            n_bins (int): number of histogram bins\n            cache (bool): whether to cache the haar integral\n            scale (bool): whether to scale the number of bins\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]:\n                - x component (bins): the input domain\n                - y component (probabilities): the haar probability density\n                  funtion for random Haar states\n        \"\"\"\n        if scale:\n            n_bins = n_qubits * n_bins\n\n        x = np.linspace(0, 1, n_bins)\n\n        if cache:\n            name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n            cache_folder = \".cache\"\n            if not os.path.exists(cache_folder):\n                os.mkdir(cache_folder)\n\n            file_path = os.path.join(cache_folder, name)\n\n            if os.path.isfile(file_path):\n                y = np.load(file_path)\n                return x, y\n\n        y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n        if cache:\n            np.save(file_path, y)\n\n        return x, y\n\n    @staticmethod\n    def kullback_leibler_divergence(\n        vqc_prob_dist: np.ndarray,\n        haar_dist: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the KL divergence between two probability distributions (Haar\n        probability distribution and the fidelity distribution sampled from a VQC).\n\n        Args:\n            vqc_prob_dist (np.ndarray): VQC fidelity probability distribution.\n                Should have shape (n_inputs_samples, n_bins)\n            haar_dist (np.ndarray): Haar probability distribution with shape.\n                Should have shape (n_bins, )\n\n        Returns:\n            np.ndarray: Array of KL-Divergence values for all values in axis 1\n        \"\"\"\n        if len(vqc_prob_dist.shape) &gt; 1:\n            assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n                \"All probabilities for inputs should have the same shape as Haar. \"\n                f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n            )\n        else:\n            vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n        kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n        for idx, p in enumerate(vqc_prob_dist):\n            kl_divergence[idx] = np.sum(rel_entr(p, haar_dist))\n\n        return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.haar_integral","title":"<code>haar_integral(n_qubits, n_bins, cache=True, scale=False)</code>  <code>staticmethod</code>","text":"<p>Calculates theoretical probability density function for random Haar states as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it into a 3D-histogram.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>number of qubits in the quantum system</p> required <code>n_bins</code> <code>int</code> <p>number of histogram bins</p> required <code>cache</code> <code>bool</code> <p>whether to cache the haar integral</p> <code>True</code> <code>scale</code> <code>bool</code> <p>whether to scale the number of bins</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: - x component (bins): the input domain - y component (probabilities): the haar probability density   funtion for random Haar states</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef haar_integral(\n    n_qubits: int,\n    n_bins: int,\n    cache: bool = True,\n    scale: bool = False,\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates theoretical probability density function for random Haar states\n    as proposed by Sim et al. (https://arxiv.org/abs/1905.10876) and bins it\n    into a 3D-histogram.\n\n    Args:\n        n_qubits (int): number of qubits in the quantum system\n        n_bins (int): number of histogram bins\n        cache (bool): whether to cache the haar integral\n        scale (bool): whether to scale the number of bins\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]:\n            - x component (bins): the input domain\n            - y component (probabilities): the haar probability density\n              funtion for random Haar states\n    \"\"\"\n    if scale:\n        n_bins = n_qubits * n_bins\n\n    x = np.linspace(0, 1, n_bins)\n\n    if cache:\n        name = f\"haar_{n_qubits}q_{n_bins}s_{'scaled' if scale else ''}.npy\"\n\n        cache_folder = \".cache\"\n        if not os.path.exists(cache_folder):\n            os.mkdir(cache_folder)\n\n        file_path = os.path.join(cache_folder, name)\n\n        if os.path.isfile(file_path):\n            y = np.load(file_path)\n            return x, y\n\n    y = Expressibility._sample_haar_integral(n_qubits, n_bins)\n\n    if cache:\n        np.save(file_path, y)\n\n    return x, y\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.kullback_leibler_divergence","title":"<code>kullback_leibler_divergence(vqc_prob_dist, haar_dist)</code>  <code>staticmethod</code>","text":"<p>Calculates the KL divergence between two probability distributions (Haar probability distribution and the fidelity distribution sampled from a VQC).</p> <p>Parameters:</p> Name Type Description Default <code>vqc_prob_dist</code> <code>ndarray</code> <p>VQC fidelity probability distribution. Should have shape (n_inputs_samples, n_bins)</p> required <code>haar_dist</code> <code>ndarray</code> <p>Haar probability distribution with shape. Should have shape (n_bins, )</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of KL-Divergence values for all values in axis 1</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef kullback_leibler_divergence(\n    vqc_prob_dist: np.ndarray,\n    haar_dist: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the KL divergence between two probability distributions (Haar\n    probability distribution and the fidelity distribution sampled from a VQC).\n\n    Args:\n        vqc_prob_dist (np.ndarray): VQC fidelity probability distribution.\n            Should have shape (n_inputs_samples, n_bins)\n        haar_dist (np.ndarray): Haar probability distribution with shape.\n            Should have shape (n_bins, )\n\n    Returns:\n        np.ndarray: Array of KL-Divergence values for all values in axis 1\n    \"\"\"\n    if len(vqc_prob_dist.shape) &gt; 1:\n        assert all([haar_dist.shape == p.shape for p in vqc_prob_dist]), (\n            \"All probabilities for inputs should have the same shape as Haar. \"\n            f\"Got {haar_dist.shape} for Haar and {vqc_prob_dist.shape} for VQC\"\n        )\n    else:\n        vqc_prob_dist = vqc_prob_dist.reshape((1, -1))\n\n    kl_divergence = np.zeros(vqc_prob_dist.shape[0])\n    for idx, p in enumerate(vqc_prob_dist):\n        kl_divergence[idx] = np.sum(rel_entr(p, haar_dist))\n\n    return kl_divergence\n</code></pre>"},{"location":"references/#qml_essentials.expressibility.Expressibility.state_fidelities","title":"<code>state_fidelities(seed, n_samples, n_bins, model, n_input_samples=0, input_domain=None, scale=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Sample the state fidelities and histogram them into a 2D array.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>Random number generator seed.</p> required <code>n_samples</code> <code>int</code> <p>Number of parameter sets to generate.</p> required <code>n_bins</code> <code>int</code> <p>Number of histogram bins.</p> required <code>n_input_samples</code> <code>int</code> <p>Number of input samples.</p> <code>0</code> <code>input_domain</code> <code>List[float]</code> <p>Input domain.</p> <code>None</code> <code>model</code> <code>Callable</code> <p>Function that models the quantum circuit.</p> required <code>scale</code> <code>bool</code> <p>Whether to scale the number of samples and bins.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the input samples, bin edges, and histogram values.</p> Source code in <code>qml_essentials/expressibility.py</code> <pre><code>@staticmethod\ndef state_fidelities(\n    seed: int,\n    n_samples: int,\n    n_bins: int,\n    model: Model,\n    n_input_samples: int = 0,\n    input_domain: List[float] = None,\n    scale: bool = False,\n    **kwargs: Any,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Sample the state fidelities and histogram them into a 2D array.\n\n    Args:\n        seed (int): Random number generator seed.\n        n_samples (int): Number of parameter sets to generate.\n        n_bins (int): Number of histogram bins.\n        n_input_samples (int): Number of input samples.\n        input_domain (List[float]): Input domain.\n        model (Callable): Function that models the quantum circuit.\n        scale (bool): Whether to scale the number of samples and bins.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]: Tuple containing the\n            input samples, bin edges, and histogram values.\n    \"\"\"\n    if scale:\n        n_samples = np.power(2, model.n_qubits) * n_samples\n        n_bins = model.n_qubits * n_bins\n\n    if input_domain is None or n_input_samples is None or n_input_samples == 0:\n        x = np.zeros((1))\n        n_input_samples = 1\n    else:\n        x = np.linspace(*input_domain, n_input_samples, requires_grad=False)\n\n    fidelities = Expressibility._sample_state_fidelities(\n        x_samples=x,\n        n_samples=n_samples,\n        seed=seed,\n        model=model,\n        kwargs=kwargs,\n    )\n    z: np.ndarray = np.zeros((n_input_samples, n_bins))\n\n    y: np.ndarray = np.linspace(0, 1, n_bins + 1)\n\n    for i, f in enumerate(fidelities):\n        z[i], _ = np.histogram(f, bins=y)\n\n    z = z / n_samples\n\n    if z.shape[0] == 1:\n        z = z.flatten()\n\n    return x, y, z\n</code></pre>"},{"location":"references/#coefficients","title":"Coefficients","text":"<pre><code>from qml_essentials.coefficients import Coefficients\n</code></pre> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>class Coefficients:\n\n    @staticmethod\n    def get_spectrum(\n        model: Model,\n        mfs: int = 1,\n        mts: int = 1,\n        shift=False,\n        trim=False,\n        **kwargs,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Extracts the coefficients of a given model using a FFT (np-fft).\n\n        Note that the coefficients are complex numbers, but the imaginary part\n        of the coefficients should be very close to zero, since the expectation\n        values of the Pauli operators are real numbers.\n\n        It can perform oversampling in both the frequency and time domain\n        using the `mfs` and `mts` arguments.\n\n        Args:\n            model (Model): The model to sample.\n            mfs (int): Multiplicator for the highest frequency. Default is 2.\n            mts (int): Multiplicator for the number of time samples. Default is 1.\n            shift (bool): Whether to apply np-fftshift. Default is False.\n            trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n                Default is False.\n            kwargs (Any): Additional keyword arguments for the model function.\n\n        Returns:\n            np.ndarray: The sampled Fourier coefficients.\n        \"\"\"\n        kwargs.setdefault(\"force_mean\", True)\n        kwargs.setdefault(\"execution_type\", \"expval\")\n\n        coeffs, freqs = Coefficients._fourier_transform(\n            model, mfs=mfs, mts=mts, **kwargs\n        )\n\n        if not np.isclose(np.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n            raise ValueError(\n                f\"Spectrum is not real. Imaginary part of coefficients is:\\\n                {np.sum(coeffs).imag}\"\n            )\n\n        if trim and coeffs.size % 2 == 0:\n            coeffs = np.delete(coeffs, len(coeffs) // 2)\n            freqs = np.delete(freqs, len(freqs) // 2)\n\n        if shift:\n            return np.fft.fftshift(coeffs), np.fft.fftshift(freqs)\n        else:\n            return coeffs, freqs\n\n    @staticmethod\n    def _fourier_transform(\n        model: Model, mfs: int, mts: int, **kwargs: Any\n    ) -&gt; np.ndarray:\n        # Create a frequency vector with as many frequencies as model degrees,\n        # oversampled by nfs\n        n_freqs: int = 2 * mfs * model.degree + 1\n\n        start, stop, step = 0, 2 * mts * np.pi, 2 * np.pi / n_freqs\n        # Stretch according to the number of frequencies\n        inputs: np.ndarray = np.arange(start, stop, step) % (2 * np.pi)\n\n        # permute with input dimensionality\n        nd_inputs = np.array(\n            np.meshgrid(*[inputs] * model.n_input_feat)\n        ).T.reshape(-1, model.n_input_feat)\n\n        # Output vector is not necessarily the same length as input\n        outputs = model(inputs=nd_inputs, **kwargs).reshape(\n            inputs.shape * model.n_input_feat\n        )\n\n        coeffs = np.fft.fftn(outputs)\n\n        assert (\n            mts * n_freqs,\n        ) * model.n_input_feat == coeffs.shape, f\"Expected shape\\\n            {(mts * n_freqs,) * model.n_input_feat} but got {coeffs.shape}\"\n\n        freqs = np.fft.fftfreq(mts * n_freqs, 1 / n_freqs)\n\n        # Run the fft and rearrange + normalize the output\n        return coeffs / outputs.size, freqs\n\n    @staticmethod\n    def get_psd(coeffs: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n        Args:\n            coeffs (np.ndarray): The Fourier coefficients.\n\n        Returns:\n            np.ndarray: The power spectral density.\n        \"\"\"\n        # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n        def abs2(x):\n            return x.real**2 + x.imag**2\n\n        scale = 2.0 / (len(coeffs) ** 2)\n        return scale * abs2(coeffs)\n\n    @staticmethod\n    def evaluate_Fourier_series(\n        coefficients: np.ndarray,\n        frequencies: np.ndarray,\n        inputs: Union[np.ndarray, list, float],\n    ) -&gt; float:\n        \"\"\"\n        Evaluate the function value of a Fourier series at one point.\n\n        Args:\n            coefficients (np.ndarray): Coefficients of the Fourier series.\n            frequencies (np.ndarray): Corresponding frequencies.\n            inputs (np.ndarray): Point at which to evaluate the function.\n        Returns:\n            float: The function value at the input point.\n        \"\"\"\n        dims = len(coefficients.shape)\n\n        if not isinstance(inputs, (np.ndarray, list)):\n            inputs = [inputs]\n\n        frequencies = np.stack(np.meshgrid(*[frequencies] * dims)).T.reshape(-1, dims)\n        freq_inputs = np.einsum(\"...j,j-&gt;...\", frequencies, inputs)\n        coeffs = coefficients.flatten()\n        freq_inputs = freq_inputs.flatten()\n\n        exp = 0.0\n        for omega_x, c in zip(freq_inputs, coeffs):\n            exp += c * np.exp(1j * omega_x)\n\n        return np.real_if_close(exp)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.evaluate_Fourier_series","title":"<code>evaluate_Fourier_series(coefficients, frequencies, inputs)</code>  <code>staticmethod</code>","text":"<p>Evaluate the function value of a Fourier series at one point.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>Coefficients of the Fourier series.</p> required <code>frequencies</code> <code>ndarray</code> <p>Corresponding frequencies.</p> required <code>inputs</code> <code>ndarray</code> <p>Point at which to evaluate the function.</p> required <p>Returns:     float: The function value at the input point.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef evaluate_Fourier_series(\n    coefficients: np.ndarray,\n    frequencies: np.ndarray,\n    inputs: Union[np.ndarray, list, float],\n) -&gt; float:\n    \"\"\"\n    Evaluate the function value of a Fourier series at one point.\n\n    Args:\n        coefficients (np.ndarray): Coefficients of the Fourier series.\n        frequencies (np.ndarray): Corresponding frequencies.\n        inputs (np.ndarray): Point at which to evaluate the function.\n    Returns:\n        float: The function value at the input point.\n    \"\"\"\n    dims = len(coefficients.shape)\n\n    if not isinstance(inputs, (np.ndarray, list)):\n        inputs = [inputs]\n\n    frequencies = np.stack(np.meshgrid(*[frequencies] * dims)).T.reshape(-1, dims)\n    freq_inputs = np.einsum(\"...j,j-&gt;...\", frequencies, inputs)\n    coeffs = coefficients.flatten()\n    freq_inputs = freq_inputs.flatten()\n\n    exp = 0.0\n    for omega_x, c in zip(freq_inputs, coeffs):\n        exp += c * np.exp(1j * omega_x)\n\n    return np.real_if_close(exp)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_psd","title":"<code>get_psd(coeffs)</code>  <code>staticmethod</code>","text":"<p>Calculates the power spectral density (PSD) from given Fourier coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>The Fourier coefficients.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The power spectral density.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_psd(coeffs: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the power spectral density (PSD) from given Fourier coefficients.\n\n    Args:\n        coeffs (np.ndarray): The Fourier coefficients.\n\n    Returns:\n        np.ndarray: The power spectral density.\n    \"\"\"\n    # TODO: if we apply trim=True in advance, this will be slightly wrong..\n\n    def abs2(x):\n        return x.real**2 + x.imag**2\n\n    scale = 2.0 / (len(coeffs) ** 2)\n    return scale * abs2(coeffs)\n</code></pre>"},{"location":"references/#qml_essentials.coefficients.Coefficients.get_spectrum","title":"<code>get_spectrum(model, mfs=1, mts=1, shift=False, trim=False, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Extracts the coefficients of a given model using a FFT (np-fft).</p> <p>Note that the coefficients are complex numbers, but the imaginary part of the coefficients should be very close to zero, since the expectation values of the Pauli operators are real numbers.</p> <p>It can perform oversampling in both the frequency and time domain using the <code>mfs</code> and <code>mts</code> arguments.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to sample.</p> required <code>mfs</code> <code>int</code> <p>Multiplicator for the highest frequency. Default is 2.</p> <code>1</code> <code>mts</code> <code>int</code> <p>Multiplicator for the number of time samples. Default is 1.</p> <code>1</code> <code>shift</code> <code>bool</code> <p>Whether to apply np-fftshift. Default is False.</p> <code>False</code> <code>trim</code> <code>bool</code> <p>Whether to remove the Nyquist frequency if spectrum is even. Default is False.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments for the model function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The sampled Fourier coefficients.</p> Source code in <code>qml_essentials/coefficients.py</code> <pre><code>@staticmethod\ndef get_spectrum(\n    model: Model,\n    mfs: int = 1,\n    mts: int = 1,\n    shift=False,\n    trim=False,\n    **kwargs,\n) -&gt; np.ndarray:\n    \"\"\"\n    Extracts the coefficients of a given model using a FFT (np-fft).\n\n    Note that the coefficients are complex numbers, but the imaginary part\n    of the coefficients should be very close to zero, since the expectation\n    values of the Pauli operators are real numbers.\n\n    It can perform oversampling in both the frequency and time domain\n    using the `mfs` and `mts` arguments.\n\n    Args:\n        model (Model): The model to sample.\n        mfs (int): Multiplicator for the highest frequency. Default is 2.\n        mts (int): Multiplicator for the number of time samples. Default is 1.\n        shift (bool): Whether to apply np-fftshift. Default is False.\n        trim (bool): Whether to remove the Nyquist frequency if spectrum is even.\n            Default is False.\n        kwargs (Any): Additional keyword arguments for the model function.\n\n    Returns:\n        np.ndarray: The sampled Fourier coefficients.\n    \"\"\"\n    kwargs.setdefault(\"force_mean\", True)\n    kwargs.setdefault(\"execution_type\", \"expval\")\n\n    coeffs, freqs = Coefficients._fourier_transform(\n        model, mfs=mfs, mts=mts, **kwargs\n    )\n\n    if not np.isclose(np.sum(coeffs).imag, 0.0, rtol=1.0e-5):\n        raise ValueError(\n            f\"Spectrum is not real. Imaginary part of coefficients is:\\\n            {np.sum(coeffs).imag}\"\n        )\n\n    if trim and coeffs.size % 2 == 0:\n        coeffs = np.delete(coeffs, len(coeffs) // 2)\n        freqs = np.delete(freqs, len(freqs) // 2)\n\n    if shift:\n        return np.fft.fftshift(coeffs), np.fft.fftshift(freqs)\n    else:\n        return coeffs, freqs\n</code></pre>"},{"location":"training/","title":"Training","text":"<p>This section describes how to use the model provided with this package, using a simple training scenario as an example.</p> <p>We consider a Fourier series with \\(n\\) frequencies defined as follows:</p> \\[ f(x, \\boldsymbol{\\theta})=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) e^{i \\omega x}=\\sum_{\\omega \\in \\boldsymbol{\\Omega}} c_{\\omega}(\\boldsymbol{\\theta}) \\left(\\cos(\\omega x) + i \\sin(\\omega x)\\right) \\] <p>Here, \\(\\omega \\in \\boldsymbol{\\Omega}\\) are the frequencies in the spectrum with the Fourier coefficients \\(c_{\\omega}(\\boldsymbol{\\theta})\\), parameterized by the set of trainable parameters \\(\\boldsymbol{\\theta}\\).</p> <p>As shown by Schuld et al. (2020), a quantum circuit, parametrised by \\(\\boldsymbol{\\theta}\\) and input \\(x\\) and is equivalent to the Fourier series representation. Such circuits must be of the following form: $$ f(x, \\boldsymbol{\\theta})=\\langle 0\\vert^{\\otimes n} U^{\\dagger}(x, \\boldsymbol{\\theta}) \\mathcal{M} U(x, \\boldsymbol{\\theta})\\vert 0\\rangle^{\\otimes n} $$</p> <p>Therefore, training such a model on a Fourier series is a proof-of-concept which we want to demonstrate here.</p> <p>Let's start with building our dataset. A Fourier series with \\(4\\) frequencies: <pre><code>import pennylane.numpy as np\nimport matplotlib.pyplot as plt\n\ndomain = [-np.pi, np.pi]\nomegas = np.array([1, 2, 3, 4])\ncoefficients = np.array([0.5, 0.5, 0.5, 0.5])\n\n# Calculate the number of required samples to satisfy the Nyquist criterium\nn_d = int(np.ceil(2 * np.max(np.abs(domain)) * np.max(omegas)))\n# Sample the domain linearly\nx = np.linspace(domain[0], domain[1], num=n_d)\n\n# define our Fourier series f(x)\ndef f(x):\n    return 1 / np.linalg.norm(omegas) * np.sum(coefficients * np.cos(omegas.T * x))\n\n# evaluate f(x) on the domain samples\ny = np.stack([f(sample) for sample in x])\n\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.show()\n</code></pre></p> <p> </p> <p>Note that we chose the coefficients to be all \\(0.5\\). Play around with those values to change the magnitude of each frequency component. Also note that we're using the Pennylane version of Numpy, which is required because of the optimizer that we will be using later. Now that we have our \"dataset\", let's move on and build a model: <pre><code>from qml_essentials.model import Model\n\nmodel = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Circuit_19\",\n)\n</code></pre></p> <p>This is the minimal amout of information needed. According to the work referenced above, a model with \\(4\\) qubits should be capable of learning a Fourier series with \\(4\\) frequencies, considering single qubit Pauli encoding (which we have by default).</p> <p>Now, let's train our model: <pre><code>import pennylane as qml\n\nopt = qml.AdamOptimizer(stepsize=0.01)\n\ndef cost_fct(params):\n    y_hat = model(params=params, inputs=x, force_mean=True)\n\n    return np.mean((y_hat - y) ** 2)\n\nfor epoch in range(1, 1001):\n    model.params, cost_val = opt.step_and_cost(cost_fct, model.params)\n\n    if epoch % 100 == 0:\n        print(f\"Epoch: {epoch}, Cost: {cost_val:.4f}\")\n\nplt.plot(x, y, label=\"True function\")\nplt.plot(x, model(params=model.params, inputs=x, force_mean=True), label=\"Model prediction\")\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.legend()\nplt.show()\n</code></pre></p> <pre><code>Epoch: 100, Cost: 0.0081\nEpoch: 200, Cost: 0.0073\nEpoch: 300, Cost: 0.0051\nEpoch: 400, Cost: 0.0043\nEpoch: 500, Cost: 0.0036\nEpoch: 600, Cost: 0.0022\nEpoch: 700, Cost: 0.0014\nEpoch: 800, Cost: 0.0008\nEpoch: 900, Cost: 0.0006\nEpoch: 1000, Cost: 0.0001\n</code></pre> <p> </p> <p>As you can see, the model is able to learn the Fourier series with the \\(4\\) frequencies.</p> <p>Btw. if you're in a hurry, we have a Jupyter notebook with the exact same example here .</p> <p>Wondering what to do next? You can try a few different models, and see how they perform. If you're curious, checkout how this correlates with the Entanglement and Expressibility of the model.</p>"},{"location":"usage/","title":"Usage","text":"<p>Central component of our package is the Fourier model which you can import with  <pre><code>from qml_essentials.model import Model\n</code></pre></p> <p>In the simplest scenario, one would instantiate such a model with \\(2\\) qubits and a single layer using the \"Hardware Efficient\" ansatz by: <pre><code>model = Model(\n    n_qubits=4,\n    n_layers=1,\n    circuit_type=\"Hardware_Efficient\",\n)\n</code></pre></p> <p>You can take a look at your model, by simply calling <pre><code>model.draw(figure=\"mpl\")\n</code></pre></p> <p> </p> <p>Looks good to you?  Head over to the Training page for getting started with an easy example </p> <p>Calling the model without any (<code>None</code>) values for the <code>params</code> and <code>inputs</code> argument, will implicitly call the model with the recently (or initial) parameters and <code>0</code>s as input.</p> <p>In the following we will describe some concepts of the <code>Model</code> class. For a more detailled reference on the methods and arguments that are available, please see the references page.</p>"},{"location":"usage/#the_essentials","title":"The essentials","text":"<p>There is much more to this package, than just providing a Fourier model. You can calculate the Expressibility or Entangling Capability besides the Coefficients which are unique to this kind of QML interpretation. You can also provide a custom circuit, by instantiating from the <code>Circuit</code> class in <code>qml_essentials.ansaetze.Circuit</code>. See page Ansaetze for more details and a list of available Ansatzes that we provide with this package.</p>"},{"location":"usage/#data-reuploading","title":"Data-Reuploading","text":"<p>This idea is one of the core features of our framework and builds upon the work by Schuld et al. (2020). Essentially it allows us to represent a quantum circuit as a truncated Fourier series which is a powerfull feature that enables the model to mimic arbitrary non-linear functions. The number of frequencies that the model can represent is constrained by the number of data encoding steps within the circuit.</p> <p>Typically, there is a reuploading step after each layer and on each qubit (<code>data_reupload=True</code>). However, our package also allows you to specify and array with the number of rows representing the qubits and number of columns representing the layers. Then a <code>1</code> means that encoding is applied at the corresponding position within the circuit.</p> <p>In the following example, the model has two reuploading steps (<code>model.degree</code> = 2) although it would be capable of representing four frequencies:</p> <pre><code>model = Model(\n    n_qubits=2,\n    n_layers=2,\n    circuit_type=\"Hardware_Efficient\",\n    data_reupload=[[1, 0], [0, 1]],\n)\n</code></pre> <p>Checkout the Coefficients page for more details on how you can visualize such a model using tools from signal analysis.</p>"},{"location":"usage/#parameter_initialization","title":"Parameter Initialization","text":"<p>The initialization strategy can be set when instantiating the model with the <code>initialization</code> argument.</p> <p>The default strategy is \"random\" which will result in random initialization of the parameters using the domain specified in the <code>initialization_domain</code> argument. Other options are: - \"zeros\": All parameters are initialized to \\(0\\) - \"zero-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(0\\) - \"pi-controlled\": All parameters are initialized to randomly except for the angles of the controlled rotations which are initialized to \\(\\\\pi\\) - \"pi\": All parameters are initialized to \\(\\\\pi\\)</p> <p>The <code>initialize_params</code> method provides the option to re-initialise the parameters after model instantiation using either the previous configuration or a different strategy.</p>"},{"location":"usage/#encoding","title":"Encoding","text":"<p>The encoding can be set when instantiating the model with the <code>encoding</code> argument.</p> <p>The default encoding is \"RX\" which will result in a single RX rotation per qubit. Other options are:</p> <ul> <li>A string such as <code>\"RX\"</code> that will result in a single RX rotation per qubit</li> <li>A list of strings such as <code>[\"RX\", \"RY\"]</code> that will result in a sequential RX and RY rotation per qubit</li> <li>Any callable such as <code>Gates.RX</code></li> <li>A list of callables such as <code>[Gates.RX, Gates.RY]</code></li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class. If a list of encodings is provided, the input is assumed to be multi-dimensional. Otherwise multiple inputs are treated as batches of inputs.</p> <p>If you want to visualize zero-valued encoding gates in the model, set <code>remove_zero_encoding</code> to <code>False</code> on instantiation.</p>"},{"location":"usage/#state_preparation","title":"State Preparation","text":"<p>While the encoding is applied in each data-reuploading step, the state preparation is only applied at the beginning of the circuit, but after the <code>StatePreparation</code> noise (see below for details). The default is no state preparation. Similar to the encoding, you can provide the <code>state_preparation</code> argument as</p> <ul> <li>A string such as <code>\"H\"</code> that will result in a single Hadamard per qubit</li> <li>A list of strings such as <code>[\"H\", \"H\"]</code> that will result in two consecutive Hadamards per qubit</li> <li>Any callable such as <code>Gates.H</code></li> <li>A list of callables such as <code>[Gates.H, Gates.H]</code></li> </ul> <p>See page Ansaetze for more details regarding the <code>Gates</code> class.</p>"},{"location":"usage/#output_shape","title":"Output Shape","text":"<p>The output shape is determined by the <code>output_qubit</code> argument, provided in the instantiation of the model. When set to -1 all qubits are measured which will result in the shape being of size \\(n\\) by default (depending on the execution type, see below).</p> <p>If <code>force_mean</code> flag is set when calling the model, the output is averaged to a single value (while keeping the batch/ input dimension). This is usually helpful, if you want to perform a n-local measurement over all qubits where only the average over \\(n\\) expecation values is of interest.</p>"},{"location":"usage/#execution_type","title":"Execution Type","text":"<p>Our model be simulated in different ways by setting the <code>execution_type</code> property, when calling the model, to:</p> <ul> <li><code>expval</code>: Returns the expectation value between \\(0\\) and \\(1\\)</li> <li><code>density</code>: Calculates the density matrix</li> <li><code>probs</code>: Simulates the model with the number of shots, set by <code>model.shots</code></li> </ul>"},{"location":"usage/#noise","title":"Noise","text":"<p>Noise can be added to the model by providing a <code>noise_params</code> argument, when calling the model, which is a dictionary with following keys</p> <ul> <li><code>BitFlip</code></li> <li><code>PhaseFlip</code></li> <li><code>AmplitudeDamping</code></li> <li><code>PhaseDamping</code></li> <li><code>Depolarizing</code></li> <li><code>StatePreparation</code></li> <li><code>Measurement</code></li> </ul> <p>with values between \\(0\\) and \\(1\\). Additionally, a <code>GateError</code> can be applied, which controls the variance of a Gaussian distribution with zero mean applied on the input vector.</p> <p>While <code>BitFlip</code>, <code>PhaseFlip</code>, <code>Depolarizing</code> and <code>GateError</code>s are applied on each gate, <code>AmplitudeDamping</code>, <code>PhaseDamping</code>, <code>StatePreparation</code> and <code>Measurement</code> are applied on the whole circuit.</p> <p>Furthermore, <code>ThermalRelaxation</code> can be applied.  Instead of the probability, the entry for this type of error consists of another dict with the keys:</p> <ul> <li><code>t1</code>: The relative T1 relaxation time (a typical value might be \\(180\\mathrm{us}\\))</li> <li><code>t2</code>: The relative T2 relaxation time (a typical value might be \\(100\\mathrm{us}\\))</li> <li><code>t_factor</code>: The relative gate time factor (a typical value might be \\(0.018\\mathrm{us}\\))</li> </ul> <p>The units can be ignored as we are only interested in relative times, above values might belong to some superconducting system. Note that <code>t2</code> is required to be max. \\(2\\times\\)<code>t1</code>. Based on <code>t_factor</code> and the circuit depth the execution time is estimated, and therefore the influence of thermal relaxation over time.</p>"},{"location":"usage/#caching","title":"Caching","text":"<p>To speed up calculation, you can add <code>cache=True</code> when calling the model. The result of the model call will then be stored in a numpy format in a folder <code>.cache</code>. Each result is being identified by a md5 hash that is a representation of the following model properties:</p> <ul> <li>number of qubits</li> <li>number of layers</li> <li>ansatz</li> <li>data-reuploading flag</li> <li>parameters</li> <li>noise parameters</li> <li>execution type</li> <li>inputs</li> <li>output qubit(s)</li> </ul>"},{"location":"usage/#quantikz_export","title":"Quantikz Export","text":"<p>In addition to the printing the model to console and into a figure using matplotlib (thanks to Pennylane); our framework extends this functionality by allowing you to create nice Quantikz figures that you can embedd in a Latex document . This can be achieved by </p> <pre><code>fig = model.draw(figure=\"tikz\", inputs_symbols=\"x\", gate_values=False)\nfig.export(\"tikz_circuit.tex\", full_document=True)\n</code></pre> <p> </p> <p>Inputs are represented with \"x\" by default, which can be changed by adjusting the optional parameter <code>inputs_symbols</code>. If you want to see the actual gate values instead of variables, simply set <code>gate_values=True</code> which is also the default option. The returned <code>fig</code> variable is a <code>TikzFigure</code> object that stores the Latex string and allows exporting to a specified file. To create a document that can be compiled, simply pass <code>full_document=True</code> when calling <code>export</code>.</p>"}]}